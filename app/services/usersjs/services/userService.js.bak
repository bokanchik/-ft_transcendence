// Logique métier (authentification, validation, etc.), sans reply
import * as userModel from '../models/userModel.js';
import * as passwordUtils from '../utils/pswdUtils.js';
import { ConflictError, ValidationError, NotFoundError } from '../utils/appError.js';

// --- Fonctions d'aide (Helpers) ---

/**
 * Génère une URL d'avatar par défaut en utilisant ui-avatars.com.
 * @param {string} name - Le nom à utiliser pour générer l'avatar.
 * @returns {string} L'URL de l'avatar généré.
 */
function generateDefaultAvatarUrl(name) {
    const encodedName = encodeURIComponent(name);
    return `https://ui-avatars.com/api/?name=${encodedName}&background=random&color=fff&size=128`;
}

/**
 * Vérifie basiquement si une chaîne ressemble à une URL HTTP/HTTPS valide.
 * @param {string} urlString - La chaîne à vérifier.
 * @returns {boolean} True si valide, false sinon.
 */
function isValidHttpUrl(urlString) {
    if (typeof urlString !== 'string') return false;
    try {
        const url = new URL(urlString);
        return url.protocol === "http:" || url.protocol === "https:";
    } catch (_) {
        return false;
    }
}

/**
 * Vérifie basiquement si une chaîne ressemble à un email.
 * @param {string} emailString - La chaîne à vérifier.
 * @returns {boolean} True si valide, false sinon.
 */
function isValidEmailFormat(emailString) {
    if (typeof emailString !== 'string') return false;
    return emailString.includes('@') && emailString.length > 3;
}

export async function loginUser({ identifier, password }) {
	console.log(`Attempting to log in user with identifier: ${identifier}`);
	let user;
	const isEmail = identifier.includes('@');
	if (isEmail) {
		user = await userModel.getUserByEmailFromDb(identifier);
	}
	else {
		user = await userModel.getUserByUsernameFromDb(identifier);
	}
	if (!user || !(await passwordUtils.comparePassword(password, user.password_hash))) {
		throw new ValidationError('Invalid credentials');
	}
	const { password_hash, ...userPassLess } = user;
	return userPassLess;
}

export async function createUserAccount(userData) {
	console.log('Creating a new user account');
	const { username, email, password, display_name, avatar_url } = userData;
	const existingUser = await userModel.getUserByUsernameFromDb(username);
	if (existingUser) {
		throw new ConflictError('Username already exists');
	}
	const existingEmail = await userModel.getUserByEmailFromDb(email);
	if (existingEmail) {
		throw new ConflictError('Email already exists');
	}
	const hashedPassword = await passwordUtils.hashPassword(password);

	let finalAvatarUrl = avatar_url;

	if (!finalAvatarUrl || finalAvatarUrl.trim() === "") {
		finalAvatarUrl = generateDefaultAvatarUrl(display_name);
		console.log(`No avatar provided for ${username}. Using default: ${finalAvatarUrl}`);
	}
	const newUser = await userModel.createUser({ username, email, password_hash: hashedPassword, display_name, avatar_url: finalAvatarUrl });
	return newUser;
}

export async function getAllUsers() {
	console.log('Fetching all users from the database');
	return await userModel.getAllUsersFromDb();
}

export async function getUserById(userId) {
	console.log('Fetching user by ID from the database');
	const user = await userModel.getUserByIdFromDb(userId);
	if (!user) {
		throw new NotFoundError('User not found');
	}
	return user;
}

export async function getUserByUsername(username) {
	console.log('Fetching user by username from the database');
	const user = await userModel.getUserByUsernameFromDb(username);
	if (!user) {
		throw new NotFoundError('User not found');
	}
	return user;
}

export async function getUserByEmail(email) {
	console.log('Fetching user by email from the database');
	const user = await userModel.getUserByEmailFromDb(email);
	if (!user) {
		throw new NotFoundError('User not found');
	}
	return user;
}

export async function getUserMatches(userId) {
	console.log('Fetching user matches from the database');
	const matches = await userModel.getUserMatchesFromDb(userId);
	if (!matches) {
		throw new NotFoundError('No matches found for this user');
	}
	return matches;
}

export async function updateUserProfile(userId, updates) {
    console.log(`Attempting to update profile for user ID: ${userId}`);

    const currentUser = await userModel.getUserByIdFromDb(userId);
    if (!currentUser) {
        throw new NotFoundError(`User with ID ${userId} not found`);
    }

    const processedUpdates = {};
    let needsDefaultAvatar = false;

    if (updates.hasOwnProperty('display_name')) {
        if (typeof updates.display_name === 'string' && updates.display_name.trim().length > 0) {
             processedUpdates.display_name = updates.display_name.trim();
        } else {
             console.warn(`Invalid display_name provided for user ${userId}, ignoring.`);
             throw new ValidationError('Display name cannot be empty');
        }
    }

    if (updates.hasOwnProperty('email')) {
         const potentialEmail = updates.email;
         if (potentialEmail && typeof potentialEmail === 'string' && isValidEmailFormat(potentialEmail)) {
             processedUpdates.email = potentialEmail.trim();
         } else if (potentialEmail) { // Log only if a non-empty invalid value was provided
             console.warn(`Invalid email format provided for user ${userId}, ignoring: ${potentialEmail}`);
             throw new ValidationError('Invalid email format provided.');
         }
    }

    if (updates.hasOwnProperty('avatar_url')) {
        const potentialAvatar = updates.avatar_url;
        if (potentialAvatar === null || (typeof potentialAvatar === 'string' && potentialAvatar.trim() === '')) {
            needsDefaultAvatar = true;
        } else if (isValidHttpUrl(potentialAvatar)) {
            processedUpdates.avatar_url = potentialAvatar;
        } else {
            console.warn(`Invalid avatar_url format provided for user ${userId}, ignoring: ${potentialAvatar}`);
            throw new ValidationError('Invalid avatar URL format provided.');
        }
    }

    if (needsDefaultAvatar) {
        const nameForAvatar = processedUpdates.display_name || currentUser.display_name;
        if (nameForAvatar) {
            processedUpdates.avatar_url = generateDefaultAvatarUrl(nameForAvatar);
            console.log(`Avatar explicitly removed or invalid for user ${userId}. Setting default based on name '${nameForAvatar}': ${processedUpdates.avatar_url}`);
        } else {
            // Cas rare où l'utilisateur n'a pas de display_name et n'en fournit pas de nouveau
            processedUpdates.avatar_url = null; // Ou une URL statique générique
            console.warn(`Could not determine name for default avatar for user ${userId}. Setting avatar_url to null.`);
        }
    }

    // 4. Vérifier s'il y a des changements *effectifs* par rapport à l'utilisateur actuel
    const changesToApply = {};
    for (const key in processedUpdates) {
        // Vérifie si la clé existe dans processedUpdates ET si la valeur est différente de celle actuelle
        if (processedUpdates.hasOwnProperty(key) && processedUpdates[key] !== currentUser[key]) {
            changesToApply[key] = processedUpdates[key];
        }
    }

    if (Object.keys(changesToApply).length === 0) {
        console.log(`No effective changes detected for user ${userId}. Profile remains unchanged.`);
        return currentUser; // Retourne l'utilisateur actuel car rien n'a besoin d'être mis à jour
    }

    console.log(`Applying changes for user ${userId}:`, changesToApply);

    // 5. Vérifications d'unicité (Conflits) UNIQUEMENT pour les champs qui changent
    if (changesToApply.hasOwnProperty('display_name')) {
        const existingUser = await userModel.getUserByDisplayNameFromDb(changesToApply.display_name);
        if (existingUser && existingUser.id !== userId) {
            throw new ConflictError(`Display name '${changesToApply.display_name}' is already taken.`);
        }
    }
    if (changesToApply.hasOwnProperty('email')) {
        const existingUser = await userModel.getUserByEmailFromDb(changesToApply.email);
        if (existingUser && existingUser.id !== userId) {
            throw new ConflictError(`Email '${changesToApply.email}' is already taken.`);
        }
    }

    // 6. Mettre à jour en Base de Données
    try {
        const result = await userModel.updateUserInDb(userId, changesToApply);

        // Bien que nous ayons vérifié les changements, `result.changes` reste une confirmation utile de la DB.
        if (result.changes === 0) {
             // Peut arriver si la donnée était identique entre temps ou autre souci DB non lancé comme erreur
             console.warn(`Database reported 0 changes for user ${userId} despite pending updates. Returning current data.`);
              // On retourne quand même une version fraîche pour être sûr.
              const finalUserCheck = await userModel.getUserByIdFromDb(userId);
              if (!finalUserCheck) throw new NotFoundError(`User ${userId} disappeared after update attempt.`); // Très improbable
              return finalUserCheck;
        }

    } catch (dbError) {
         console.error(`Database error during profile update for user ${userId}:`, dbError);
         throw new Error(`Failed to update profile for user ${userId} due to a database issue.`);
    }


    // 7. Récupérer et retourner les données utilisateur mises à jour
    console.log(`Profile successfully updated for user ${userId}. Fetching updated data...`);
    const updatedUser = await userModel.getUserByIdFromDb(userId);
    if (!updatedUser) {
        // Sécurité : ne devrait pas arriver si l'update a réussi
        throw new Error(`Failed to retrieve user ${userId} immediately after successful update.`);
    }
    return updatedUser; // Contient les données mises à jour
}

// export async function updateUserProfile(userId, updates) {
// 	console.log(`Updating profile for user ID: ${userId}`);
//
//
// 	// 1. Filtrer les champs autorisés (sécurité)
// 	const allowedUpdates = {};
// 	if (updates.hasOwnProperty('display_name')) {
// 		allowedUpdates.display_name = updates.display_name;
// 	}
// 	if (updates.hasOwnProperty('avatar_url')) {
// 		if (typeof updates.avatar_url === 'string' && updates.avatar_url.startsWith('http')) { // Simple validation
// 			allowedUpdates.avatar_url = updates.avatar_url;
// 		} else {
// 			console.warn(`Invalid avatar_url format received for user ${userId}, ignoring.`);
// 		}
// 	}
// 	if (updates.hasOwnProperty('email') && updates.email !== null && updates.email !== "") { // Ne pas permettre null ou vide pour email
// 		// Validation supplémentaire (le format est déjà vérifié par le schéma)
// 		if (typeof updates.email === 'string' && updates.email.includes('@')) {
// 			allowedUpdates.email = updates.email;
// 		} else {
// 			console.warn(`Invalid email format received for user ${userId}, ignoring.`);
// 		}
// 	}
//
//
// 	// 2. Vérifications métier (ex: unicité)
// 	if (allowedUpdates.display_name) {
// 		const existingUser = await userModel.getUserByDisplayNameFromDb(allowedUpdates.display_name);
// 		// Vérifie si le display_name existe ET appartient à un autre utilisateur
// 		if (existingUser && existingUser.id !== userId) {
// 			throw new ConflictError('Display name already taken by another user.');
// 		}
// 	}
// 	if (allowedUpdates.email) {
// 		const existingUser = await userModel.getUserByEmailFromDb(allowedUpdates.email);
// 		// Vérifie si l'email existe ET appartient à un autre utilisateur
// 		if (existingUser && existingUser.id !== userId) {
// 			throw new ConflictError('Email already taken by another user.');
// 		}
// 	}
//
// 	if (Object.keys(allowedUpdates).length === 0) {
// 		console.log("No valid fields provided for update.");
// 		// Retourne l'utilisateur actuel sans modification, ou lance une erreur BadRequest ?
// 		// Pour l'instant, on retourne l'utilisateur actuel.
// 		const currentUser = await userModel.getUserByIdFromDb(userId);
// 		if (!currentUser) throw new NotFoundError('User not found');
// 		return currentUser;
// 		// Ou : throw new ValidationError("No valid fields provided for update.");
// 	}
// 	// 3. Appeler le modèle pour mettre à jour la base de données
// 	const result = await userModel.updateUserInDb(userId, allowedUpdates);
//
// 	// 4. Vérifier si la mise à jour a réussi
// 	if (result.changes === 0) {
// 		// Cela peut arriver si l'ID utilisateur n'existe pas, ou si les données fournies sont identiques aux données actuelles.
// 		// Vérifions si l'utilisateur existe toujours.
// 		const userExists = await userModel.getUserByIdFromDb(userId);
// 		if (!userExists) {
// 			throw new NotFoundError('User not found');
// 		}
// 		console.log(`No changes detected for user ${userId}. Data might be identical.`);
// 		// Retourne les données actuelles car rien n'a changé ou l'utilisateur n'existe pas
// 		return userExists;
// 	}
//
// 	// 5. Récupérer et retourner les données utilisateur mises à jour (sans le hash du mdp)
// 	const updatedUser = await userModel.getUserByIdFromDb(userId);
// 	if (!updatedUser) {
// 		// Ne devrait pas arriver si result.changes > 0, mais sécurité
// 		throw new NotFoundError('User not found after update attempt.');
// 	}
// 	return updatedUser; // getUserByIdFromDb ne retourne déjà pas le hash
// }
