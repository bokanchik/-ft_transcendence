// app/frontend/conf/utils/config.ts
// app/frontend/conf/services/config.ts

const USER_API_PREFIX = '/api/users';
const GAME_API_PREFIX = '/api/game';

export const config = {
    api: {
        users: {
            // URL_ALL_USERS
            all: `${USER_API_PREFIX}/`,
            // URL_USER
            byId: (userId: number | string) => `${USER_API_PREFIX}/${userId}`,
            // URL_USER_ME
            me: `${USER_API_PREFIX}/me`,
            // URL_USER_MATCH
            matchesByUserId: (userId: number | string) => `${USER_API_PREFIX}/${userId}/matches`,
        },
        auth: {
            // URL_LOGIN
            login: `${USER_API_PREFIX}/auth/login`,
            // URL_REGISTER
            register: `${USER_API_PREFIX}/auth/register`,
            // URL_LOGOUT
            logout: `${USER_API_PREFIX}/auth/logout`,
            // URL_CSRF
            csrf: `${USER_API_PREFIX}/csrf-token`,
        },
        friends: {
            // URL_FRIEND_LIST
            list: `${USER_API_PREFIX}/friends/friends`,
            // URL_FRIEND_REQUEST (pour envoyer une demande)
            sendRequest: `${USER_API_PREFIX}/friends/requests`,
            // URL_FRIEND_RECEIVED
            receivedRequests: `${USER_API_PREFIX}/friends/requests/received`,
            // URL_FRIEND_SENT
            sentRequests: `${USER_API_PREFIX}/friends/requests/sent`,
            // URL_FRIEND_ACCEPT
            acceptRequest: (friendshipId: number) => `${USER_API_PREFIX}/friends/requests/${friendshipId}/accept`,
            // URL_FRIEND_DECLINE
            declineRequest: (friendshipId: number) => `${USER_API_PREFIX}/friends/requests/${friendshipId}/decline`,
            // URL_FRIEND_CANCEL
            cancelRequest: (friendshipId: number) => `${USER_API_PREFIX}/friends/requests/${friendshipId}/cancel`,
            // URL_FRIEND_REMOVE
            remove: (friendshipId: number) => `${USER_API_PREFIX}/friends/${friendshipId}/remove`,
        },
        game: {
            // URL_MATCH (POST pour cr√©er, GET pour r√©cup√©rer)
            match: (matchId?: string) => matchId ? `${GAME_API_PREFIX}/match/${matchId}` : `${GAME_API_PREFIX}/match`,
            // URL_MATCH_USER
            matchHistory: (userId: number | string) => `${GAME_API_PREFIX}/match/history/${userId}`,
        }
    }
};// app/frontend/conf/utils/types.ts
import { z } from 'zod';
import { UserBaseSchema } from '../shared/schemas/usersSchemas.js';

export const ApiSuccessResponseSchema = z.object({
	message: z.string(),
	user: UserBaseSchema, // Ou un autre sch√©ma ??
});
export type ApiSuccessResponse = z.infer<typeof ApiSuccessResponseSchema>;

export const ApiErrorResponseSchema = z.object({
	error: z.string(),
	statusCode: z.number().optional(), // Si on fait les codes
	details: z.any().optional(),
});
export type ApiErrorResponse = z.infer<typeof ApiErrorResponseSchema>;

// typer g√©n√©riquement avec Zod si le type de `data` !!!
// en TypeScript :
export type ApiResult<TSuccessData = ApiSuccessResponse> =
	| { success: true; data: TSuccessData }
	| { success: false; error: string; details?: any; statusCode?: number };
// app/frontend/conf/utils/domUtils.ts
// app/frontend/conf/utils/domUtils.ts
import { showToast } from "../components/toast.js";

export function createElement<K extends keyof HTMLElementTagNameMap>(
    tagName: K,
    options?: {
        id?: string;
        className?: string;
        textContent?: string;
        innerHTML?: string;
        name?: string; // <--- ADDED 'name'
        href?: string;
        src?: string;
        alt?: string;
        type?: string;
        value?: string;
        placeholder?: string;
        readonly?: boolean;
        required?: boolean;
        minLength?: number;
        maxLength?: number;
        min?: string;
        max?: string;
        // Add more common attributes as needed
    },
    children?: (HTMLElement | string | null | undefined)[]
): HTMLElementTagNameMap[K] {
    const el = document.createElement(tagName);

    if (options?.id) el.id = options.id;
    if (options?.className) el.className = options.className;
    if (options?.textContent) el.textContent = options.textContent;
    if (options?.innerHTML && !children?.length) el.innerHTML = options.innerHTML;
    if (options?.name) el.setAttribute('name', options.name); // Use setAttribute for name for broader compatibility

    if (options?.href && el instanceof HTMLAnchorElement) el.href = options.href;
    if (options?.src && el instanceof HTMLImageElement) el.src = options.src;
    if (options?.alt && el instanceof HTMLImageElement) el.alt = options.alt;
    
    // Handle 'type' attribute carefully
    if (options?.type) {
        if (el instanceof HTMLInputElement) {
            el.type = options.type;
        } else if (el instanceof HTMLButtonElement) {
            // Ensure type is one of the valid ones for buttons
            const validType = options.type as "submit" | "reset" | "button";
            if (["submit", "reset", "button"].includes(validType)) {
                el.type = validType;
            }
        }
        // 'type' for HTMLSelectElement is generally not set this way.
        // It's 'select-one' or 'select-multiple' based on the 'multiple' attribute.
    }

    if (options?.value && (el instanceof HTMLInputElement || el instanceof HTMLSelectElement || el instanceof HTMLTextAreaElement)) el.value = options.value;
    if (options?.placeholder && (el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement)) el.placeholder = options.placeholder;
    if (options?.readonly && el instanceof HTMLInputElement) el.readOnly = options.readonly;
    if (options?.required && (el instanceof HTMLInputElement || el instanceof HTMLSelectElement || el instanceof HTMLTextAreaElement)) el.required = options.required;
    if (options?.minLength && (el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement)) el.minLength = options.minLength;
    if (options?.maxLength && (el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement)) el.maxLength = options.maxLength;
    if (options?.min && el instanceof HTMLInputElement) el.min = options.min;
    if (options?.max && el instanceof HTMLInputElement) el.max = options.max;

    if (children) {
        children.forEach(child => {
            if (child === null || child === undefined) return;
            if (typeof child === 'string') {
                el.appendChild(document.createTextNode(child));
            } else {
                el.appendChild(child);
            }
        });
    }
    return el;
}


// Reusable Action Button
interface ActionButtonProps {
    text: string;
    baseClass?: string; // e.g., 'bg-blue-500'
    variant?: 'primary' | 'secondary' | 'danger' | 'warning' | 'success' | 'info'; // For predefined styles
    onClick: (event: MouseEvent) => Promise<void> | void;
    icon?: string; // Optional icon HTML or class
    dataAction?: string;
    dataId?: string | number;
    disabled?: boolean;
}

export function createActionButton(props: ActionButtonProps): HTMLButtonElement {
    const button = createElement('button', {
        textContent: props.text,
        type: 'button'
    });

    let colorClasses = 'bg-gray-500 hover:bg-gray-600'; // Default
    if (props.baseClass) {
        colorClasses = props.baseClass;
    } else if (props.variant) {
        switch (props.variant) {
            case 'primary': colorClasses = 'bg-blue-500 hover:bg-blue-600'; break;
            case 'secondary': colorClasses = 'bg-gray-200 hover:bg-gray-300 text-gray-800'; break;
            case 'danger': colorClasses = 'bg-red-500 hover:bg-red-600'; break;
            case 'warning': colorClasses = 'bg-yellow-500 hover:bg-yellow-600 text-black'; break;
            case 'success': colorClasses = 'bg-green-500 hover:bg-green-600'; break;
            case 'info': colorClasses = 'bg-teal-500 hover:bg-teal-600'; break;
        }
    }
    
    button.className = `${colorClasses} text-white text-xs font-semibold py-1 px-2.5 rounded hover:opacity-80 transition-opacity disabled:opacity-50 disabled:cursor-not-allowed`;
    if (props.disabled) {
        button.disabled = true;
    }

    if (props.dataAction) button.dataset.action = props.dataAction;
    if (props.dataId !== undefined) button.dataset.id = props.dataId.toString();


    button.addEventListener('click', async (e) => {
        e.stopPropagation();
        if (button.disabled) return; // Prevent action if already disabled

        button.disabled = true;
        const originalText = button.textContent;
        button.textContent = '...'; // Loading indicator

        try {
            await props.onClick(e);
        } catch (error) {
            const actionText = props.dataAction || originalText || 'action';
            console.error(`Error performing action "${actionText}":`, error);
            showToast(`Failed to ${actionText.toLowerCase()}.`, 'error');
            button.textContent = originalText;
            button.disabled = false;
        }
        // Note: Re-enabling the button and restoring text on success should be handled
        // by the parent component logic (e.g., after a list re-renders or state updates)
        // unless the action is purely local and doesn't trigger a re-render.
        // If not :
        // if (button.disabled) { // If not re-enabled by parent logic
        //     button.textContent = originalText;
        //     button.disabled = false;
        // }
    });
    return button;
}


// Helper for input fields
interface InputFieldOptions {
    type?: string;
    placeholder?: string;
    required?: boolean;
    value?: string;
    minLength?: number;
    maxLength?: number;
    min?: string; // for type=number
    max?: string; // for type=number
    readonly?: boolean;
    inputClass?: string;
    labelClass?: string;
    wrapperClass?: string;
    pattern?: string;
    helpText?: string;
}
export function createInputField(id: string, labelText: string, options: InputFieldOptions = {}): HTMLDivElement {
    const fieldDiv = createElement('div', {
        className: options.wrapperClass || 'mb-4'
    });

    const label = createElement('label', {
        textContent: labelText,
        className: options.labelClass || 'block text-sm font-medium text-gray-700 mb-1'
    });
    label.htmlFor = id;

    const input = createElement('input', {
        type: options.type || 'text',
        id: id,
        name: id, // Good practice to have name attribute
        required: options.required,
        value: options.value || '',
        placeholder: options.placeholder,
        minLength: options.minLength,
        maxLength: options.maxLength,
        min: options.min,
        max: options.max,
        readonly: options.readonly,
        className: options.inputClass || 'w-full p-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500'
    });
    if (options.pattern) input.pattern = options.pattern;


    fieldDiv.appendChild(label);
    fieldDiv.appendChild(input);

    if (options.helpText) {
        const helpTextEl = createElement('p', {
            textContent: options.helpText,
            className: 'text-xs text-gray-500 mt-1'
        });
        fieldDiv.appendChild(helpTextEl);
    }
    
    return fieldDiv;
}

// Helper for select fields (from aliasFormPage)
export function createSelectField(id: string, labelText: string, optionValues: (string | {value: string, text: string})[], options: InputFieldOptions = {}): HTMLDivElement {
    const fieldDiv = createElement('div', {
        className: options.wrapperClass || 'mb-4'
    });

    const label = createElement('label', {
        textContent: labelText,
        className: options.labelClass || 'block text-sm font-medium text-gray-700 mb-1'
    });
    label.htmlFor = id;

    const select = createElement('select', {
        id: id,
        name: id,
        required: options.required,
        className: options.inputClass || 'w-full p-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500'
    });

    optionValues.forEach(opt => {
        const optionEl = document.createElement('option');
        if (typeof opt === 'string') {
            optionEl.value = opt;
            optionEl.textContent = opt;
        } else {
            optionEl.value = opt.value;
            optionEl.textContent = opt.text;
        }
        if (options.value === optionEl.value) {
            optionEl.selected = true;
        }
        select.appendChild(optionEl);
    });

    fieldDiv.appendChild(label);
    fieldDiv.appendChild(select);
     if (options.helpText) {
        const helpTextEl = createElement('p', {
            textContent: options.helpText,
            className: 'text-xs text-gray-500 mt-1'
        });
        fieldDiv.appendChild(helpTextEl);
    }
    return fieldDiv;
}// app/frontend/conf/tailwind.config.js
module.exports = {
    content: [
      './src/**/*.{html,js,ts}',
      './dist/**/*.html',
    ],
    theme: {
      extend: {
        keyframes: {
          'fade-in': {
            '0%': { opacity: '0', transform: 'translateY(10px)', boxShadow: 'none' },
            '100%': { opacity: '1', transform: 'translateY(0)', boxShadow: '0px 4px 20px rgba(0, 0, 0, 0.1)' },
          },
        },
        animation: {
          'fade-in': 'fade-in 0.5s ease-out forwards',
        },
      },
    },
    plugins: [],
  }
  // app/frontend/conf/components/headerComponent.ts
// src/components/headerComponent.ts
import { User } from '../shared/schemas/usersSchemas.js';
import { navigateTo } from '../services/router.js'; // Assuming navigateTo handles data-link
import { logout } from '../services/authService.js';
import { showToast } from './toast.js';

interface HeaderProps {
	currentUser: User;
	// onLanguageChange?: () => void;
}

interface NavLink {
	href: string;
	text: string;
}

export function HeaderComponent(props: HeaderProps): HTMLElement {
	const { currentUser } = props;

	const headerContainer = document.createElement('div');
	headerContainer.className = 'flex justify-between items-center p-4 border-b border-gray-200 bg-white';

	// --- Left side: Language Button ---
	const leftSection = document.createElement('div');
	const langButton = document.createElement('button');
	langButton.className = 'bg-blue-500 text-white font-bold py-2 px-4 rounded-lg text-sm hover:bg-blue-600 transition-colors';
	langButton.textContent = 'ENG';
	// langButton.addEventListener('click', () => { /* ... */ });
	leftSection.appendChild(langButton);

	// --- Center: Navigation Links ---
	const centerSection = document.createElement('div');
	centerSection.className = 'flex-grow flex justify-center space-x-4 sm:space-x-6'; // flex-grow to push others, justify-center

	const navLinks: NavLink[] = [
		{ href: '/', text: 'Home' },
		{ href: '/game', text: 'Game' },
		{ href: '/dashboard', text: 'Dashboard' },
	];

	navLinks.forEach(linkInfo => {
		const linkElement = document.createElement('a');
		linkElement.href = linkInfo.href;
		linkElement.textContent = linkInfo.text;
		linkElement.className = 'text-gray-600 hover:text-blue-600 font-medium transition-colors px-2 py-1 text-sm sm:text-base';
		linkElement.setAttribute('data-link', '');
		centerSection.appendChild(linkElement);
	});

	// --- Right side: User Header (Avatar & Menu) ---
	const rightSection = document.createElement('div');
	const userHeader = document.createElement('div');
	userHeader.className = 'flex items-center space-x-4 relative';

	const avatarDisplayWrapper = document.createElement('div');
	avatarDisplayWrapper.className = 'bg-orange-400 p-2 rounded-lg flex items-center space-x-3 cursor-pointer select-none';

	const displayNameHeader = document.createElement('span');
	displayNameHeader.className = 'text-white font-semibold text-sm';
	displayNameHeader.textContent = currentUser.display_name || currentUser.username;

	const avatarHeader = document.createElement('img');
	avatarHeader.className = 'w-10 h-10 rounded-full object-cover border-2 border-white';
	const avatarFallbackName = currentUser.display_name || currentUser.username;
	avatarHeader.src = currentUser.avatar_url || `https://ui-avatars.com/api/?name=${encodeURIComponent(avatarFallbackName)}&background=0D8ABC&color=fff&size=128`;
	avatarHeader.alt = 'User Avatar';

	avatarDisplayWrapper.appendChild(displayNameHeader);
	avatarDisplayWrapper.appendChild(avatarHeader);

	const miniMenu = document.createElement('div');
	miniMenu.className = 'absolute right-0 mt-2 w-40 bg-white rounded-lg shadow-lg border border-gray-200 z-50 hidden flex-col';
	miniMenu.style.top = '110%';

	const settingsButton = document.createElement('a');
	settingsButton.href = '/profile';
	settingsButton.setAttribute('data-link', '');
	settingsButton.className = 'block px-4 py-2 text-gray-700 hover:bg-gray-100 rounded-t-lg';
	settingsButton.textContent = 'Settings';

	const logoutButtonEl = document.createElement('button');
	logoutButtonEl.className = 'block w-full text-left px-4 py-2 text-gray-700 hover:bg-gray-100 rounded-b-lg';
	logoutButtonEl.textContent = 'Logout';
	logoutButtonEl.addEventListener('click', async (e) => {
		e.stopPropagation();
		try {
			await logout();
			showToast('You have been logged out.', 'success');
		} catch (error) {
			showToast('Error logging out.', 'error');
		} finally {
			navigateTo('/login');
		}
	});

	miniMenu.appendChild(settingsButton);
	miniMenu.appendChild(logoutButtonEl);
	userHeader.appendChild(avatarDisplayWrapper);
	userHeader.appendChild(miniMenu);
	rightSection.appendChild(userHeader);


	// Menu open/close logic
	let menuOpen = false;
	const toggleMenu = (show: boolean) => {
		menuOpen = show;
		miniMenu.classList.toggle('hidden', !menuOpen);
	};

	avatarDisplayWrapper.addEventListener('click', (e) => {
		e.stopPropagation();
		toggleMenu(!menuOpen);
	});

	const globalClickListener = (event: MouseEvent) => {
		if (menuOpen && !userHeader.contains(event.target as Node)) {
			toggleMenu(false);
		}
	};
	document.addEventListener('click', globalClickListener);
	// Consider cleanup only if this component could be frequently removed/re-added or if multiple such components exist on one page.

	// Assemble the header sections
	headerContainer.appendChild(leftSection);
	headerContainer.appendChild(centerSection);
	headerContainer.appendChild(rightSection);

	return headerContainer;
}
// app/frontend/conf/components/userList.ts
import { Friend, PendingFriendRequest } from '../shared/schemas/friendsSchemas.js';
import { User as ApiUser, UserOnlineStatus } from '../shared/schemas/usersSchemas.js';
import { createActionButton } from '../utils/domUtils.js';

export interface UserListProps {
	users: ApiUser[];
	friends: Friend[];
	sentRequests: PendingFriendRequest[];
	receivedRequests: PendingFriendRequest[];
	currentUserId: number;
	onSendRequest: (targetUserId: number) => Promise<void>;
	onCancelRequest: (friendshipId: number) => Promise<void>;
	onAcceptRequest: (friendshipId: number) => Promise<void>;
	onDeclineRequest: (friendshipId: number) => Promise<void>;
	onRemoveFriend?: (targetUserId: number) => Promise<void>; // Rendu optionnel
}

export function UserList(props: UserListProps): HTMLElement {
	const {
		users,
		friends,
		sentRequests,
		receivedRequests,
		currentUserId,
		onSendRequest,
		onCancelRequest,
		onAcceptRequest,
		onDeclineRequest
	} = props;

	const ul = document.createElement('ul');
	ul.className = 'space-y-4';

	const otherUsers = users.filter(user => user.id !== currentUserId);

	if (otherUsers.length === 0) {
		ul.innerHTML = '<li class="text-center text-gray-500 py-4">Aucun autre utilisateur √† afficher.</li>';
		return ul;
	}

	otherUsers.forEach(user => {
		const li = document.createElement('li');
		li.className = 'p-4 bg-white border border-gray-200 rounded-lg shadow-sm flex flex-col sm:flex-row justify-between items-start sm:items-center space-y-3 sm:space-y-0 hover:shadow-md transition-shadow duration-200';
		li.dataset.userId = user.id.toString();

		const userPrimaryInfoContainer = document.createElement('div');
		userPrimaryInfoContainer.className = 'flex items-center w-full sm:w-auto';

		const displayName = user.display_name || user.username;
		const avatarUrl = user.avatar_url;
		const status: UserOnlineStatus = user.status as UserOnlineStatus;
		const wins = user.wins ?? 0;
		const losses = user.losses ?? 0;

		const avatarSrc = avatarUrl || `https://ui-avatars.com/api/?name=${encodeURIComponent(displayName)}&background=random&color=fff&size=40`;

		let statusIndicatorClass = 'bg-gray-400'; // Offline par d√©faut
		let statusText = 'Offline';

		if (status === UserOnlineStatus.ONLINE) {
			statusIndicatorClass = 'bg-green-500';
			statusText = 'Online';
		} else if (status === UserOnlineStatus.IN_GAME) {
			statusIndicatorClass = 'bg-yellow-500';
			statusText = 'In Game';
		}

		userPrimaryInfoContainer.innerHTML = `
            <img src="${avatarSrc}" alt="${displayName}" class="w-12 h-12 rounded-full mr-4 object-cover">
            <div class="flex-grow">
                <div class="flex items-center mb-1">
                    <span class="inline-block w-3 h-3 ${statusIndicatorClass} rounded-full mr-2" title="${statusText}"></span>
                    <strong class="text-lg text-gray-700">${displayName}</strong>
                    <!-- Le (@username) a √©t√© enlev√© d'ici -->
                </div>
                <div class="text-xs text-gray-500">
                    <span>Wins: ${wins}</span> | <span>Losses: ${losses}</span>
                </div>
            </div>
        `;
		li.appendChild(userPrimaryInfoContainer);

		const actionContainer = document.createElement('div');
		actionContainer.className = 'flex flex-col items-end space-y-1 text-sm self-end sm:self-center pt-2 sm:pt-0 sm:ml-4';


		const friendshipStatus = document.createElement('span');
		friendshipStatus.className = 'text-xs italic text-gray-500 mb-1';

		let actionButton: HTMLButtonElement | null = null;
		let actionButtonsContainer: HTMLElement | null = null;

		const isFriend = friends.some(f => f.friend_id === user.id);
		const sentRequestToThisUser = sentRequests.find(r => r.receiver?.id === user.id);
		const receivedRequestFromThisUser = receivedRequests.find(r => r.requester?.id === user.id);

		if (isFriend) {
			friendshipStatus.textContent = 'Friends';
			friendshipStatus.className += ' text-green-600 font-semibold';
		} else if (sentRequestToThisUser) {
			friendshipStatus.textContent = 'Friend request sent';
			friendshipStatus.className += ' text-yellow-600';
			actionButton = createActionButton({
				text: 'Cancel Request',
				variant: 'warning', // 'bg-yellow-500 text-black',
				onClick: () => onCancelRequest(sentRequestToThisUser.friendship_id)
			});
		} else if (receivedRequestFromThisUser) {
			friendshipStatus.textContent = 'Request received';
			friendshipStatus.className += ' text-indigo-600';

			actionButtonsContainer = document.createElement('div');
			actionButtonsContainer.className = 'flex space-x-1'; // Mettre les boutons c√¥te √† c√¥te
			const acceptBtn = createActionButton({
				text: 'Accept',
				variant: 'success', // 'bg-green-500'
				onClick: () => onAcceptRequest(receivedRequestFromThisUser.friendship_id)
				});
			const declineBtn = createActionButton({
				text: 'Decline',
				variant: 'danger', // 'bg-red-500'
				onClick: () => onDeclineRequest(receivedRequestFromThisUser.friendship_id)
				});
			actionButtonsContainer.appendChild(acceptBtn);
			actionButtonsContainer.appendChild(declineBtn);
		} else {
			friendshipStatus.textContent = 'Not Friends'; // Statut par d√©faut si aucune des conditions
			actionButton = createActionButton({
				text: 'Inviter', // 'bg-blue-500'
				onClick: () => onSendRequest(user.id)
			});
		}

		actionContainer.prepend(friendshipStatus);

		if (actionButtonsContainer) {
			actionContainer.appendChild(actionButtonsContainer);
		} else if (actionButton) {
			actionContainer.appendChild(actionButton);
		}

		li.appendChild(actionContainer);

		ul.appendChild(li);
	});

	return ul;
}

// function createActionButton(text: string, baseClass: string, onClick: () => Promise<void>): HTMLButtonElement {
// 	const button = document.createElement('button');
// 	button.textContent = text;
// 	button.className = `${baseClass} text-white text-xs font-semibold py-1 px-2.5 rounded hover:opacity-80 transition-opacity disabled:opacity-50`;
// 	button.addEventListener('click', async (e) => {
// 		e.stopPropagation();
// 		button.disabled = true;
// 		const originalText = button.textContent;
// 		button.textContent = '...';
// 		try {
// 			await onClick();
// 		} catch (error) {
// 			const actionText = originalText || 'action';
// 			console.error(`Error performing action "${actionText}":`, error);
// 			alert(`Failed to ${actionText.toLowerCase()}.`);
// 			button.textContent = originalText;
// 			button.disabled = false;
// 		}
// 	});
// 	return button;
// }// app/frontend/conf/components/friendsList.ts
// /components/friendsList.ts
import { Friend } from '../shared/schemas/friendsSchemas.js';
import { UserOnlineStatus } from '../shared/schemas/usersSchemas.js';
import { navigateTo } from '../services/router.js';
import { showCustomConfirm, showToast } from './toast.js';

interface FriendsListProps {
	friends: Friend[];
	onRemoveFriend: (friendshipId: number) => Promise<void>;
}

export function FriendsListComponent(props: FriendsListProps): HTMLElement {
	const { friends, onRemoveFriend } = props;

	const section = document.createElement('div');
	section.id = 'friends-list-section';
	section.className = 'mt-8 p-6 bg-white border border-gray-200 rounded-lg shadow-lg'; // Changed background for better contrast

	const title = document.createElement('h2');
	title.className = 'text-2xl font-semibold text-gray-800 mb-6';
	title.innerHTML = `Mes Amis (<span id="friends-count">${friends.length}</span>)`;

	const ul = document.createElement('ul');
	ul.id = 'friends-list';
	ul.className = 'space-y-4';

	if (!friends.length) {
		ul.innerHTML = `<li class="text-gray-500 italic p-4 text-center">Vous n'avez pas encore d'amis.</li>`;
	} else {
		friends.forEach(friend => {
			const displayName = friend.friend_display_name;
			const avatarUrl = friend.friend_avatar_url;
			const friendId = friend.friend_id;
			const friendshipId = friend.friendship_id;
			const status = friend.friend_online_status;
			const wins = friend.friend_wins ?? 0;
			const losses = friend.friend_losses ?? 0;

			const avatarFallbackName = displayName.charAt(0).toUpperCase();
			const avatar = avatarUrl || `https://ui-avatars.com/api/?name=${encodeURIComponent(displayName)}&background=random&color=fff&size=40`;

			let statusIndicatorClass = 'bg-gray-400';
			let statusText = 'Offline';

			if (status === UserOnlineStatus.ONLINE) {
				statusIndicatorClass = 'bg-green-500';
				statusText = 'Online';
			} else if (status === UserOnlineStatus.IN_GAME) {
				statusIndicatorClass = 'bg-yellow-500';
				statusText = 'In Game';
			}

			const li = document.createElement('li');
			li.dataset.friendId = friendId.toString();
			li.dataset.friendshipId = friendshipId.toString();
			li.className = 'p-4 bg-gray-50 border border-gray-200 rounded-lg shadow-sm flex flex-col sm:flex-row justify-between items-start sm:items-center space-y-3 sm:space-y-0';
			li.innerHTML = `
                <div class="flex items-center w-full sm:w-auto">
                    <img src="${avatar}" alt="${displayName}" class="w-12 h-12 rounded-full mr-4 object-cover">
                    <div class="flex-grow">
                        <div class="flex items-center mb-1">
                            <span class="inline-block w-3 h-3 ${statusIndicatorClass} rounded-full mr-2" title="${statusText}"></span>
                            <strong class="text-lg text-gray-700">${displayName}</strong>
                        </div>
                        <div class="text-xs text-gray-500">
                            <span>Wins: ${wins}</span> | <span>Losses: ${losses}</span>
                        </div>
                    </div>
                </div>
                <div class="flex space-x-2 self-end sm:self-center pt-2 sm:pt-0">
                    <button data-action="view-profile" data-user-id="${friendId}" class="text-xs bg-blue-500 hover:bg-blue-600 text-white font-semibold py-1.5 px-3 rounded-md">Profil</button>
                    <button data-action="remove-friend" data-friendship-id="${friendshipId}" class="text-xs bg-red-500 hover:bg-red-600 text-white font-semibold py-1.5 px-3 rounded-md">Supprimer</button>
                </div>
            `;
			ul.appendChild(li);
		});
	}

	section.appendChild(title);
	section.appendChild(ul);

	ul.addEventListener('click', async (event) => {
		const target = event.target as HTMLElement;
		const button = target.closest('button[data-action]') as HTMLButtonElement | null;
		if (!button) return;

		const action = button.dataset.action;
		if (action === 'view-profile') {
			const userIdToView = button.dataset.userId; // Get userId from button
			if (userIdToView) {
				navigateTo(`/profile/${userIdToView}`);
			}
		} else if (action === 'remove-friend') {
			const friendshipIdToRemove = button.dataset.friendshipId; // Get friendshipId from button
			if (friendshipIdToRemove) {
				// Utilisation de la nouvelle bo√Æte de dialogue personnalis√©e
				const confirmed = await showCustomConfirm(
					'√ätes-vous s√ªr de vouloir supprimer cet ami de votre liste ? Cette action est irr√©versible.',
					'Supprimer l\'ami' // Titre optionnel
				);

				if (confirmed) {
					button.disabled = true;
					button.textContent = '...';
					try {
						await onRemoveFriend(parseInt(friendshipIdToRemove, 10));
						// showToast('Ami supprim√© avec succ√®s.', 'success'); // Exemple
					} catch (error: any) {
						console.error('Erreur lors de la suppression de l\'ami:', error);
						showToast(`Erreur: ${error.message || 'Impossible de supprimer l\'ami.'}`, 'error');
						button.disabled = false;
						button.textContent = 'Supprimer';
					}
				}
			}
			// if (friendshipIdToRemove && confirm(`√ätes-vous s√ªr de vouloir supprimer cet ami ?`)) {
			//     button.disabled = true;
			//     button.textContent = '...';
			//     try {
			//         await onRemoveFriend(parseInt(friendshipIdToRemove, 10));
			//         // button.closest('li')?.remove();
			//     } catch (error: any) {
			//         console.error('Erreur lors de la suppression de l\'ami:', error);
			//         alert(`Erreur: ${error.message || 'Impossible de supprimer l\'ami.'}`);
			//         button.disabled = false;
			//         button.textContent = 'Supprimer';
			//     }
			// }
		}
	});

	return section;
}
// app/frontend/conf/components/settingsForm.ts
// /components/profileForm.ts
import { User, UpdateUserPayload } from '../shared/schemas/usersSchemas.js'; // S'assurer que ApiResult est import√©
import { ApiResult } from '../utils/types.js'; // S'assurer que ApiResult est import√©

interface ProfileFormProps {
	user: User;
	onProfileUpdate: (payload: UpdateUserPayload) => Promise<ApiResult>;
}

export function SettingsForm(props: ProfileFormProps): HTMLElement {
	const { user, onProfileUpdate } = props;

	const formElement = document.createElement('form');
	formElement.id = 'profile-form-component'; // ID unique
	formElement.innerHTML = `
        <!-- Message d'√©tat -->
        <div id="profile-message" class="mb-4 text-center text-sm min-h-[1.25rem]"></div>

        <!-- Champ Username (souvent non modifiable) -->
        <div class="mb-4">
            <label for="username" class="block text-gray-700 text-sm font-bold mb-2">Nom d'utilisateur</label>
            <input type="text" id="username" name="username" readonly
                   value="${user.username}"
                   class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 bg-gray-200 cursor-not-allowed leading-tight focus:outline-none focus:shadow-outline">
            <p class="text-xs text-gray-500 mt-1">Le nom d'utilisateur ne peut pas √™tre modifi√©.</p>
        </div>

        <!-- Champ Email -->
        <div class="mb-4">
            <label for="email" class="block text-gray-700 text-sm font-bold mb-2">Adresse Email</label>
            <input type="email" id="email" name="email" required
                   value="${user.email || ''}"
                   placeholder="Votre adresse email"
                   class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
        </div>

        <!-- Champ Display Name -->
        <div class="mb-4">
            <label for="display_name" class="block text-gray-700 text-sm font-bold mb-2">Nom Affich√©</label>
            <input type="text" id="display_name" name="display_name" required
                   value="${user.display_name || ''}"
                   placeholder="Comment voulez-vous √™tre appel√© ?"
                   class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
        </div>

        <!-- Champ Avatar URL (Optionnel) -->
        <div class="mb-6">
            <label for="avatar_url" class="block text-gray-700 text-sm font-bold mb-2">URL de l'Avatar (Optionnel)</label>
            <input type="url" id="avatar_url" name="avatar_url"
                   value="${user.avatar_url || ''}"
                   placeholder="https://example.com/avatar.png"
                   class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
             <p class="text-xs text-gray-500 mt-1">Laissez vide si vous n'avez pas d'avatar.</p>
        </div>

        <div class="flex items-center justify-between mt-6 border-t pt-6">
            <button type="submit" id="save-profile-button"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline w-full sm:w-auto transition duration-300 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
                Enregistrer les modifications
            </button>
            <!-- Le lien de retour est mieux g√©r√© par la page parente -->
        </div>
    `;

	const emailInput = formElement.querySelector('#email') as HTMLInputElement;
	const displayNameInput = formElement.querySelector('#display_name') as HTMLInputElement;
	const avatarUrlInput = formElement.querySelector('#avatar_url') as HTMLInputElement;
	const messageDiv = formElement.querySelector('#profile-message') as HTMLDivElement;
	const saveButton = formElement.querySelector('#save-profile-button') as HTMLButtonElement;

	formElement.addEventListener('submit', async (event) => {
		event.preventDefault();
		messageDiv.textContent = 'Sauvegarde en cours...';
		messageDiv.className = 'mb-4 text-center text-sm text-gray-600 min-h-[1.25rem]';
		saveButton.disabled = true;
		saveButton.textContent = 'Sauvegarde...';

		const updatedEmail = emailInput.value.trim();
		const updatedDisplayName = displayNameInput.value.trim();
		const updatedAvatarUrl = avatarUrlInput.value.trim();

		if (!updatedEmail || !updatedDisplayName) {
			messageDiv.textContent = 'Veuillez remplir les champs Email et Nom affich√©.';
			messageDiv.className = 'mb-4 text-center text-sm text-red-600 font-semibold min-h-[1.25rem]';
			saveButton.disabled = false;
			saveButton.textContent = 'Enregistrer les modifications';
			return;
		}

		const payload: UpdateUserPayload = {
			email: updatedEmail,
			display_name: updatedDisplayName,
			avatar_url: updatedAvatarUrl,
		};

		const result = await onProfileUpdate(payload);

		saveButton.disabled = false;
		saveButton.textContent = 'Enregistrer les modifications';

		if (result.success) {
			messageDiv.textContent = 'Profil mis √† jour avec succ√®s !';
			messageDiv.className = 'mb-4 text-center text-sm text-green-600 font-semibold min-h-[1.25rem]';

			// Mettre √† jour les valeurs des champs avec les donn√©es retourn√©es par l'API
			// Cela est important si le backend effectue une sanitisation ou une transformation
			emailInput.value = result.data.user.email;
			displayNameInput.value = result.data.user.display_name;
			avatarUrlInput.value = result.data.user.avatar_url || '';

			setTimeout(() => {
				if (messageDiv.textContent === 'Profil mis √† jour avec succ√®s !') {
					messageDiv.textContent = ''; // Effacer le message de succ√®s
				}
			}, 3000);
		} else {
			messageDiv.textContent = `Erreur: ${result.error || 'Une erreur inconnue est survenue.'}`;
			messageDiv.className = 'mb-4 text-center text-sm text-red-600 font-semibold min-h-[1.25rem]';
		}
	});

	return formElement;
}
// app/frontend/conf/components/gamePage.ts
import { navigateTo } from '../services/router.js';
import { handleOnlineGame } from '../services/initOnlineGame.js';
import { HeaderComponent } from '../components/headerComponent.js';
import { User } from '../shared/schemas/usersSchemas.js';
import { getUserDataFromStorage } from '../services/authService.js';
import { showToast } from './toast.js';

export type GameMode = 'local' | 'remote';

export function GamePage(): HTMLElement {
	//ajout arthur -> on check tout de suite si l'utilisateur est connect√©
	const authData = getUserDataFromStorage();

	// Le HeaderComponent attend un currentUser.
	// Si l'utilisateur n'est pas connect√©, redirigez-le ou affichez un √©tat alternatif.
	if (!authData) {
		console.warn("GamePage: User not authenticated, redirecting to login.");
		navigateTo('/login');
		// Retourner un √©l√©ment vide pour √©viter les erreurs de rendu pendant la redirection
		return document.createElement('div');
	}
	const currentUser: User = authData as User;

	// --- Main Container ---
	const pageWrapper = document.createElement('div');
	pageWrapper.className = 'flex flex-col min-h-screen'; // Assure que la page prend toute la hauteur

	// --- Header ---
	const headerElement = HeaderComponent({ currentUser });
	pageWrapper.appendChild(headerElement);

    // --- Game Page Content ---
    const gameContentContainer: HTMLDivElement = document.createElement('div');
	gameContentContainer.className = 'bg-white flex justify-center items-center min-h-screen p-8';    
    
    const formContainer: HTMLDivElement = document.createElement('div');
    formContainer.className = 'bg-white bg-opacity-90 backdrop-filter backdrop-blur-lg rounded-xl shadow-2xl p-8 max-w-md w-full';   

    // --- Title ---
    const title: HTMLHeadElement = document.createElement('h2');
    title.textContent = 'Welcome to the Game';
    title.className = 'text-3xl font-bold mb-6 text-center text-gray-800';
    
    // --- Buttons ---
    const buttonsContainer: HTMLDivElement = document.createElement('div');
    buttonsContainer.id = 'buttons-container';
    buttonsContainer.className = 'flex flex-col items-center';
    
    // const localGameButton: HTMLButtonElement = document.createElement('button');
    // localGameButton.id = 'local-button';
    // localGameButton.className = 'bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline w-full mb-4 transition duration-300 ease-in-out';
    // localGameButton.textContent = 'Local game';
    
    const onlineGameButton: HTMLButtonElement  = document.createElement('button');
    onlineGameButton.id = 'online-button';// fastify.get('/match/:matchId', { schema: matchSchemas.idOnly}, getMatchIdHandler);
   
    onlineGameButton.className = 'bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline w-full mb-4 transition duration-300 ease-in-out';
    onlineGameButton.textContent = 'Online game';
    
    // TODO (not finished at all)
    const customSettingsButton: HTMLButtonElement  = document.createElement('button');
    customSettingsButton.id = 'custom-settings-button';
    customSettingsButton.className = 'bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline w-full transition duration-300 ease-in-out';
    customSettingsButton.textContent = 'Custom Settings';
    
    buttonsContainer.append(onlineGameButton, customSettingsButton); 
    
    // --- Le pied du page ---
    const footer: HTMLDivElement = document.createElement('div');
    footer.className = 'mt-6 text-center';
    
    const homeLink: HTMLAnchorElement = document.createElement('a');
    homeLink.href = '/'; // lien vers la page d'accueil
    homeLink.textContent = 'Back to Home';
    homeLink.setAttribute('data-link', ''); // intercepte par le router dans le main.ts
    homeLink.className = 'text-blue-600 hover:text-blue-800 text-sm';
    
    footer.appendChild(homeLink);
    
    // --- Ajout des √©l√©ments au conteneur principal ---
    formContainer.append(title, buttonsContainer, footer);
    gameContentContainer.appendChild(formContainer);
    pageWrapper.appendChild(gameContentContainer);
    
    // --- Event: Online game button clicked ---
    onlineGameButton.addEventListener('click', async () => { 
        
        try {
            const userRes = await fetch('/api/users/me');
            if (!userRes.ok) {
                showToast('You must be logged in to play online', 'error');
                return;
            }
            const userData = await userRes.json();
            const display_name: string = userData.display_name;
            const userId: string = userData.id;

            sessionStorage.setItem('gameMode', 'remote');

            await handleOnlineGame(display_name, userId, buttonsContainer, onlineGameButton, title);

        } catch (err: unknown) {
            console.log(`Failed to fetch from user`);
            showToast('Something went wrong. Please try again later.', 'error');
            throw err;
        }
    });
        // return container;
        return pageWrapper; // ajout arthur
}

// app/frontend/conf/components/friendRequests.ts
// /components/friendRequests.ts
import { PendingFriendRequest } from '../shared/schemas/friendsSchemas.js';

interface FriendRequestsProps {
	receivedRequests: PendingFriendRequest[];
	sentRequests: PendingFriendRequest[];
	onAcceptRequest: (friendshipId: number) => Promise<void>;
	onDeclineRequest: (friendshipId: number) => Promise<void>;
	onCancelRequest: (friendshipId: number) => Promise<void>;
}

export function FriendRequestsComponent(props: FriendRequestsProps): HTMLElement {
	const { receivedRequests, sentRequests, onAcceptRequest, onDeclineRequest, onCancelRequest } = props;

	const section = document.createElement('div');
	section.id = 'friend-requests-section';
	section.className = 'mt-8 p-6 bg-indigo-50 border border-indigo-200 rounded-lg shadow-sm';
	section.innerHTML = `
        <h2 class="text-2xl font-semibold text-indigo-800 mb-4">Demandes d'amis</h2>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
                <h3 class="text-xl font-medium text-indigo-700 mb-3">Re√ßues (<span id="received-requests-count">${receivedRequests.length}</span>)</h3>
                <ul id="received-requests-list" class="space-y-3">
                    ${renderReceivedItems(receivedRequests)}
                </ul>
            </div>
            <div>
                <h3 class="text-xl font-medium text-indigo-700 mb-3">Envoy√©es (<span id="sent-requests-count">${sentRequests.length}</span>)</h3>
                <ul id="sent-requests-list" class="space-y-3">
                    ${renderSentItems(sentRequests)}
                </ul>
            </div>
        </div>
    `;

	// Gestionnaire d'√©v√©nements unifi√© pour les demandes d'amis
	section.addEventListener('click', async (event) => {
		const target = event.target as HTMLElement;
		if (target.tagName !== 'BUTTON' || !target.dataset.action) return;

		const button = target as HTMLButtonElement;
		const listItem = target.closest('li[data-friendship-id]') as HTMLLIElement;
		if (!listItem) return;

		const friendshipId = parseInt(listItem.dataset.friendshipId || '', 10);
		if (isNaN(friendshipId)) return;

		const action = target.dataset.action;
		button.disabled = true;
		button.textContent = '...';

		try {
			let message = '';
			if (action === 'accept') {
				await onAcceptRequest(friendshipId);
			} else if (action === 'decline') {
				await onDeclineRequest(friendshipId);
			} else if (action === 'cancel') {
				await onCancelRequest(friendshipId);
			}
		} catch (error: any) {
			console.error(`Erreur lors de l'action '${action}':`, error);
			alert(`Erreur: ${error.message || 'Une erreur est survenue.'}`);
			button.disabled = false; // Restaurer le bouton en cas d'erreur
			button.textContent = action.charAt(0).toUpperCase() + action.slice(1); // Restaurer le texte original
		}
	});

	return section;
}

// Fonctions utilitaires de rendu (pourrait √™tre dans le composant ou s√©par√©es)
function renderReceivedItems(requests: PendingFriendRequest[]): string {
	if (!requests.length) {
		return `<li class="text-gray-500 italic">Aucune demande re√ßue.</li>`;
	}
	return requests.map(req => `
        <li data-friendship-id="${req.friendship_id}" class="p-3 bg-white border border-gray-200 rounded-md shadow-sm flex justify-between items-center">
            <div>
                <strong class="text-indigo-600">${req.requester?.display_name || req.requester?.username}</strong>
                <span class="text-xs text-gray-500 block">(${req.requester?.username})</span>
            </div>
            <div>
                <button data-action="accept" class="text-xs bg-green-500 hover:bg-green-600 text-white font-semibold py-1 px-2 rounded mr-1">Accepter</button>
                <button data-action="decline" class="text-xs bg-red-500 hover:bg-red-600 text-white font-semibold py-1 px-2 rounded">Refuser</button>
            </div>
        </li>
    `).join('');
}

function renderSentItems(requests: PendingFriendRequest[]): string {
	if (!requests.length) {
		return `<li class="text-gray-500 italic">Aucune demande envoy√©e.</li>`;
	}
	return requests.map(req => `
        <li data-friendship-id="${req.friendship_id}" class="p-3 bg-white border border-gray-200 rounded-md shadow-sm flex justify-between items-center">
             <div>
                <strong class="text-indigo-600">${req.receiver?.display_name || req.receiver?.username}</strong>
                 <span class="text-xs text-gray-500 block">(${req.receiver?.username})</span>
            </div>
            <button data-action="cancel" class="text-xs bg-yellow-500 hover:bg-yellow-600 text-black font-semibold py-1 px-2 rounded">Annuler</button>
        </li>
    `).join('');
}
// app/frontend/conf/components/gameResults.ts
import { cleanupSocket } from "../services/initOnlineGame.js";
import { navigateTo } from "../services/router.js";
import socket from '../services/socket.js';

export function showGameResult(player1: string, player2: string, score1: number, score2: number, url1: string, url2: string) {
	const modal = document.createElement('div');
	modal.className = 'fixed inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm';

	const content = document.createElement('div');
	content.className = 'bg-white/90 backdrop-blur-md rounded-2xl shadow-2xl p-6 w-[90%] max-w-lg text-center border border-gray-300';

	// Titre
	const title = document.createElement('h2');
	title.className = 'text-3xl font-bold text-gray-800 mb-6';
	title.textContent = 'üèì Match Finished';

	// Container des joueurs
	const playersContainer = document.createElement('div');
	playersContainer.className = 'flex justify-between items-center gap-4 mb-6';

	// Joueur 1
	const player1Container = document.createElement('div');
	player1Container.className = 'flex flex-col items-center flex-1';

	const img1 = document.createElement('img');
    // TODO: fetch a la base de donne d'Arthur
	img1.src = url1;
	img1.className = 'w-20 h-20 object-cover rounded-full mb-2 border-4 border-blue-500 shadow';

	const name1 = document.createElement('p');
	name1.className = 'font-semibold text-lg text-gray-800';
	name1.textContent = player1;

	const scoreText1 = document.createElement('p');
	scoreText1.className = 'text-2xl font-bold text-blue-600';
	scoreText1.textContent = String(score1);

	player1Container.appendChild(img1);
	player1Container.appendChild(name1);
	player1Container.appendChild(scoreText1);

	// "vs" texte
	const vsText = document.createElement('span');
	vsText.className = 'text-3xl font-bold text-gray-700';
	vsText.textContent = 'vs';

	// Joueur 2
	const player2Container = document.createElement('div');
	player2Container.className = 'flex flex-col items-center flex-1';

	const img2 = document.createElement('img');
	img2.src = url2;
	img2.className = 'w-20 h-20 object-cover rounded-full mb-2 border-4 border-red-500 shadow';

	const name2 = document.createElement('p');
	name2.className = 'font-semibold text-lg text-gray-800';
	name2.textContent = player2;

	const scoreText2 = document.createElement('p');
	scoreText2.className = 'text-2xl font-bold text-red-600';
	scoreText2.textContent = String(score2);

	player2Container.appendChild(img2);
	player2Container.appendChild(name2);
	player2Container.appendChild(scoreText2);

	// Bouton retour au lobby
	const closeButton = document.createElement('button');
	closeButton.id = 'close-modal';
	closeButton.className = 'mt-4 px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-xl shadow transition';
	closeButton.textContent = 'Return to Lobby';

	// Assemble tout
	playersContainer.appendChild(player1Container);
	playersContainer.appendChild(vsText);
	playersContainer.appendChild(player2Container);

	content.appendChild(title);
	content.appendChild(playersContainer);
	content.appendChild(closeButton);
	modal.appendChild(content);
	document.body.appendChild(modal);

	// --- Event: Close bouton
	closeButton.addEventListener('click', () => {
		modal.remove();
		cleanupSocket(socket);
		sessionStorage.clear();
		navigateTo('/game');
	});
}
// app/frontend/conf/components/matchHistoryComponent.ts
import { fetchUserDetails } from '../services/authService.js';
import { fetchMatchHistoryForUser } from '../services/authService.js';
import { Match } from '../shared/schemas/matchesSchemas.js';

export interface MatchHistoryComponentProps {
	userId: number; // ID de l'utilisateur dont on affiche l'historique
}

export async function MatchHistoryComponent(props: MatchHistoryComponentProps): Promise<HTMLElement> {
	const { userId: profiledUserId } = props;

	const el = document.createElement('div');
	el.className = 'p-4';
	el.innerHTML = `<h3 class="text-xl font-semibold mb-4 text-gray-800">Historique des Matchs</h3>`;

	const loadingMessage = document.createElement('p');
	loadingMessage.className = 'text-gray-500 italic';
	loadingMessage.textContent = 'Chargement de l\'historique des matchs...';
	el.appendChild(loadingMessage);

	try {
		const matches = await fetchMatchHistoryForUser(profiledUserId);
		loadingMessage.remove();

		if (!matches || matches.length === 0) {
			el.innerHTML += '<p class="text-gray-500">Aucun match trouv√© pour cet utilisateur.</p>';
			return el;
		}

		const opponentsDetailsCache: { [key: number]: { display_name: string } } = {};
		const list = document.createElement('ul');
		list.className = 'space-y-3';

		for (const match of matches) {
			let opponentId: number;
			let profiledUserScore: number;
			let opponentScore: number;
			let opponentDisplayName = 'Adversaire Inconnu';

			if (match.player1_id === profiledUserId) {
				opponentId = match.player2_id;
				profiledUserScore = match.player1_score;
				opponentScore = match.player2_score;
			} else if (match.player2_id === profiledUserId) {
				opponentId = match.player1_id;
				profiledUserScore = match.player2_score;
				opponentScore = match.player1_score;
			} else {
				console.warn("Match ne semble pas impliquer l'utilisateur profil√©:", match);
				continue;
			}
			
			if (!opponentsDetailsCache[opponentId]) {
				try {
					const opponentUser = await fetchUserDetails(opponentId);
					opponentsDetailsCache[opponentId] = { display_name: opponentUser?.display_name || `Joueur ${opponentId}` };
				} catch (e) {
					console.error(`Impossible de r√©cup√©rer les d√©tails pour l'utilisateur ${opponentId}`, e);
					opponentsDetailsCache[opponentId] = { display_name: `Joueur ${opponentId}` };
				}
			}
			opponentDisplayName = opponentsDetailsCache[opponentId].display_name;
			
			const resultText = match.winner_id === profiledUserId ? 'Victoire' : (match.winner_id ? 'D√©faite' : '√âgalit√©/Annul√©');
			const resultColor = match.winner_id === profiledUserId ? 'text-green-600' : (match.winner_id ? 'text-red-600' : 'text-gray-600');

			const item = document.createElement('li');
			item.className = 'p-3 bg-gray-100 border border-gray-200 rounded-lg shadow-sm hover:shadow-md transition-shadow';
			item.innerHTML = `
                <div class="flex justify-between items-center mb-1">
                    <span class="font-medium text-gray-700">Contre : ${opponentDisplayName}</span>
                    <span class="font-semibold ${resultColor}">${resultText}</span>
                </div>
                <div class="text-sm text-gray-600">
                    Score : ${profiledUserScore} - ${opponentScore}
                    <span class="mx-1">|</span>
                    Type : ${match.win_type}
                    <span class="mx-1">|</span>
                    Date : ${new Date(match.created_at).toLocaleDateString()}
                </div>
            `;
			list.appendChild(item);
		}
		el.appendChild(list);

	} catch (error) {
		console.error("Erreur lors du rendu de l'historique des matchs:", error);
		loadingMessage.textContent = `Erreur lors du chargement de l'historique des matchs: ${(error as Error).message}`;
		loadingMessage.classList.remove('text-gray-500', 'italic');
		loadingMessage.classList.add('text-red-500');
	}

	return el;
}// app/frontend/conf/components/aliasFormPage.ts
import { navigateTo } from "../services/router.js";
import { initLocalGame } from "../services/initLocalGame.js";
// import { createInputField, createInputField } from "../utils/domUtils.js";

export function promptAliasForm(): HTMLDivElement {

    // --- Main Container ---
    const container: HTMLDivElement = document.createElement('div');
	container.className = 'bg-white flex justify-center items-center min-h-screen p-8';

    const formContainer: HTMLDivElement = document.createElement('div');
    formContainer.className = 'bg-white bg-opacity-90 backdrop-filter backdrop-blur-lg rounded-xl shadow-2xl p-8 max-w-md w-full';

    // --- Title ---
    const title: HTMLHeadingElement = document.createElement('h2');
    title.textContent = 'Select Game Mode';
    title.className = 'text-3xl font-bold mb-6 text-center text-gray-800';

    // --- Input form ---
    const form: HTMLFormElement = document.createElement('form');
    form.className = 'space-y-6';

    const gameModeField = createSelectField('gameMode', 'Game Mode', ['1v1', 'Tournament']);
    const dynamicInputs = document.createElement('div');

    // --- Buttons ---
    const buttonsContainer: HTMLDivElement = document.createElement('div');
    buttonsContainer.id = 'buttons-container';
    buttonsContainer.className = 'flex justify-end space-x-4';

    const cancelButton: HTMLButtonElement = document.createElement('button');
    cancelButton.type = 'button';
    cancelButton.id = 'cancel-button';
    cancelButton.textContent = 'Cancel';
    cancelButton.className = 'bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 px-4 rounded transition duration-200';

    const submitButton: HTMLButtonElement = document.createElement('button');
    submitButton.id = 'submit-button';
    submitButton.textContent = 'Start';
    submitButton.className = 'bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition duration-200';

    buttonsContainer.append(cancelButton, submitButton);
    
    // --- Le pied de page ---
    const footer: HTMLDivElement = document.createElement('div');
    footer.className = 'mt-6 text-center';

    const homeLink: HTMLAnchorElement = document.createElement('a');
    homeLink.href = '/'; // lien vers la page d'accueil
    homeLink.textContent = 'Back to Home';
    homeLink.setAttribute('data-link', ''); // intercepte par le router dans le main.ts
    homeLink.className = 'text-blue-600 hover:text-blue-800 text-sm';

    // --- Ajout des √©l√©ments au conteneur principal ---
    footer.appendChild(homeLink);
    form.append(gameModeField, dynamicInputs, buttonsContainer);
    formContainer.append(title, form, footer);
    container.appendChild(formContainer);

    // --- Event: Cancel button clicked
    cancelButton.addEventListener('click', async () => {
        // need to abort the fetch ?
        navigateTo('/game');
    });
    
    // --- Input depends on gameMode
    const selectElement: HTMLSelectElement = (gameModeField.querySelector('select') as HTMLSelectElement);
    selectElement.addEventListener('change', (e) => {
        const value = (e.target as HTMLSelectElement).value;
        dynamicInputs.innerHTML = ''; // reset a chaque changement

        if (value === '1v1') {
            dynamicInputs.append(
                createInputField('alias1', 'Player1'),
                createInputField('alias2', 'Player2')
            );
        } else if (value === 'Tournament' || value === 'Battle Royale') {
            const countField = createInputField('playerCount', 'How many players?');
            const inputElement = countField.querySelector('input') as HTMLInputElement;
            inputElement.placeholder = 'Enter a number between 3 and 10';
            
            dynamicInputs.append(countField);

            // generate as many inputs as recieved in countField
            const aliasFields = document.createElement('div');
            dynamicInputs.append(aliasFields);

            inputElement.type = 'number';
            inputElement.min = '3';
            inputElement.max = '10';

            inputElement.addEventListener('input', () => {
                aliasFields.innerHTML = ''; // reset a chaque changement
                const count: number = parseInt(inputElement.value);
                if (isNaN(count) || count < 3 || count > 10) return;

                for (let i = 1; i <= count; i++) {
                    const field = createInputField(`alias${i}`, `Player ${i}`);
                    field.classList.add('animate-fade-in');
                    aliasFields.appendChild(field);
                }
            });
        }
    });

    // diffuser l'event 'change'
    selectElement.dispatchEvent(new Event('change'));

    // --- Event: Submit form event triggered
    form.addEventListener('submit', async (event) => {
        event.preventDefault(); // prevents the page from refreshing
        await initLocalGame(form);
    });
    
    return container;
}


// -- Helper function for input
function createInputField(id: string, labelText: string): HTMLDivElement {
    const fieldDiv = document.createElement('div');

    const label = document.createElement('label');
    label.htmlFor = id;
    label.textContent = labelText;
    label.className = 'block text-sm font-medium text-gray-700 mb-1';

    const input = document.createElement('input');
    input.type = 'text';
    input.id = id;
    input.required = true;
    input.className = 'w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500';

    fieldDiv.append(label, input);
    
    return fieldDiv;
}

// --- Helper function for game mode (menu delurant avec 3 options)
function createSelectField(id: string, labelText: string, options: string[]): HTMLDivElement {
    const fieldDiv = document.createElement('div');

    const label = document.createElement('label');
    label.htmlFor = id;
    label.textContent = labelText;
    label.className = 'block text-sm font-medium text-gray-700 mb-1';

    const select = document.createElement('select');
    select.id = id;
    select.required = true;
    select.className = 'w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500';

    for (const optionValue of options) {
        const option = document.createElement('option');
        option.value = optionValue;
        option.textContent = optionValue;
        select.appendChild(option);
    }

    fieldDiv.append(label, select);
    return fieldDiv;
}
// app/frontend/conf/components/countdown.ts
export function initCountdown(container: HTMLDivElement): Promise<void> {
	return new Promise((resolve) => {
		const countdownIsDone = sessionStorage.getItem('countdown') === 'true';

		if (!countdownIsDone) {
			let countdownValue = 3;
			container.textContent = `Start in ${countdownValue}...`;

			const interval = setInterval(() => {
				countdownValue--;

				if (countdownValue > 0) {
					container.textContent = `Start in ${countdownValue}...`;
				} else {
					clearInterval(interval);
					container.remove();
					sessionStorage.setItem('countdown', 'true');
					resolve();
				}
			}, 1000);
		} else {
			container.remove();
			resolve();
		}
	});
}
// app/frontend/conf/components/loginForm.ts
// /components/loginForm.ts
import { LoginRequestBody } from '../shared/schemas/usersSchemas.js';
import { ApiResult } from '../utils/types.js';

interface LoginFormProps {
	onLoginAttempt: (credentials: LoginRequestBody) => Promise<ApiResult>;
	onLoginSuccess: (userData: any) => void; // Callback pour informer la page du succ√®s
}

export function LoginForm(props: LoginFormProps): HTMLElement {
	const { onLoginAttempt, onLoginSuccess } = props;

	const formWrapper = document.createElement('div');
	// Pas besoin de classes sp√©cifiques ici si elles sont d√©j√† sur formContainer dans la page

	formWrapper.innerHTML = `
        <form id="login-form-component"> <!-- ID unique pour ce composant -->
            <div class="mb-4">
                <label for="identifier" class="block text-gray-700 text-sm font-bold mb-2">Username or Email</label>
                <input type="text" id="identifier" name="identifier" required placeholder="Enter your username or email"
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
            </div>
            <div class="mb-6">
                <label for="password" class="block text-gray-700 text-sm font-bold mb-2">Password</label>
                <input type="password" id="password" name="password" required
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:shadow-outline">
            </div>
            <div class="flex items-center justify-between">
                <button type="submit" id="login-button"
                        class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline w-full transition duration-300 ease-in-out">
                    Sign In
                </button>
            </div>
        </form>
        <div id="login-message-component" class="mt-4 text-center text-sm"></div>
    `;

	const form = formWrapper.querySelector('#login-form-component') as HTMLFormElement;
	const identifierInput = formWrapper.querySelector('#identifier') as HTMLInputElement;
	const passwordInput = formWrapper.querySelector('#password') as HTMLInputElement;
	const messageDiv = formWrapper.querySelector('#login-message-component') as HTMLDivElement;
	const loginButton = formWrapper.querySelector('#login-button') as HTMLButtonElement;

	form.addEventListener('submit', async (event) => {
		event.preventDefault();
		messageDiv.textContent = 'Attempting login...';
		messageDiv.className = 'mt-4 text-center text-sm text-gray-600';
		loginButton.disabled = true;
		loginButton.textContent = 'Signing In...';

		const identifier = identifierInput.value.trim();
		const password = passwordInput.value;

		if (!identifier || !password) {
			messageDiv.textContent = 'Please enter both username/email and password.';
			messageDiv.className = 'mt-4 text-center text-sm text-red-600';
			loginButton.disabled = false;
			loginButton.textContent = 'Sign In';
			return;
		}

		const result = await onLoginAttempt({ identifier, password });

		loginButton.disabled = false;
		loginButton.textContent = 'Sign In';

		if (result.success) {
			messageDiv.textContent = `Login successful! Welcome ${result.data.user.display_name || result.data.user.username}!`;
			messageDiv.className = 'mt-4 text-center text-sm text-green-600';
			onLoginSuccess(result.data.user); // Appeler le callback de succ√®s
		} else {
			messageDiv.textContent = result.error || 'Login failed. Please try again.';
			messageDiv.className = 'mt-4 text-center text-sm text-red-600';
			passwordInput.value = ''; // Vider le mot de passe en cas d'√©chec
		}
	});

	return formWrapper;
}
// app/frontend/conf/components/loginForm.ts
// import { ApiResult } from '../shared/types.js';
// import { LoginRequestBody, User } from '../shared/schemas/usersSchemas.js';
// import { createElement, createInputField, createActionButton } from '../utils/domUtils.js';

// interface LoginFormProps {
//     onLoginAttempt: (credentials: LoginRequestBody) => Promise<ApiResult>;
//     onLoginSuccess: (userData: User) => void;
// }

// export function LoginForm(props: LoginFormProps): HTMLElement {
//     const { onLoginAttempt, onLoginSuccess } = props;

//     const messageDiv = createElement('div', {
//         id: 'login-message-component',
//         className: 'mt-4 text-center text-sm min-h-[1.25rem]'
//     });

//     const identifierField = createInputField('identifier', 'Username or Email', {
//         required: true,
//         placeholder: 'Enter your username or email'
//     });

//     const passwordField = createInputField('password', 'Password', {
//         type: 'password',
//         required: true,
//         wrapperClass: 'mb-6' // Specific class for password field wrapper
//     });

//     const loginButton = createActionButton({
//         text: 'Sign In',
//         variant: 'success', // Using predefined variant
//         onClick: async () => { /* Will be handled by form submit */ }
//     });
//     loginButton.type = 'submit';
//     loginButton.id = 'login-button';
//     loginButton.classList.add('w-full');


//     const form = createElement('form', { id: 'login-form-component' }, [
//         identifierField,
//         passwordField,
//         createElement('div', { className: 'flex items-center justify-between' }, [
//             loginButton
//         ])
//     ]);

//     const formWrapper = createElement('div', {}, [form, messageDiv]);


//     const getInputValue = (field: HTMLElement): string => (field.querySelector('input') as HTMLInputElement).value;

//     form.addEventListener('submit', async (event) => {
//         event.preventDefault();
//         messageDiv.textContent = 'Attempting login...';
//         messageDiv.className = 'mt-4 text-center text-sm text-gray-600 min-h-[1.25rem]';
//         loginButton.disabled = true;
//         const originalButtonText = loginButton.textContent;
//         loginButton.textContent = 'Signing In...';

//         const identifier = getInputValue(identifierField).trim();
//         const password = getInputValue(passwordField); // No trim for password

//         if (!identifier || !password) {
//             messageDiv.textContent = 'Please enter both username/email and password.';
//             messageDiv.className = 'mt-4 text-center text-sm text-red-600 min-h-[1.25rem]';
//             loginButton.disabled = false;
//             loginButton.textContent = originalButtonText;
//             return;
//         }

//         const result = await onLoginAttempt({ identifier, password });

//         loginButton.disabled = false;
//         loginButton.textContent = originalButtonText;

//         if (result.success) {
//             messageDiv.textContent = `Login successful! Welcome ${result.data.user.display_name || result.data.user.username}!`;
//             messageDiv.className = 'mt-4 text-center text-sm text-green-600 min-h-[1.25rem]';
//             onLoginSuccess(result.data.user);
//         } else {
//             messageDiv.textContent = result.error || 'Login failed. Please try again.';
//             messageDiv.className = 'mt-4 text-center text-sm text-red-600 min-h-[1.25rem]';
//             (passwordField.querySelector('input') as HTMLInputElement).value = '';
//         }
//     });

//     return formWrapper;
// }
// app/frontend/conf/components/toast.ts
export function showToast(message: string, type: 'success' | 'error' = 'success') {
    const existingToast = document.querySelector('.custom-toast');
    if (existingToast) {
        existingToast.remove();
    }

    const toast = document.createElement('div');
    toast.textContent = message;

    const successBgClass = 'bg-green-400'; // Ou bg-teal-400, bg-emerald-400
    const errorBgClass = 'bg-red-500';

    toast.className = `custom-toast fixed top-6 left-6 transform z-[1000] px-6 py-3 
                       rounded-lg shadow-lg text-white font-medium transition-all duration-300 ease-in-out
                       ${type === 'success' ? successBgClass : errorBgClass}`;
    
    toast.style.opacity = '0';
    toast.style.transform = 'translateY(-20px)';

    document.body.appendChild(toast);

    setTimeout(() => {
        toast.style.opacity = '0.8';
        toast.style.transform = 'translateY(0)';
    }, 10);

    setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transform = 'translateY(-20px)';
        setTimeout(() => toast.remove(), 300);
    }, 3000);
}

export function showCustomConfirm(message: string, title: string = "Confirmation"): Promise<boolean> {
    return new Promise((resolve) => {
        const existingDialog = document.querySelector('.custom-confirm-overlay');
        if (existingDialog) {
            existingDialog.remove();
        }

        const overlay = document.createElement('div');
        overlay.className = `custom-confirm-overlay fixed inset-0 
                             flex items-center justify-center z-[999] p-4 
                             transition-opacity duration-200 ease-out`;
        overlay.style.backdropFilter = 'blur(2px)'; // flou

        overlay.style.opacity = '0';

        // Dialog Box 
        const dialog = document.createElement('div');
        dialog.className = 'bg-white rounded-lg shadow-xl w-full max-w-sm transform transition-all duration-200 ease-out';
        dialog.style.opacity = '0';
        dialog.style.transform = 'scale(0.95)';

        // Title 
        const titleElement = document.createElement('h3');
        titleElement.className = 'text-lg font-semibold text-gray-800 px-6 py-4 border-b border-gray-200';
        titleElement.textContent = title;

        // Message
        const messageElement = document.createElement('p');
        messageElement.className = 'text-gray-600 px-6 py-5 text-sm';
        messageElement.textContent = message;

        // Buttons Container
        const buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'px-6 py-3 bg-gray-50 rounded-b-lg flex justify-end space-x-3';

        // Confirm Button
        const confirmButton = document.createElement('button');
        confirmButton.textContent = 'Yes';
        confirmButton.className = 'px-4 py-2 rounded-md text-sm font-medium text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2';
        
        // Cancel Button
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'No';
        cancelButton.className = 'px-4 py-2 rounded-md text-sm font-medium text-gray-700 bg-gray-200 hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2';

        const closeDialog = (value: boolean) => {
            overlay.style.opacity = '0';
            dialog.style.transform = 'scale(0.95)';
            setTimeout(() => {
                overlay.remove();
                resolve(value);
                window.removeEventListener('keydown', handleEscKey);
            }, 200);
        };
        
        confirmButton.onclick = () => closeDialog(true);
        cancelButton.onclick = () => closeDialog(false);

        const handleEscKey = (event: KeyboardEvent) => {
            if (event.key === 'Escape') {
                closeDialog(false);
            }
        };
        window.addEventListener('keydown', handleEscKey);

        buttonsContainer.appendChild(cancelButton);
        buttonsContainer.appendChild(confirmButton);
        dialog.appendChild(titleElement);
        dialog.appendChild(messageElement);
        dialog.appendChild(buttonsContainer);
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);

        requestAnimationFrame(() => {
            overlay.style.opacity = '1';
            dialog.style.opacity = '1';
            dialog.style.transform = 'scale(1)';
        });
    });
}

export function showWaitingToast(socket: SocketIOClient.Socket, controller: AbortController) {
    const existingToast = document.querySelector('.custom-waiting-toast');
    if (existingToast) {
        existingToast.remove();
    }

    const toast = document.createElement('div') as HTMLElement;
     toast.className = `custom-waiting-toast fixed bottom-6 right-6 z-[1000]
                       bg-white text-gray-800 shadow-lg rounded-full w-48 h-48 p-4 
                       flex flex-col items-center justify-center gap-4
                       transition-all duration-300 ease-in-out border border-gray-300`;

     // Spinner container
    const spinnerContainer = document.createElement('div');
    spinnerContainer.className = 'relative w-16 h-16';

    // Spinner ring (outer border)
    const spinner = document.createElement('div');
    spinner.className = `absolute inset-0 rounded-full border-4 
                         border-green-500 border-t-transparent animate-spin`;

    // Message
    const message = document.createElement('p');
    message.textContent = 'Looking for an opponent...';
    message.className = 'text-center text-sm font-medium';

    // Timer
    const timer = document.createElement('div');
    timer.textContent = '60';
    timer.className = 'absolute inset-0 flex items-center justify-center text-lg font-bold text-green-700';
    
    spinnerContainer.appendChild(spinner);
    spinnerContainer.appendChild(timer);

    // Cancel button
    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'Cancel';
    cancelBtn.className = `bg-red-600 hover:bg-red-700 text-white 
                           font-medium py-1 px-4 rounded`;
                           
    toast.appendChild(spinnerContainer);                      
    toast.appendChild(message);
    toast.appendChild(cancelBtn);
    document.body.appendChild(toast);

    // Animation d'apparition
    toast.style.opacity = '0';
    toast.style.transform = 'translateY(20px)';
    setTimeout(() => {
        toast.style.opacity = '1';
        toast.style.transform = 'translateY(0)';
    }, 10);

    // Timer countdown
    let secondsLeft = 60;
    const countdown = setInterval(() => {
        secondsLeft--;
        timer.textContent = `${secondsLeft}`;
        if (secondsLeft <= 0) {
            clearInterval(countdown);
        }
    }, 1000);

    // Cancel logic
    cancelBtn.addEventListener('click', () => {
        clearInterval(countdown);
        controller.abort();
        socket.emit('cancelMatch');
        socket.disconnect();
        removeWaitingToast();
    });
}


export function removeWaitingToast() {
    const toast = document.querySelector('.custom-waiting-toast');
    if (toast instanceof HTMLElement) {
        toast.style.opacity = '0';
        toast.style.transform = 'translateY(20px)';
        setTimeout(() => toast.remove(), 300);
    }
}
// app/frontend/conf/components/registerPage.ts
import { attemptRegister } from '../services/authService.js';
import { RegisterRequestBody } from '../shared/schemas/usersSchemas.js'
import { ApiResult } from '../utils/types.js'
import { navigateTo } from '../services/router.js';

export async function RegisterPage(): Promise<HTMLElement> {


	const container = document.createElement('div');
	container.className = 'bg-white flex justify-center items-center min-h-screen p-8';
	
	const formContainer = document.createElement('div');
	formContainer.className = 'bg-white bg-opacity-90 backdrop-filter backdrop-blur-lg rounded-xl shadow-2xl p-8 max-w-md w-full';

	formContainer.innerHTML = `
        <h2 class="text-3xl font-bold mb-6 text-center text-gray-800">Register</h2>
        <form id="register-form">
            <div class="mb-4">
                <label for="username" class="block text-gray-700 text-sm font-bold mb-2">Username</label>
                <input type="text" id="username" name="username" required minlength="3" maxlength="20"
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                <p class="text-xs text-gray-600 mt-1">3 to 20 characters.</p>
            </div>
            <div class="mb-4">
                <label for="email" class="block text-gray-700 text-sm font-bold mb-2">Email</label>
                <input type="email" id="email" name="email" required
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
            </div>
             <div class="mb-4">
                <label for="display_name" class="block text-gray-700 text-sm font-bold mb-2">Display Name</label>
                <input type="text" id="display_name" name="display_name" required minlength="3" maxlength="20"
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                <p class="text-xs text-gray-600 mt-1">3 to 20 characters.</p>
            </div>
            <div class="mb-4">
                <label for="password" class="block text-gray-700 text-sm font-bold mb-2">Password</label>
                <input type="password" id="password" name="password" required minlength="8" maxlength="100"
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                 <p class="text-xs text-gray-600 mt-1">8 to 100 characters.</p>
            </div>
             <div class="mb-6">
                <label for="confirm_password" class="block text-gray-700 text-sm font-bold mb-2">Confirm Password</label>
                <input type="password" id="confirm_password" name="confirm_password" required minlength="8" maxlength="100"
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:shadow-outline">
            </div>
            <div class="mb-6">
                <label for="avatar_url" class="block text-gray-700 text-sm font-bold mb-2">Avatar URL (Optional)</label>
                <input type="url" id="avatar_url" name="avatar_url" placeholder="https://example.com/avatar.jpg"
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
            </div>
            <div class="flex items-center justify-between">
                <button type="submit" id="register-button"
                        class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline w-full transition duration-300 ease-in-out">
                    Register
                </button>
            </div>
        </form>
        <div id="register-message" class="mt-4 text-center text-sm"></div>
        <div class="mt-6 text-center">
          <a href="/" data-link class="text-blue-600 hover:text-blue-800 text-sm">
            Back to Home
          </a>
          <span class="mx-2 text-gray-400">|</span>
          <a href="/login" data-link class="text-blue-600 hover:text-blue-800 text-sm">
            Already have an account? Login
          </a>
        </div>
    `;

	container.appendChild(formContainer);

	// --- Logique du formulaire d'inscription ---
	const form = container.querySelector('#register-form') as HTMLFormElement;
	const usernameInput = container.querySelector('#username') as HTMLInputElement;
	const emailInput = container.querySelector('#email') as HTMLInputElement;
	const displayNameInput = container.querySelector('#display_name') as HTMLInputElement;
	const passwordInput = container.querySelector('#password') as HTMLInputElement;
	const confirmPasswordInput = container.querySelector('#confirm_password') as HTMLInputElement;
	const avatarUrlInput = container.querySelector('#avatar_url') as HTMLInputElement;
	const messageDiv = container.querySelector('#register-message') as HTMLDivElement;
	const registerButton = container.querySelector('#register-button') as HTMLButtonElement;

	form.addEventListener('submit', async (event) => {
		event.preventDefault();
		messageDiv.textContent = ''; // Clear previous messages
		messageDiv.className = 'mt-4 text-center text-sm'; // Reset style

		const username = usernameInput.value.trim();
		const email = emailInput.value.trim();
		const displayName = displayNameInput.value.trim();
		const password = passwordInput.value; // No trim on password
		const confirmPassword = confirmPasswordInput.value;
		const avatarUrl = avatarUrlInput.value.trim();

		// --- Validation des champs ---
		if (!username || !email || !displayName || !password || !confirmPassword) {
			messageDiv.textContent = 'Please fill in all required fields.';
			messageDiv.className = 'mt-4 text-center text-sm text-red-600';
			return;
		}
		if (password !== confirmPassword) {
			messageDiv.textContent = 'Passwords do not match.';
			messageDiv.className = 'mt-4 text-center text-sm text-red-600';
			passwordInput.value = ''; // Clear passwords
			confirmPasswordInput.value = '';
			return;
		}
		if (password.length < 8) {
			messageDiv.textContent = 'Password must be at least 8 characters long.';
			messageDiv.className = 'mt-4 text-center text-sm text-red-600';
			return;
		}
		// Simple check for avatar URL format if provided
		if (avatarUrl && !isValidHttpUrl(avatarUrl)) {
			messageDiv.textContent = 'Avatar URL must be a valid HTTP/HTTPS URL.';
			messageDiv.className = 'mt-4 text-center text-sm text-red-600';
			return;
		}

		// --- Appel √† l'API ---
		messageDiv.textContent = 'Attempting registration...';
		messageDiv.className = 'mt-4 text-center text-sm text-gray-600';
		registerButton.disabled = true;
		registerButton.textContent = 'Registering...';

		const credentials: RegisterRequestBody = {
			username,
			email,
			password,
			display_name: displayName,
		};
		// Only add avatar_url if it's not empty
		if (avatarUrl) {
			credentials.avatar_url = avatarUrl;
		}

		const registrationResult: ApiResult = await attemptRegister(credentials);

		registerButton.disabled = false; // Re-enable button
		registerButton.textContent = 'Register';

		if (registrationResult.success) {
			messageDiv.textContent = `Registration successful for ${username}! Redirecting to login...`;
			messageDiv.className = 'mt-4 text-center text-sm text-green-600';
			form.reset(); // Clear the form fields
			setTimeout(() => { navigateTo('/login'); }, 500);

		} else {
			messageDiv.textContent = 'Registration failed. Please check the details and try again.'; // Message g√©n√©rique post-alert
			messageDiv.className = 'mt-4 text-center text-sm text-red-600';
			passwordInput.value = ''; // Clear password fields on failure
			confirmPasswordInput.value = '';
		}
	});

	return container;
}

// Helper function for basic URL validation
function isValidHttpUrl(string: string): boolean {
	let url;
	try {
		url = new URL(string);
	} catch (_) {
		return false;
	}
	return url.protocol === "http:" || url.protocol === "https:";
}

// app/frontend/conf/pages/registerPage.ts
// import { attemptRegister } from '../services/authService.js';
// import { RegisterRequestBody, ApiResult } from '../shared/types.js';
// import { navigateTo } from '../services/router.js';
// import { createElement, createInputField, createActionButton } from '../utils/domUtils.js';
// import { isValidHttpUrl, isValidEmailFormat } from '../services/apiUtils.js'; // Import validation

// export async function RegisterPage(): Promise<HTMLElement> {
// 	const messageDiv = createElement('div', {
// 		id: 'register-message',
// 		className: 'mt-4 text-center text-sm min-h-[1.25rem]'
// 	});

// 	const usernameField = createInputField('username', 'Username', {
// 		required: true, minLength: 3, maxLength: 20, helpText: '3 to 20 characters.'
// 	});
// 	const emailField = createInputField('email', 'Email', {
// 		type: 'email', required: true
// 	});
// 	const displayNameField = createInputField('display_name', 'Display Name', {
// 		required: true, minLength: 3, maxLength: 20, helpText: '3 to 20 characters.'
// 	});
// 	const passwordField = createInputField('password', 'Password', {
// 		type: 'password', required: true, minLength: 8, maxLength: 100, helpText: '8 to 100 characters.'
// 	});
// 	const confirmPasswordField = createInputField('confirm_password', 'Confirm Password', {
// 		type: 'password', required: true, minLength: 8, maxLength: 100, wrapperClass: 'mb-6'
// 	});
// 	const avatarUrlField = createInputField('avatar_url', 'Avatar URL (Optional)', {
// 		type: 'url', placeholder: 'https://example.com/avatar.jpg', wrapperClass: 'mb-6'
// 	});

// 	const registerButton = createActionButton({
// 		text: 'Register',
// 		baseClass: 'bg-yellow-500 hover:bg-yellow-600', // Specific color
// 		onClick: async () => { /* form submit */ }
// 	});
// 	registerButton.type = 'submit';
// 	registerButton.id = 'register-button';
// 	registerButton.classList.add('w-full');

// 	const form = createElement('form', { id: 'register-form' }, [
// 		usernameField,
// 		emailField,
// 		displayNameField,
// 		passwordField,
// 		confirmPasswordField,
// 		avatarUrlField,
// 		createElement('div', { className: 'flex items-center justify-between' }, [registerButton])
// 	]);

// 	const linksDiv = createElement('div', {
// 		className: 'mt-6 text-center',
// 		innerHTML: `
//             <a href="/" data-link class="text-blue-600 hover:text-blue-800 text-sm">Back to Home</a>
//             <span class="mx-2 text-gray-400">|</span>
//             <a href="/login" data-link class="text-blue-600 hover:text-blue-800 text-sm">Already have an account? Login</a>
//         `
// 	});

// 	const formContainer = createElement('div', {
// 		className: 'bg-white bg-opacity-90 backdrop-filter backdrop-blur-lg rounded-xl shadow-2xl p-8 max-w-md w-full'
// 	}, [
// 		createElement('h2', { textContent: 'Register', className: 'text-3xl font-bold mb-6 text-center text-gray-800' }),
// 		form,
// 		messageDiv,
// 		linksDiv
// 	]);

// 	const pageContainer = createElement('div', {
// 		className: 'bg-gradient-to-r from-blue-500 to-purple-600 flex justify-center items-center min-h-screen p-8'
// 	}, [formContainer]);

// 	const getVal = (field: HTMLElement) => (field.querySelector('input') as HTMLInputElement).value;

// 	form.addEventListener('submit', async (event) => {
// 		event.preventDefault();
// 		messageDiv.textContent = '';
// 		messageDiv.className = 'mt-4 text-center text-sm min-h-[1.25rem]';
// 		const originalButtonText = registerButton.textContent;

// 		const username = getVal(usernameField).trim();
// 		const email = getVal(emailField).trim();
// 		const displayName = getVal(displayNameField).trim();
// 		const password = getVal(passwordField); // No trim
// 		const confirmPassword = getVal(confirmPasswordField);
// 		const avatarUrl = getVal(avatarUrlField).trim();

// 		const displayError = (msg: string) => {
// 			messageDiv.textContent = msg;
// 			messageDiv.className = 'mt-4 text-center text-sm text-red-600 min-h-[1.25rem]';
// 		};

// 		if (!username || !email || !displayName || !password || !confirmPassword) {
// 			return displayError('Please fill in all required fields.');
// 		}
// 		if (!isValidEmailFormat(email)) {
// 			return displayError('Invalid email format.');
// 		}
// 		if (password !== confirmPassword) {
// 			(passwordField.querySelector('input') as HTMLInputElement).value = '';
// 			(confirmPasswordField.querySelector('input') as HTMLInputElement).value = '';
// 			return displayError('Passwords do not match.');
// 		}
// 		if (password.length < 8) {
// 			return displayError('Password must be at least 8 characters long.');
// 		}
// 		if (avatarUrl && !isValidHttpUrl(avatarUrl)) {
// 			return displayError('Avatar URL must be a valid HTTP/HTTPS URL.');
// 		}

// 		messageDiv.textContent = 'Attempting registration...';
// 		messageDiv.className = 'mt-4 text-center text-sm text-gray-600 min-h-[1.25rem]';
// 		registerButton.disabled = true;
// 		registerButton.textContent = 'Registering...';

// 		const credentials: RegisterRequestBody = { username, email, password, display_name: displayName };
// 		if (avatarUrl) credentials.avatar_url = avatarUrl;

// 		const registrationResult: ApiResult = await attemptRegister(credentials);

// 		registerButton.disabled = false;
// 		registerButton.textContent = originalButtonText;

// 		if (registrationResult.success) {
// 			messageDiv.textContent = `Registration successful for ${username}! Redirecting to login...`;
// 			messageDiv.className = 'mt-4 text-center text-sm text-green-600 min-h-[1.25rem]';
// 			form.reset();
// 			setTimeout(() => { navigateTo('/login'); }, 1500); // Increased timeout slightly
// 		} else {
// 			displayError(registrationResult.error || 'Registration failed. Please try again.');
// 			(passwordField.querySelector('input') as HTMLInputElement).value = '';
// 			(confirmPasswordField.querySelector('input') as HTMLInputElement).value = '';
// 		}
// 	});
// 	return pageContainer;
// }
// app/frontend/conf/style/input.css
@import 'tailwindcss';

@layer utilities {
    .animate-pulse-custom {
      animation: pulseCustom 2s infinite;
    }
  
    @keyframes pulseCustom {
      0%, 100% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(1.1);
        opacity: 0.7;
      }
    }
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}
.animate-spin {
    animation: spin 1s linear infinite;
}

.jungle-coconut {
	background: radial-gradient(circle at 30% 30%, #6e4a2f 15%, #4a2f18 80%);
	box-shadow: inset 0 0 2px #2a1d12, 0 0 5px rgba(0, 0, 0, 0.4);
}// app/frontend/conf/services/csrf.ts
export let csrfToken: string | null = null;

export function setCsrfToken(token: string) {
	csrfToken = token;
	localStorage.setItem('csrfToken', token);
}

export function getCsrfTokenOrThrow(): string {
	if (!csrfToken) {
		csrfToken = localStorage.getItem('csrfToken');
	}
	if (!csrfToken) throw new Error('CSRF token missing. Please refresh the page.');
	return csrfToken;
}

export async function fetchWithCsrf(url: string, options: RequestInit = {}): Promise<Response> {
	const token = getCsrfTokenOrThrow();
	const headers = new Headers(options.headers || {});
	headers.set('x-csrf-token', token);
	return fetch(url, {
		...options,
		headers,
		credentials: 'include',
	});
}

export async function fetchCsrfToken() {
	try {
		const response = await fetch('/api/users/csrf-token', { credentials: 'include' });
		if (!response.ok) throw new Error('Failed to fetch CSRF token');
		const data = await response.json();
		csrfToken = data.csrfToken;
		console.log('CSRF Token fetched and stored:', csrfToken);
	} catch (error) {
		console.error('Error fetching CSRF token:', error);
	}
}
// app/frontend/conf/services/error.ts
import { z } from 'zod';

export const ServerErrorPayloadSchema = z.object({
  error: z.string(),
  statusCode: z.number(),
  details: z.any().optional(),
});

export type ServerErrorPayload = z.infer<typeof ServerErrorPayloadSchema>;

export class ClientApiError extends Error {
  public httpStatus: number;
  public serverStatusCode?: number;
  public errorResponse?: ServerErrorPayload;

  constructor(
    message: string,
    httpStatus: number,
    serverStatusCode?: number,
    errorResponse?: ServerErrorPayload
  ) {
    super(message);
    this.name = 'ClientApiError';
    this.httpStatus = httpStatus;
    this.serverStatusCode = serverStatusCode;
    this.errorResponse = errorResponse;

    Object.setPrototypeOf(this, ClientApiError.prototype);
  }
}

/**
 * G√®re une r√©ponse API, la parse avec un sch√©ma Zod et l√®ve une erreur en cas d'√©chec.
 * @template T - Le sch√©ma Zod √† utiliser pour le parsing.
 * @param {Response} response - L'objet r√©ponse de fetch.
 * @param {T} schema - Le sch√©ma Zod pour valider et parser les donn√©es.
 * @returns {Promise<z.infer<T>>} Les donn√©es pars√©es et valid√©es.
 * @throws {ClientApiError} Si la r√©ponse n'est pas OK ou si le parsing √©choue.
 */
export const handleApiResponse = async <T extends z.ZodTypeAny>(
  response: Response,
  schema: T
): Promise<z.infer<T>> => {
  if (!response.ok) {
    let errorPayload: ServerErrorPayload | undefined;
    let errorMessage = `Erreur HTTP ${response.status}: ${response.statusText}`;

    const contentType = response.headers.get('content-type');
    if (response.body && contentType?.includes('application/json')) {
      try {
        const json = await response.json();
        const parsedError = ServerErrorPayloadSchema.safeParse(json);
        if (parsedError.success) {
          errorPayload = parsedError.data;
          errorMessage = errorPayload.error;
        } else {
          errorMessage = `Erreur HTTP ${response.status}: La r√©ponse d'erreur JSON est mal form√©e.`;
        }
      } catch (e) {
      }
    }
    throw new ClientApiError(errorMessage, response.status, errorPayload?.statusCode, errorPayload);
  }


  if (response.status === 204) {
    return undefined as z.infer<T>;
  }

  const json = await response.json();
  const result = schema.safeParse(json); // Parsing de la r√©ponse de SUCC√àS

  if (!result.success) {
    console.error("Erreur de validation Zod (r√©ponse succ√®s invalide):", result.error.issues);
    
    const validationErrorPayload: ServerErrorPayload = {
      error: "Les donn√©es re√ßues du serveur sont invalides.",
      statusCode: response.status,
      details: result.error.issues
    };

    throw new ClientApiError(
      validationErrorPayload.error,
      response.status,
      response.status,
      validationErrorPayload
    );
  }

  return result.data;
};

// export const handleApiResponse = async <T>(response: Response): Promise<T> => {
//   if (!response.ok) {
//     let errorPayload: ServerErrorPayload | undefined;
//     let errorMessage: string = `Erreur HTTP ${response.status}: ${response.statusText}`; // Message par d√©faut

//     const contentType = response.headers.get('content-type');
//     if (response.body && contentType && contentType.includes('application/json')) {
//       try {
//         errorPayload = await response.json() as ServerErrorPayload;
//         if (errorPayload && errorPayload.error) {
//           errorMessage = errorPayload.error;
//         } else {
//           errorMessage = `Erreur HTTP ${response.status}: ${response.statusText}. La r√©ponse d'erreur JSON est mal form√©e.`;
//         }
//       } catch (jsonError) {
//         console.error("Impossible de parser la r√©ponse d'erreur JSON:", jsonError);
//         errorMessage = `Erreur HTTP ${response.status}: ${response.statusText}. La r√©ponse d'erreur n'est pas du JSON valide.`;
//       }
//     } else if (response.body) {
//       try {
//         const textError = await response.text();
//         if (textError) {
//           errorMessage = `Erreur HTTP ${response.status}: ${textError}`;
//         }
//       } catch (textParseError) {
//         console.error("Impossible de lire le corps de l'erreur texte:", textParseError);
//       }
//     }
//     throw new ClientApiError(
//       errorMessage,
//       response.status,
//       errorPayload?.statusCode,
//       errorPayload
//     );
//   }

//   if (response.status === 204) {
//     return undefined as T;
//   }

//   try {
//     const data = await response.json();
//     return data as T;
//   } catch (jsonParseError) {
//     console.error(
//       `R√©ponse serveur OK (${response.status}) mais le corps n'est pas du JSON valide:`,
//       jsonParseError
//     );
//     throw new ClientApiError(
//       `R√©ponse serveur inattendue (${response.status}): le corps de la r√©ponse succ√®s n'est pas du JSON valide.`,
//       response.status
//     );
//   }
// };// app/frontend/conf/services/initOnlineGame.ts
import { UUID } from "crypto";
import { navigateTo } from "./router.js";
import socket from "./socket.js";
import { removeWaitingToast, showToast, showWaitingToast } from "../components/toast.js";
import { initCountdown } from "../components/countdown.js";

// --- Main Fonction for online game: 
export async function handleOnlineGame(display_name: string, userId: string, container: HTMLElement, button: HTMLButtonElement, title: HTMLHeadElement): Promise<void> {
    button.disabled = true; // pour eviter les multiples click (data race)
    try {
        await initOnlineGame(display_name, userId, container, title);
    } catch (err: unknown) {
        console.log(err);
        showToast('Error while creating a waiting room. Please, try again later', 'error');
        navigateTo('/game');
    } finally {
        button.disabled = false;
    }
}

// --- Fonction pour initialiser le client socket et le mettre dans le waiting room ---
export async function initOnlineGame(display_name: string, userId: string, buttonsContainer: HTMLElement, title: HTMLHeadElement) {
    const controller: AbortController = new AbortController();

    if (!socket.connected) {
        socket.connect();
    }
    
    socket.on('connect', () => {
        console.log('Connected to the server');
        socket.emit('authenticate', { display_name, userId });
    });
    
    socket.on('inQueue', () => {
        showWaitingToast(socket, controller);
    });

    // --- Socket listener on matchFound event --> if opponenet is found
    socket.on('matchFound', async ({ matchId, displayName, side, opponent }: { matchId: UUID; displayName: string, side: 'left' | 'right'; opponent: string}) => {

        sessionStorage.setItem('matchId', matchId);
        sessionStorage.setItem('displayName', displayName);
        sessionStorage.setItem('side', side);
        sessionStorage.setItem('opponent', opponent);

        removeWaitingToast();

        const countdownContainer = document.createElement('div');
        countdownContainer.className = `
            fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50
            text-lime-200 text-6xl font-extrabold tracking-widest jungle-font
        `;        
        document.body.appendChild(countdownContainer);

        await initCountdown(countdownContainer);

        navigateTo(`/game-room?matchId=${matchId}`);

    });
    
    // --- Socket listeners on errors from the server side
    socket.on('disconnect', (reason: string, details?: any) => { 
        console.log(`Disconnected from the server: reason ${reason}`);
        if (details){
            console.log(`details: ${details.message}, ${details.description}, ${details.context}`);
        }
    });
    
    socket.on('error', (err: Error) => {
        console.error('Socket error:', err);
    });

    socket.on('connect_error', (err: Error) => {
        console.error(`Connection to the server is failed: ${err.message}`);
        showToast('Failed to connect to server. Please try later.', 'error');
        cleanupSocket(socket);
      });

    // --- TODO: emit on server side ---
    socket.on('matchTimeout', () => {
        showToast('No opponent found. Please try later.', 'error');
        cleanupSocket(socket);
        removeWaitingToast();
        navigateTo('/game');
    });
}

// // --- Fonction pour cr√©er une salle d'attente ---
// export async function createOnlineMatch(token: string, opponentId: string, display_name: string, signal: AbortSignal): Promise<string | null> {
//     try {
//         const requestBody = {
//             player1: display_name,
//             player2: opponentId,
//             isLocal: false,
//         }

//         console.log("Request Body:", requestBody);
//         const response = await fetch('/api/game/match', {
//             method: 'POST',
//             headers: {
//                 'Authorization': `Bearer ${token}`,
//                 'Content-Type': 'application/json',
//             },
//             body: JSON.stringify({
//                 player1: display_name,
//                 player2: opponentId,
//                 isLocal: false,
//             }),
//             signal: signal,
//           //  cache: 'default',
//         });
        
//         if (!response.ok) { // la reponse echouee (true if (res > 200 && res < 299))
//             throw new Error(`Failed to create online match: ${await response.text}`);
//         };
      
//         const data = await response.json();  
//         const matchId = data.matchId;

//         return matchId;
//     } catch (err: unknown) {
//         if (err instanceof DOMException && err.name === 'AbortError'){
//             console.log('Fetch aborted by user');
//         } else {
//             alert('Error creating online match');
//             console.log(err);
//         }
//         return null;
//     }
// }


// --- Helper to cleanup Socket connexion ---
export function cleanupSocket(socket: SocketIOClient.Socket) {
    socket.removeAllListeners();
    socket.disconnect();
}// app/frontend/conf/services/socket.ts
import { io, Socket } from "socket.io-client"

const socket: typeof Socket = io('http://localhost:3001', {
    transports: ['websocket'],
    autoConnect: false,
});

export default socket;// app/frontend/conf/services/initLocalGame.ts
import { navigateTo } from "./router.js";

export async function initLocalGame(form: HTMLFormElement) {
    const gameMode = form.querySelector<HTMLSelectElement>('#gameMode');
    if (!gameMode) { // optional check ?
        alert('Please select a game mode.');
        return;
    }
    switch (gameMode.value) {
        case '1v1':
            const isValidAlias = (alias: string) => /^[a-zA-Z0-9_-]+$/.test(alias);
            const alias1 = form.querySelector<HTMLInputElement>('#alias1')?.value.trim();
            const alias2 = form.querySelector<HTMLInputElement>('#alias2')?.value.trim();
            
            if (!alias1 || !alias2 ) {
                alert('Please enter aliases for both players.');
                return;
            }
            // sanitaze check (maybe not necessery on client side ?)
            if (!isValidAlias(alias1) || !isValidAlias(alias2)) {
                alert('Aliases can only contain letters, numbers, dashes, and underscores.');
                return;
            }
            if (alias1 === alias2) {
                alert('Aliases should be unique');
                return;
            }
            
            await createLocalMatch(alias1, alias2);
            break;
        case 'Tournament':
        default:
            alert('Unknown game mode selected');
    }
}

// --- Helper function to call an API
async function createLocalMatch(alias1: string, alias2: string) {
    try {
        const response = await fetch('/api/game/match/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                player1: alias1,
                player2: alias2,
                isLocal: true,
            }),
        });
        
        if (!response.ok) {
            throw new Error(`Failed to create local match: ${await response.text}`);
        }
        
        const data = await response.json();
        const matchId = data.matchId;

        if (!matchId) {
            throw new Error('Missing match ID from server.')
        }
        // ! sessionStorage store all data locally 
        // + not erased after page refresh (but after closing the tab)
        sessionStorage.setItem('player1', data.player1);
        sessionStorage.setItem('player2', data.player2);
        sessionStorage.setItem('gameMode', 'local');
        sessionStorage.setItem('localMatchId', matchId);

        navigateTo(`/game-room?matchId=${matchId}`);

    } catch (err: unknown) {
        alert('Error creating local match');
        console.log(err);
    }
}
// app/frontend/conf/services/apiUtils.ts
//@ts-ignore
import { ApiErrorResponse } from "../utils/types.js";

/**
 * Handles an API response, parsing JSON and throwing errors if the response is not OK.
 * @template T The expected response type.
 * @param {Response} response - The fetch API response object.
 * @returns {Promise<T>} The parsed response data.
 * @throws {Error} If the response is not OK or cannot be parsed.
 */
export const handleApiResponse = async <T>(response: Response): Promise<T> => {
	if (!response.ok) {
		let errorData: ApiErrorResponse = { error: `Server error (${response.status})` };
		try {
			errorData = await response.json();
		} catch (jsonError) {
			console.error("Unable to parse error JSON response:", jsonError);
		}
		throw new Error(errorData.error || `HTTP Error ${response.status}: ${response.statusText}`);
	}
	if (response.status === 204) {
		return undefined as T;
	}
	return response.json() as Promise<T>;
};

export function isValidHttpUrl(urlString: string | undefined | null): boolean {
	if (typeof urlString !== 'string' || !urlString) return false;
	try {
		const url = new URL(urlString);
		return url.protocol === "http:" || url.protocol === "https:";
	} catch (_) {
		return false;
	}
}

export function isValidEmailFormat(emailString: string | undefined | null): boolean {
	if (typeof emailString !== 'string' || !emailString) return false;
	return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(emailString);
}
// app/frontend/conf/services/router.ts
import { router } from '../main.js';

export function navigateTo(url: string) {
	window.history.pushState({}, '', url);	// Met √† jour l'URL dans la barre d'adresse sans recharger
	router();
}// app/frontend/conf/services/friendService.ts
import { fetchWithCsrf } from './csrf.js';
import {
	Friend,
	PendingFriendRequest,
	PendingRequestsResponseSchema,
	FriendsListResponseSchema,
	MessageResponseSchema,
} from '../shared/schemas/friendsSchemas.js';
// import { handleApiResponse } from './apiUtils.js';
import { config } from '../utils/config.js';
import { handleApiResponse } from './error.js';

/**
 * Retrieves the friend requests received by the logged-in user.
 * @returns A list of pending friend requests.
 */
export async function getReceivedFriendRequests(): Promise<PendingFriendRequest[]> {
	const url = config.api.friends.receivedRequests;
	const response = await fetch(url, {
		method: 'GET',
		headers: { 'Content-Type': 'application/json' },
		credentials: 'include',
	});
	return handleApiResponse(response, PendingRequestsResponseSchema);
	// return handleApiResponse(response);
}

/**
 * Retrieves the list of friends of the logged-in user.
 * @returns A list of friends.
 */
export async function getFriendsList(): Promise<Friend[]> {
	const url = config.api.friends.list;
	const response = await fetch(url, {
		method: 'GET',
		headers: { 'Content-Type': 'application/json' },
		credentials: 'include',
	});
	return handleApiResponse(response, FriendsListResponseSchema);
}

/**
 * Retrieves the friend requests sent by the logged-in user.
 * @returns A list of sent friend requests.
 */
export async function getSentFriendRequests(): Promise<PendingFriendRequest[]> {
	const url = config.api.friends.sentRequests;
	const response = await fetch(url, {
		method: 'GET',
		headers: { 'Content-Type': 'application/json' },
		credentials: 'include',
	});
	return handleApiResponse(response, PendingRequestsResponseSchema);
}

/**
 * Accepts a friend request.
 * @param friendshipId The ID of the friendship (obtained from a received request).
 * @returns A message indicating the result of the operation.
 */
export async function acceptFriendRequest(friendshipId: number): Promise<{ message: string }> {
	const url = config.api.friends.acceptRequest(friendshipId);
	const response = await fetchWithCsrf(url, {
		method: 'POST',
	});
	return handleApiResponse(response, MessageResponseSchema);
}

/**
 * Declines a received friend request.
 * @param friendshipId The ID of the friendship.
 * @returns A message indicating the result of the operation.
 */
export async function declineFriendRequest(friendshipId: number): Promise<{ message: string }> {
	const url = config.api.friends.declineRequest(friendshipId);
	const response = await fetchWithCsrf(url, {
		method: 'POST',
	});
	return handleApiResponse(response, MessageResponseSchema);
}

/**
 * Cancels a sent friend request.
 * @param friendshipId The ID of the friendship.
 * @returns A message indicating the result of the operation.
 */
export async function cancelFriendRequest(friendshipId: number): Promise<{ message: string }> {
	const url = config.api.friends.cancelRequest(friendshipId);
	const response = await fetchWithCsrf(url, {
		method: 'POST',
	});
	return handleApiResponse(response, MessageResponseSchema);
}

/**
 * Sends a friend request to another user.
 * @param friendId The ID of the friend to be added.
 * @returns A message indicating the result of the operation.
 */
export async function sendFriendRequest(friendId: number): Promise<{ message: string }> {
	const url = config.api.friends.sendRequest;
	const response = await fetchWithCsrf(url, {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({ friendId }),
	});
	return handleApiResponse(response, MessageResponseSchema);
}

/**
 * Removes a friend by friendshipId.
 * @param friendshipId The ID of the friendship to remove.
 * @returns A message indicating the result of the operation.
 */
export async function removeFriend(friendshipId: number): Promise<{ message: string }> {
	const url = config.api.friends.remove(friendshipId);
	const response = await fetchWithCsrf(url, {
		method: 'POST',
	});
	return handleApiResponse(response, MessageResponseSchema);
}
// app/frontend/conf/services/authService.ts
import { fetchWithCsrf, setCsrfToken } from './csrf.js';
import { ApiSuccessResponse, ApiResult } from '../utils/types.js';
import { User, LoginRequestBody, RegisterRequestBody, UpdateUserPayload } from '../shared/schemas/usersSchemas.js';
import { Match, MatchBaseSchema } from '../shared/schemas/matchesSchemas.js';
import { handleApiResponse } from './apiUtils.js';

const USER_DATA_KEY = 'userDataKey';
const USER_DATA_EXPIRATION_KEY = 'userDataExpiration';

/**
 * Retrieves user data (not the token) from localStorage.
 * The presence of this data does not guarantee that the user is still authenticated
 * (the JWT cookie might have expired). An API call is required to confirm authentication.
 * @returns {User | null} User if available, null otherwise.
 */
export function getUserDataFromStorage(): User | null {
	const expiration = localStorage.getItem(USER_DATA_EXPIRATION_KEY);
	if (expiration && new Date().getTime() > parseInt(expiration, 10)) {
		localStorage.removeItem(USER_DATA_KEY);
		localStorage.removeItem(USER_DATA_EXPIRATION_KEY);
		return null;
	}

	const data = localStorage.getItem(USER_DATA_KEY);
	try {
		const parsedData = data ? JSON.parse(data) as User : null;
		if (parsedData && parsedData.id && parsedData.username) {
			return parsedData;
		}
		localStorage.removeItem(USER_DATA_KEY);
		return null;
	} catch (e) {
		console.error("Error reading user data", e);
		localStorage.removeItem(USER_DATA_KEY);
		return null;
	}
}

/**
 * Fetches the list of all users from the API.
 *
 * @returns {Promise<User[]>} An array of User objects. Returns an empty array if the request fails.
 */
export async function fetchUsers(): Promise<User[]> {
	try {
		const response = await fetch('/api/users/');
		if (!response.ok) {
			console.error(`HTTP error! status: ${response.status}`);
			return [];
		}
		const users = await response.json() as User[];
		return users;
	} catch (error) {
		console.error("Failed to fetch users:", error);
		return [];
	}
}

/**
 * Fetches the details of a user by their ID.
 * @param {number} userId - The ID of the user to fetch.
 * @returns {Promise<User>} The user object.
 * @throws {Error} If the fetch fails.
 */
export async function fetchUserDetails(userId: number): Promise<User> {
	try {
		const response = await fetch(`/api/users/${userId}`, {
			method: 'GET',
			headers: {
				'Content-Type': 'application/json',
				'Accept': 'application/json',
			},
			credentials: 'include',
		});
		return await handleApiResponse<User>(response);
	} catch (error) {
		console.error(`Error fetching details for user ${userId}:`, error);
		throw error;
	}
}

/**
 * Fetches the match history for a given user.
 * @param {number} userId - The ID of the user whose match history to fetch.
 * @returns {Promise<Match[]>} An array of matches.
 * @throws {Error} If the fetch fails.
 */
export async function fetchMatchHistoryForUser(userId: number): Promise<Match[]> {
	try {
		// const response = await fetch(`/api/users/${userId}/matches`, {
		const response = await fetch(`/api/game/history/${userId}`, {
			method: 'GET',
			headers: {
				'Content-Type': 'application/json',
				'Accept': 'application/json',
			},
			credentials: 'include',
		});
		return await handleApiResponse<Match[]>(response);
	} catch (error) {
		console.error(`Error fetching match history for user ${userId}:`, error);
		throw error;
	}
}

/**
 * Attempts to verify the authentication status by calling a protected endpoint.
 * The server will verify the JWT cookie.
 * @returns {Promise<User | null>} User if authenticated, null otherwise.
 */
export async function checkAuthStatus(): Promise<User | null> {
	const meUrl = '/api/users/me';
	try {
		const response = await fetch(meUrl, {
			method: 'GET',
			headers: { 'Content-Type': 'application/json' },
			credentials: 'include',
		});
		const user = await handleApiResponse<User>(response);
		localStorage.setItem(USER_DATA_KEY, JSON.stringify(user));
		return user;
	} catch (error) {
		console.error("Error verifying authentication status:", error);
		localStorage.removeItem(USER_DATA_KEY);
		return null;
	}
}

/**
 * Attempts to log in with the provided credentials.
 * @param {LoginRequestBody} credentials - Login credentials (identifier and password).
 * @returns {Promise<ApiResult>} LoginResult indicating success or failure.
 */
export async function attemptLogin(credentials: LoginRequestBody): Promise<ApiResult> {
	if (!credentials.identifier || !credentials.password) {
		return { success: false, error: "Identifier and password are required." };
	}

	const loginUrl = '/api/users/auth/login';

	try {
		const response = await fetch(loginUrl, {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify(credentials),
			credentials: 'include',
		});

		const data: ApiSuccessResponse & { csrfToken: string } = await handleApiResponse(response);

		if (data && data.user) {
			localStorage.setItem(USER_DATA_KEY, JSON.stringify(data.user));
			setCsrfToken(data.csrfToken);
			return { success: true, data: data };
		} else {
			console.warn("No user data received in login response.");
			return { success: false, error: "Problem receiving user data." };
		}
	} catch (error) {
		console.error("Network error or other issue during fetch call:", error);
		const errorMessage = error instanceof Error ? error.message : "Unknown error";
		return { success: false, error: `Server connection error (${errorMessage})` };
	}
}

/**
 * Logs out the user by removing local data and invalidating the server-side session.
 * @returns {Promise<void>}
 */
export async function logout(): Promise<void> {
	const logoutUrl = '/api/users/auth/logout';
	localStorage.removeItem(USER_DATA_KEY);
	console.log("User data removed from localStorage.");

	try {
		const response = await fetchWithCsrf(logoutUrl, {
			method: 'POST',
			credentials: 'include',
		});
		await handleApiResponse<{ message: string }>(response);
		console.log("Server-side logout successful (cookie invalidated).");
	} catch (error) {
		console.error("Error attempting server logout:", error);
	}
}

/**
 * Attempts to register a new user with the provided credentials.
 * @param {RegisterRequestBody} credentials - Registration credentials (username, email, password, etc.).
 * @returns {Promise<ApiResult>} RegisterResult indicating success or failure.
 */
export async function attemptRegister(credentials: RegisterRequestBody): Promise<ApiResult> {
	const registerUrl = '/api/users/auth/register';

	try {
		const payload: any = { ...credentials };
		if (!payload.avatar_url) {
			delete payload.avatar_url;
		}

		const response = await fetch(registerUrl, {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify(payload),
		});

		const data: ApiSuccessResponse = await handleApiResponse(response);

		return { success: true, data };

	} catch (error) {
		console.error("Network error during registration:", error);
		const errorMessage = error instanceof Error ? error.message : "Unknown error";
		return { success: false, error: `Server connection error during registration (${errorMessage})` };
	}
}

/**
 * Updates the user's profile with the provided payload.
 * @param {UpdateUserPayload} payload - Profile update payload (email, display name, avatar URL, etc.).
 * @returns {Promise<ApiResult>} UpdateProfileResult indicating success or failure.
 */
export async function updateUserProfile(payload: UpdateUserPayload): Promise<ApiResult> {
	const profileUpdateUrl = '/api/users/me';

	const cleanPayload = { ...payload };
	if (cleanPayload.avatar_url === undefined || cleanPayload.avatar_url === null || cleanPayload.avatar_url === '') {
		delete cleanPayload.avatar_url;
	}
	try {
		const response = await fetchWithCsrf(profileUpdateUrl, {
			method: 'PATCH',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify(cleanPayload),
			credentials: 'include',
		});

		const data: ApiSuccessResponse = await handleApiResponse(response);

		if (data.user) {
			localStorage.setItem(USER_DATA_KEY, JSON.stringify(data.user));
			console.log("User data updated in localStorage.");
		}
		return { success: true, data: data };

	} catch (error) {
		console.error("Network error during profile update:", error);
		const errorMessage = error instanceof Error ? error.message : "Unknown error";
		return { success: false, error: `Server connection error during update (${errorMessage})` };
	}
}

// import { z } from 'zod';
// import { fetchWithCsrf, setCsrfToken } from './csrf';
// import { ApiResult } from '../utils/types';
// import { User, UserBaseSchema, LoginRequestBody, RegisterRequestBody, UpdateUserPayload } from '../shared/schemas/usersSchemas';
// import { Match, MatchBaseSchema } from '../shared/schemas/matchesSchemas';
// // Importez le bon handleApiResponse
// import { handleApiResponse, ClientApiError } from './error'; 
// import { config } from '../utils/config';

// const USER_DATA_KEY = 'userDataKey';
// const USER_DATA_EXPIRATION_KEY = 'userDataExpiration';

// // Un sch√©ma simple pour les r√©ponses qui n'ont qu'un message
// const MessageResponseSchema = z.object({ message: z.string() });

// // Sch√©ma pour la r√©ponse de login qui contient l'utilisateur et le token CSRF
// const LoginSuccessResponseSchema = z.object({
// 	message: z.string(),
// 	user: UserBaseSchema,
// 	csrfToken: z.string(),
// });

// // Sch√©ma pour la r√©ponse de mise √† jour de profil
// const UpdateProfileSuccessResponseSchema = z.object({
// 	message: z.string(),
// 	user: UserBaseSchema,
// });


// /**
//  * Fetches the list of all users from the API.
//  */
// export async function fetchUsers(): Promise<User[]> {
// 	try {
// 		const response = await fetch(config.api.users.all);
// 		return await handleApiResponse(response, z.array(UserBaseSchema));
// 	} catch (error) {
// 		console.error("Failed to fetch users:", error);
// 		// En cas d'erreur, on renvoie un tableau vide pour ne pas casser l'UI
// 		return [];
// 	}
// }

// /**
//  * Fetches the details of a user by their ID.
//  */
// export async function fetchUserDetails(userId: number): Promise<User> {
// 	const response = await fetch(config.api.users.byId(userId), {
// 		method: 'GET',
// 		headers: {
// 			'Content-Type': 'application/json',
// 			'Accept': 'application/json',
// 		},
// 		credentials: 'include',
// 	});
// 	return handleApiResponse(response, UserBaseSchema);
// }

// /**
//  * Fetches the match history for a given user.
//  */
// export async function fetchMatchHistoryForUser(userId: number): Promise<Match[]> {
// 	const response = await fetch(config.api.game.matchHistory(userId), {
// 		method: 'GET',
// 		headers: {
// 			'Content-Type': 'application/json',
// 			'Accept': 'application/json',
// 		},
// 		credentials: 'include',
// 	});
// 	return await handleApiResponse(response, z.array(MatchBaseSchema));
// }

// /**
//  * Attempts to verify the authentication status by calling a protected endpoint.
//  */
// export async function checkAuthStatus(): Promise<User | null> {
// 	try {
// 		const response = await fetch(config.api.users.me, {
// 			method: 'GET',
// 			headers: { 'Content-Type': 'application/json' },
// 			credentials: 'include',
// 		});
// 		const user = await handleApiResponse(response, UserBaseSchema);
// 		localStorage.setItem(USER_DATA_KEY, JSON.stringify(user));
// 		return user;
// 	} catch (error) {
// 		// Une erreur (ex: 401) est attendue si non connect√©, c'est normal.
// 		if (!(error instanceof ClientApiError && error.httpStatus === 401)) {
// 			console.error("Error verifying authentication status:", error);
// 		}
// 		localStorage.removeItem(USER_DATA_KEY);
// 		return null;
// 	}
// }

// /**
//  * Attempts to log in with the provided credentials.
//  */
// export async function attemptLogin(credentials: LoginRequestBody): Promise<ApiResult> {
// 	if (!credentials.identifier || !credentials.password) {
// 		return { success: false, error: "Identifier and password are required." };
// 	}
// 	try {
// 		const response = await fetch(config.api.auth.login, {
// 			method: 'POST',
// 			headers: { 'Content-Type': 'application/json' },
// 			body: JSON.stringify(credentials),
// 			credentials: 'include',
// 		});

// 		// La gestion d'erreur est maintenant DANS handleApiResponse
// 		const data = await handleApiResponse(response, LoginSuccessResponseSchema);
		
// 		localStorage.setItem(USER_DATA_KEY, JSON.stringify(data.user));
// 		setCsrfToken(data.csrfToken);
// 		// La fonction ne retourne que le succ√®s
// 		return { success: true, data: { message: data.message, user: data.user } };

// 	} catch (error) {
// 		// On attrape l'erreur lev√©e par handleApiResponse
// 		const errorMessage = error instanceof Error ? error.message : "Unknown error during login";
// 		return { success: false, error: errorMessage };
// 	}
// }

// /**
//  * Logs out the user.
//  */
// export async function logout(): Promise<void> {
// 	localStorage.removeItem(USER_DATA_KEY);
// 	console.log("User data removed from localStorage.");

// 	try {
// 		const response = await fetchWithCsrf(config.api.auth.logout, {
// 			method: 'POST',
// 		});
// 		await handleApiResponse(response, MessageResponseSchema);
// 		console.log("Server-side logout successful.");
// 	} catch (error) {
// 		console.error("Error attempting server logout:", error);
// 	}
// }

// /**
//  * Attempts to register a new user.
//  */
// export async function attemptRegister(credentials: RegisterRequestBody): Promise<ApiResult> {
// 	try {
// 		const payload: any = { ...credentials };
// 		if (!payload.avatar_url) {
// 			delete payload.avatar_url;
// 		}

// 		const response = await fetch(config.api.auth.register, {
// 			method: 'POST',
// 			headers: { 'Content-Type': 'application/json' },
// 			body: JSON.stringify(payload),
// 		});

// 		const data = await handleApiResponse(response, MessageResponseSchema);
// 		// La r√©ponse de register ne contient pas de `user`, donc on la construit diff√©remment
// 		return { success: true, data: { message: data.message, user: {} as User } };

// 	} catch (error) {
// 		const errorMessage = error instanceof Error ? error.message : "Unknown error during registration";
// 		return { success: false, error: errorMessage };
// 	}
// }

// /**
//  * Updates the user's profile.
//  */
// export async function updateUserProfile(payload: UpdateUserPayload): Promise<ApiResult> {
// 	const cleanPayload = { ...payload };
// 	if (cleanPayload.avatar_url === undefined || cleanPayload.avatar_url === null || cleanPayload.avatar_url === '') {
// 		// Pour le backend, envoyer `null` explicitement peut √™tre n√©cessaire pour effacer une valeur
// 		cleanPayload.avatar_url = null;
// 	}

// 	try {
// 		const response = await fetchWithCsrf(config.api.users.me, {
// 			method: 'PATCH',
// 			headers: { 'Content-Type': 'application/json' },
// 			body: JSON.stringify(cleanPayload),
// 		});

// 		const data = await handleApiResponse(response, UpdateProfileSuccessResponseSchema);

// 		localStorage.setItem(USER_DATA_KEY, JSON.stringify(data.user));
// 		console.log("User data updated in localStorage.");
		
// 		return { success: true, data: data };

// 	} catch (error) {
// 		const errorMessage = error instanceof Error ? error.message : "Unknown error during profile update";
// 		return { success: false, error: errorMessage };
// 	}
// }// app/frontend/conf/pages/userPage.ts
import { fetchUsers } from '../services/authService.js';
import { UserList } from '../components/userList.js';

export async function UsersPage(): Promise<HTMLElement> {
	const container = document.createElement('div');
	container.className = 'container mx-auto p-8';

	const title = document.createElement('h1');
	title.className = 'text-3xl font-bold mb-6 text-center text-blue-700';
	title.textContent = 'üèì King-Pong User List üèì';

	const userListElement = document.createElement('div');
	userListElement.id = 'user-list';
	userListElement.className = 'mt-6 bg-white p-6 rounded-lg shadow-md';
	userListElement.innerHTML = '<p class="text-center text-gray-500">Loading users...</p>';

	container.appendChild(title);
	container.appendChild(userListElement);

	try {
		const users = await fetchUsers();
		userListElement.innerHTML = '';

		// Fournir des valeurs par d√©faut pour les props requises
		const userListProps = {
			users,
			friends: [],
			sentRequests: [],
			receivedRequests: [],
			currentUserId: -1, // ou null/undefined si tu adaptes UserList
			onSendRequest: async () => { },
			onCancelRequest: async () => { },
			onAcceptRequest: async () => { },
			onDeclineRequest: async () => { },
		};
		userListElement.appendChild(UserList(userListProps));
	} catch (error) {
		console.error("Failed to load users for UsersPage:", error);
		userListElement.innerHTML = '<p class="text-center text-red-500">Error loading users.</p>';
	}

	return container;
}
// app/frontend/conf/pages/dashboardPage.ts
import { navigateTo } from '../services/router.js';
import { getUserDataFromStorage } from '../services/authService.js';
import { fetchCsrfToken } from '../services/csrf.js';
import { User } from '../shared/schemas/usersSchemas.js';
import {
	getReceivedFriendRequests,
	getSentFriendRequests,
	acceptFriendRequest,
	declineFriendRequest,
	cancelFriendRequest,
	getFriendsList,
	sendFriendRequest,
	removeFriend,
} from '../services/friendService.js';
import { fetchUsers } from '../services/authService.js';
import { FriendsListComponent } from '../components/friendsList.js';
import { FriendRequestsComponent } from '../components/friendRequests.js';
import { UserList, UserListProps } from '../components/userList.js';
import { HeaderComponent } from '../components/headerComponent.js';
import { showToast } from '../components/toast.js';
import { MatchHistoryComponent } from '../components/matchHistoryComponent.js';

export async function DashboardPage(): Promise<HTMLElement> {
	const currentUser: User | null = getUserDataFromStorage();

	if (!currentUser) {
		navigateTo('/login');
		const redirectMsg = document.createElement('div');
		redirectMsg.className = 'min-h-screen flex items-center justify-center text-xl';
		redirectMsg.textContent = 'Redirecting to login...';
		return redirectMsg;
	}

	try {
		await fetchCsrfToken();
	} catch (error) {
		console.error("Failed to fetch CSRF token:", error);
		const errorMsg = document.createElement('div');
		errorMsg.className = 'min-h-screen flex items-center justify-center text-xl text-red-500';
		errorMsg.textContent = 'Error initializing page. Please try refreshing.';
		return errorMsg;
	}

	// --- Conteneur principal de la page ---
	const pageContainer = document.createElement('div');
	pageContainer.className = 'min-h-screen bg-gray-200 p-4 sm:p-8 flex flex-col items-center';

	// --- Le "Dashboard" lui-m√™me ---
	const dashboardWrapper = document.createElement('div');
	dashboardWrapper.className = 'bg-white rounded-2xl shadow-2xl w-full max-w-6xl flex flex-col overflow-hidden';

	// --- Section du haut (Langue, User Header) ---
	const headerElement = HeaderComponent({ currentUser: currentUser! });
	// Note: The global click listener for menu close is in HeaderComponent.

	// --- Section principale (Sidebar + Contenu √† onglets) ---
	const mainSection = document.createElement('div');
	mainSection.className = 'flex flex-1 min-h-[calc(100vh-150px)]'; // Hauteur minimale pour le contenu

	// --- Sidebar ---
	const sidebar = document.createElement('div');
	sidebar.className = 'w-1/4 p-6 bg-gray-50 border-r border-gray-200 space-y-3 overflow-y-auto';

	function createSidebarItem(label: string, value: string | number | Date | undefined | null): HTMLElement {
		const item = document.createElement('div');
		item.className = 'p-2.5 bg-white border border-gray-200 rounded-lg shadow-sm';
		const labelEl = document.createElement('span');
		labelEl.className = 'text-xs text-gray-500 block mb-0.5';
		labelEl.textContent = label;
		const valueEl = document.createElement('p');
		valueEl.className = 'text-sm text-gray-800 font-medium truncate';
		if (value instanceof Date) {
			valueEl.textContent = value.toLocaleDateString();
		} else {
			valueEl.textContent = value?.toString() || 'N/A';
		}
		item.appendChild(labelEl);
		item.appendChild(valueEl);
		return item;
	}

	sidebar.appendChild(createSidebarItem('Username', currentUser.username));
	sidebar.appendChild(createSidebarItem('Display Name', currentUser.display_name));
	sidebar.appendChild(createSidebarItem('Email', currentUser.email));
	sidebar.appendChild(createSidebarItem('Creation Date', new Date(currentUser.created_at)));
	sidebar.appendChild(createSidebarItem('Wins', currentUser.wins ?? 'N/A'));
	sidebar.appendChild(createSidebarItem('Losses', currentUser.losses ?? 'N/A'));

	// --- Contenu √† onglets ---
	const tabContentWrapper = document.createElement('div');
	tabContentWrapper.className = 'w-3/4 p-6 flex flex-col overflow-y-auto';

	const tabNavigation = document.createElement('div');
	tabNavigation.className = 'flex space-x-1 border-b border-gray-200 mb-6';

	const TABS = [
		{ id: 'users', label: 'All Users', componentLoader: loadUsersContent },
		{ id: 'friends', label: 'Friends', componentLoader: loadFriendsContent },
		{ id: 'pending', label: 'Pending', componentLoader: loadPendingRequestsContent },
		{ id: 'history', label: 'History Match', componentLoader: loadMatchHistoryContent },
	];
	let activeTabId = TABS[0].id;

	const activeTabContentContainer = document.createElement('div');
	activeTabContentContainer.id = 'active-tab-content';
	activeTabContentContainer.className = 'flex-1';

	TABS.forEach(tabInfo => {
		const tabButton = document.createElement('button');
		tabButton.dataset.tabId = tabInfo.id;
		tabButton.textContent = tabInfo.label;
		tabButton.className = `py-2 px-4 text-sm font-medium focus:outline-none transition-colors`;
		if (tabInfo.id === activeTabId) {
			tabButton.classList.add('border-b-2', 'border-blue-600', 'text-blue-600');
		} else {
			tabButton.classList.add('text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
		}
		tabButton.addEventListener('click', () => switchTab(tabInfo.id));
		tabNavigation.appendChild(tabButton);
	});

	tabContentWrapper.appendChild(tabNavigation);
	tabContentWrapper.appendChild(activeTabContentContainer);

	mainSection.appendChild(sidebar);
	mainSection.appendChild(tabContentWrapper);

	dashboardWrapper.appendChild(headerElement);
	dashboardWrapper.appendChild(mainSection);
	pageContainer.appendChild(dashboardWrapper);

	// --- Fonctions de rappel pour les actions d'amiti√© (utilis√©es par UserList) ---
	const handleSendFriendRequest = async (targetUserId: number) => {
		const result = await sendFriendRequest(targetUserId);
		showToast(result.message);
		if (activeTabId === 'users' || activeTabId === 'pending') await loadActiveTabContent(); // Recharger si l'onglet users ou pending est actif
	};

	const handleCancelFriendRequest = async (friendshipId: number) => {
		const result = await cancelFriendRequest(friendshipId);
		showToast(result.message);
		if (activeTabId === 'users' || activeTabId === 'pending') await loadActiveTabContent();
	};

	const handleAcceptFriendRequest = async (friendshipId: number) => {
		const result = await acceptFriendRequest(friendshipId);
		showToast(result.message, 'success');
		if (['users', 'pending', 'friends'].includes(activeTabId)) await loadActiveTabContent();
	};

	const handleDeclineFriendRequest = async (friendshipId: number) => {
		const result = await declineFriendRequest(friendshipId);
		showToast(result.message, 'success');
		if (activeTabId === 'users' || activeTabId === 'pending') await loadActiveTabContent();
	};

	// --- Logique de chargement et de changement d'onglet ---
	async function switchTab(tabId: string) {
		activeTabId = tabId;
		tabNavigation.querySelectorAll('button').forEach(btn => {
			if (btn.dataset.tabId === tabId) {
				btn.className = 'py-2 px-4 text-sm font-medium focus:outline-none transition-colors border-b-2 border-blue-600 text-blue-600';
			} else {
				btn.className = 'py-2 px-4 text-sm font-medium focus:outline-none transition-colors text-gray-500 hover:text-gray-700 hover:border-gray-300';
			}
		});
		await loadActiveTabContent();
	}

	async function loadActiveTabContent() {
		activeTabContentContainer.innerHTML = '<p class="text-center text-gray-500 py-10">Loading...</p>';
		const currentTab = TABS.find(t => t.id === activeTabId);
		if (currentTab) {
			try {
				const contentElement = await currentTab.componentLoader();
				activeTabContentContainer.innerHTML = '';
				activeTabContentContainer.appendChild(contentElement);
			} catch (error) {
				console.error(`Error loading content for tab ${activeTabId}:`, error);
				activeTabContentContainer.innerHTML = `<p class="text-center text-red-500 py-10">Error loading content for ${activeTabId}.</p>`;
			}
		}
	}

	// --- Fonctions de chargement sp√©cifiques pour chaque onglet ---
	async function loadUsersContent(): Promise<HTMLElement> {
		const [usersData, friendsData, sentRequestsData, receivedRequestsData] = await Promise.all([
			fetchUsers(),
			getFriendsList(),
			getSentFriendRequests(),
			getReceivedFriendRequests()
		]);

		const userListProps: UserListProps = {
			users: usersData as User[],
			friends: friendsData,
			sentRequests: sentRequestsData,
			receivedRequests: receivedRequestsData,
			currentUserId: currentUser!.id,
			onSendRequest: handleSendFriendRequest,
			onCancelRequest: handleCancelFriendRequest,
			onAcceptRequest: handleAcceptFriendRequest,
			onDeclineRequest: handleDeclineFriendRequest,
		};
		return UserList(userListProps);
	}

	async function loadFriendsContent(): Promise<HTMLElement> {
		const friends = await getFriendsList();
		return FriendsListComponent({
			friends: friends,
			onRemoveFriend: async (friendshipId) => {
				const result = await removeFriend(friendshipId);
				showToast(result.message);
				if (['friends', 'users'].includes(activeTabId)) await loadActiveTabContent();
			},
		});
	}

	async function loadPendingRequestsContent(): Promise<HTMLElement> {
		const [received, sent] = await Promise.all([
			getReceivedFriendRequests(),
			getSentFriendRequests(),
		]);
		return FriendRequestsComponent({
			receivedRequests: received,
			sentRequests: sent,
			onAcceptRequest: handleAcceptFriendRequest, // R√©utilisation du handler global
			onDeclineRequest: handleDeclineFriendRequest, // R√©utilisation du handler global
			onCancelRequest: handleCancelFriendRequest, // R√©utilisation du handler global
		});
	}

	async function loadMatchHistoryContent(): Promise<HTMLElement> {
		if (currentUser) {
			return await MatchHistoryComponent({ userId: currentUser.id });
		} else {
			const errorMsg = document.createElement('div');
			errorMsg.className = 'min-h-screen flex items-center justify-center text-xl text-red-500';
			errorMsg.textContent = 'User not found. Please log in.';
			return errorMsg;
		}
	}

	// Charger le contenu de l'onglet initial
	await loadActiveTabContent();

	return pageContainer;
}
// app/frontend/conf/pages/gameRoomPage.ts
import { GameMode } from "../components/gamePage.js";
import { cleanupSocket } from "../services/initOnlineGame.js";
import { navigateTo } from "../services/router.js";
import socket from '../services/socket.js';
import { showGameResult } from "../components/gameResults.js";
import { showCustomConfirm } from "../components/toast.js";
//@ts-ignore
import { GameState } from '../shared/gameTypes.js';
// import { showToast } from '../components/toast.js';
const PADDLE_HEIGHT = 120;
const PADDLE_WIDTH = 20;
const BG_COLOUR = "rgb(0, 0, 0) ";
const BALL_COLOUR = "rgb(255, 255, 255) ";
const PADDLE_COLOUR = "rgb(255, 255, 255) ";

const gameState: GameState = {
	leftPaddle: {
		x: 20,
		y: 200,
		vy: 0, // need to remove
	},
	rightPaddle: {
		x: 770,
		y: 200,
		vy: 0,
	},
	ball: {
		x: 400,
		y: 250,
		radius: 15,
		vx: 0,
		vy: 0,
	},
} 

// boolean qui sert pour arreter dessiner le jeu
let isGameOver = false;

export function GameRoomPage(mode: GameMode): HTMLElement {
	
	// Conteneur principal
	const container = document.createElement('div');
	container.className = `
		w-full h-screen flex flex-col items-center justify-center 
		bg-gradient-to-b from-green-900 via-green-700 to-green-600 
		jungle-font text-white
	`;

	// Wrapper horizontal pour les usernames et canvas
	const gameRow = document.createElement('div');
	gameRow.className = 'flex items-center';

	// Nom du joueur gauche (√† gauche du canvas)
	const leftUsername = document.createElement('div');
	leftUsername.className = `
		mr-4 px-3 py-1 bg-lime-200 text-green-900 
		border border-green-800 rounded font-bold text-xl 
		shadow jungle-font text-center inline-block
	`;
	leftUsername.id = 'left-username';

	// Canvas de jeu
	const canvas = document.createElement('canvas');
	canvas.id = 'pong-canvas';
	canvas.width = 800;
	canvas.height = 500;
	canvas.className = 'border-8 border-green-700 rounded-lg bg-neutral-900';

	// Nom du joueur droit (√† droite du canvas)
	const rightUsername = document.createElement('div');
	rightUsername.className = `
		ml-4 px-3 py-1 bg-lime-200 text-green-900 
		border border-green-800 rounded font-bold text-xl 
		shadow jungle-font text-center inline-block
	`;
	rightUsername.id = 'right-username';

	// Score display
	const scoreDisplay = document.createElement('div');
	scoreDisplay.className = `
		absolute top-8 left-1/2 transform -translate-x-1/2
		text-3xl font-extrabold text-yellow-300 jungle-font drop-shadow
	`;
	scoreDisplay.id = 'score-display';
	scoreDisplay.textContent = '0 - 0';

	// Composition de la ligne
	gameRow.append(leftUsername, canvas, rightUsername, scoreDisplay);
	container.appendChild(gameRow);

	// Quit button
	const quitButton = document.createElement('button');
	quitButton.className = `
		mt-6 px-5 py-2 bg-red-700 text-white font-bold rounded-lg 
		hover:bg-red-800 shadow-lg transition duration-300 jungle-font
	`;
	quitButton.textContent = 'Quit';

	// Ajouter le bouton dans le container principal
	container.appendChild(quitButton);
	
	const gameMode = sessionStorage.getItem('gameMode');
	if (gameMode === 'local') {
		rightUsername.textContent = sessionStorage.getItem('player1');
		leftUsername.textContent = sessionStorage.getItem('player2');
	} else {
		setBoard(leftUsername, rightUsername);
	}

	// Initialiser le canvas
	const ctx = canvas.getContext('2d');
	if (!ctx) throw new Error('Canvas context not supported');
	ctx.fillStyle = BG_COLOUR;
	ctx.fillRect(0, 0, canvas.width, canvas.height);

	// --- Event: quit button ---
	quitButton.addEventListener('click', quitButtonHandler);
	
	drawGame(gameState, ctx);

	clientSocketHandler(scoreDisplay, gameMode, ctx);

	return container;
}


function drawGame(state: GameState, ctx: CanvasRenderingContext2D) {
	
	// Efface tout le canvas
	ctx.fillStyle = BG_COLOUR;
	ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
	 
	// DRAW BALL
	const ball = state.ball;
	 
	ctx.fillStyle = BALL_COLOUR;
	ctx.beginPath();
	ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
	ctx.fill();
	ctx.closePath();
	
	ctx.fillStyle = PADDLE_COLOUR;
	
	// DRAW LEFT PADDLE
	const leftPaddle = state.leftPaddle;
	
	ctx.fillRect(leftPaddle.x, leftPaddle.y, PADDLE_WIDTH, PADDLE_HEIGHT);
	
	// DRAW RIGHT PADDLE
	const rightPaddle = state.rightPaddle;
	
	ctx.fillRect(rightPaddle.x, rightPaddle.y, PADDLE_WIDTH, PADDLE_HEIGHT);
	
	
}

async function quitButtonHandler() {
	const confirmed = await showCustomConfirm("Are you sure you want to quit this game?");
	
	if (confirmed) {
		// const matchId = sessionStorage.getItem('matchId');
		// const opponentId = sessionStorage.getItem('opponent');
		isGameOver = true;
		socket.emit('quitGame');
		cleanupSocket(socket);
		sessionStorage.clear(); // clean storage --> users have to put there aliases again
		navigateTo('/local-game');
		isGameOver = false;
	}
}

// Function to set usernames if they're playing in remote
function setBoard(leftUsername: HTMLDivElement, rightUsername: HTMLDivElement) {
	const side = sessionStorage.getItem('side');
	const displayName = sessionStorage.getItem('displayName');
	const opponent = sessionStorage.getItem('opponent');
	
	if (side === 'left') {
		leftUsername.textContent = displayName;
		rightUsername.textContent = opponent;
	} else if (side === 'right') {
		leftUsername.textContent = opponent;
		rightUsername.textContent = displayName;
	}
}


function clientSocketHandler(scoreDisplay: HTMLDivElement, gameMode: string | null, ctx: CanvasRenderingContext2D) {
	
	if (!socket.connected) {
		socket.connect();
	}
	
	socket.emit('start');
	
	document.addEventListener('keydown', keydown);
	document.addEventListener('keyup', keyup);

	socket.on('gameState', (state: GameState) => {
		handleGameState(state, ctx);
	});

	socket.on('scoreUpdated', ({ score1, score2 }: {score1: number, score2: number})  => {
		if (scoreDisplay) {
			scoreDisplay.textContent = `${score1} - ${score2}`;
		}
	});

	socket.on('gameOver', () => {
		isGameOver = true;
		// showToast ? You want to play again ? 
		cleanupSocket(socket);
		sessionStorage.clear();
		navigateTo('/local-game');
		isGameOver = false;
	});
	
}

function keydown(e: KeyboardEvent) {
//	console.log(e);
	socket.emit('keydown', e.keyCode);
}

function keyup(e: KeyboardEvent) {
	socket.emit('keyup', e.keyCode);
}


function handleGameState(state: GameState, ctx: CanvasRenderingContext2D) {
	if (isGameOver) return;
	requestAnimationFrame(() => drawGame(state, ctx));
}


async function getDisplayName(userId: number) : Promise<string> {
	const userRes = await fetch(`api/users/${userId}`);
	if (!userRes.ok) throw new Error('Failed to fetch user info');
	const userData = await userRes.json();
	const displayName = userData.display_name;
	
	return displayName;
}

async function getUserAvatar(userId: number) : Promise<string> {
	const userRes = await fetch(`/api/users/${userId}`);
	if (!userRes.ok) throw new Error('Failed to fetch user info');
	const userData = await userRes.json();
	const url: string = userData.avatar_url;
	
	return url;
}

// function startOnlineGame(socket: SocketIOClient.Socket) {
	
// 	const side = sessionStorage.getItem('side');
// 	let paddleMovement = 0;

// 	document.addEventListener('keydown', (event) => {
	// 		if (event.key === 'ArrowUp') {
		// 			paddleMovement = -1;
		// 		} else if (event.key === 'ArrowDown') {
			// 			paddleMovement = 1;
			// 		}
			// 		socket.emit('playerMove', {
				// 			side,
				// 			paddleMovement,
				// 		});
				// 	})
				
				// 	document.addEventListener('keyup', (event) => {
					// 		if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
						// 			paddleMovement = 0;
						// 			socket.emit('playerMove', {
							// 				side,
							// 				paddleMovement,
							// 			});
							// 		}
							// 	});
							
							// socket.on('stateUpdate', (data: string) => {
	// 	const { leftPaddleUpdated, rightPaddleUpdated, ballUpdated } = JSON.parse(data);
	// 	document.getElementById('left-paddle')!.style.top = `${leftPaddleUpdated}px`;
	// 	document.getElementById('right-paddle')!.style.top = `${rightPaddleUpdated}px`;
	// 	document.getElementById('ball')!.style.left = `${ballUpdated.x}px`;
	// 	document.getElementById('ball')!.style.top = `${ballUpdated.y}px`;
	// });
	
	//}
	

// socket.on('gameFinished', async (matchId: string) => {
	// 	try {
		// 		const matchRes = await fetch(`/api/game/match/${matchId}`);
		// 		if (!matchRes.ok) throw new Error('Failed to fetch match info');
		// 		const matchData = await matchRes.json();
		// 		const data = matchData.data;
		// 		const player1: number = data.player1_id; // userid
		// 		const player2: number = data.player2_id;
		// 		const score1: number = data.player1_score;
		// 		const score2: number = data.player2_score;
		
		// 		const url1: string = await getUserAvatar(player1);
		// 		const url2: string = await getUserAvatar(player2);
		// 		const name1: string = await getDisplayName(player1);
// 		const name2: string = await getDisplayName(player2);

// 		setTimeout(() => {
	// 			showGameResult(name1, name2, score1, score2, url1, url2);
	// 		}, 2000);
	
	// 	} catch (err: unknown) {
		// 		console.log(`Failed to fetch data from db: ${err}`);
		// 	}
		// });
// app/frontend/conf/pages/profilePage.ts
// profilePage.ts
import { navigateTo } from '../services/router.js';
import { getUserDataFromStorage, fetchUserDetails, fetchMatchHistoryForUser } from '../services/authService.js';
import { fetchCsrfToken } from '../services/csrf.js';
import { User } from '../shared/schemas/usersSchemas.js';
import { HeaderComponent } from '../components/headerComponent.js';
import { showToast } from '../components/toast.js';
import { MatchHistoryComponent } from '../components/matchHistoryComponent.js';

// --- Composant MatchHistory ---
// interface MatchHistoryComponentProps {
// 	userId: number; // ID de l'utilisateur dont on affiche le profil
// }

// async function MatchHistoryComponent(props: MatchHistoryComponentProps): Promise<HTMLElement> {
// 	const { userId: profiledUserId } = props;

// 	const el = document.createElement('div');
// 	el.className = 'p-4';
// 	el.innerHTML = `<h3 class="text-xl font-semibold mb-4 text-gray-800">Historique des Matchs</h3>`;

// 	const loadingMessage = document.createElement('p');
// 	loadingMessage.className = 'text-gray-500 italic';
// 	loadingMessage.textContent = 'Chargement de l\'historique des matchs...';
// 	el.appendChild(loadingMessage);

// 	try {
// 		const matches = await fetchMatchHistoryForUser(profiledUserId);
// 		loadingMessage.remove();

// 		if (!matches || matches.length === 0) {
// 			el.innerHTML += '<p class="text-gray-500">Aucun match trouv√© pour cet utilisateur.</p>';
// 			return el;
// 		}
// 		const opponentsDetailsCache: { [key: number]: { display_name: string } } = {};

// 		const list = document.createElement('ul');
// 		list.className = 'space-y-3';

// 		for (const match of matches) {
// 			let opponentId: number;
// 			let profiledUserScore: number;
// 			let opponentScore: number;
// 			let opponentDisplayName = 'Adversaire Inconnu';

// 			if (match.player1_id === profiledUserId) {
// 				opponentId = match.player2_id;
// 				profiledUserScore = match.player1_score;
// 				opponentScore = match.player2_score;
// 			} else if (match.player2_id === profiledUserId) {
// 				opponentId = match.player1_id;
// 				profiledUserScore = match.player2_score;
// 				opponentScore = match.player1_score;
// 			} else {
// 				console.warn("Match ne semble pas impliquer l'utilisateur profil√©:", match);
// 				continue;
// 			}

// 			if (opponentsDetailsCache[opponentId]) {
// 				opponentDisplayName = opponentsDetailsCache[opponentId].display_name;
// 			} else {
// 				const opponentUser = await fetchUserDetails(opponentId); // ATTENTION: Peut √™tre co√ªteux
// 				if (opponentUser) {
// 					opponentsDetailsCache[opponentId] = { display_name: opponentUser.display_name };
// 					opponentDisplayName = opponentUser.display_name;
// 				} else {
// 					opponentDisplayName = `Joueur ${opponentId}`;
// 				}
// 			}


// 			const resultText = match.winner_id === profiledUserId ? 'Victoire' : (match.winner_id ? 'D√©faite' : '√âgalit√©/Annul√©');
// 			const resultColor = match.winner_id === profiledUserId ? 'text-green-600' : (match.winner_id ? 'text-red-600' : 'text-gray-600');

// 			const item = document.createElement('li');
// 			item.className = 'p-3 bg-gray-100 border border-gray-200 rounded-lg shadow-sm hover:shadow-md transition-shadow';
// 			item.innerHTML = `
//                 <div class="flex justify-between items-center mb-1">
//                     <span class="font-medium text-gray-700">Contre : ${opponentDisplayName}</span>
//                     <span class="font-semibold ${resultColor}">${resultText}</span>
//                 </div>
//                 <div class="text-sm text-gray-600">
//                     Score : ${profiledUserScore} - ${opponentScore}
//                     <span class="mx-1">|</span>
//                     Type : ${match.win_type}
//                     <span class="mx-1">|</span>
//                     Date : ${new Date(match.created_at).toLocaleDateString()}
//                 </div>
//             `; // TODO : changer win_type
// 			list.appendChild(item);
// 		}
// 		el.appendChild(list);

// 	} catch (error) {
// 		console.error("Erreur lors du rendu de l'historique des matchs:", error);
// 		loadingMessage.textContent = `Erreur lors du chargement de l'historique des matchs: ${(error as Error).message}`;
// 		loadingMessage.classList.remove('text-gray-500', 'italic');
// 		loadingMessage.classList.add('text-red-500');
// 	}
// 	return el;
// }


export async function ProfilePage(params: { userId?: string }): Promise<HTMLElement> {
	const loggedInUser: User | null = getUserDataFromStorage();

	if (!loggedInUser) {
		navigateTo('/login');
		const redirectMsg = document.createElement('div');
		redirectMsg.className = 'min-h-screen flex items-center justify-center text-xl';
		redirectMsg.textContent = 'Redirection vers la page de connexion...';
		return redirectMsg;
	}

	const userIdToViewStr = params.userId;
	const userIdToView = userIdToViewStr ? parseInt(userIdToViewStr, 10) : loggedInUser.id;

	if (isNaN(userIdToView)) {
		const errorMsg = document.createElement('div');
		errorMsg.className = 'min-h-screen flex items-center justify-center text-xl text-red-500';
		errorMsg.textContent = 'ID utilisateur invalide.';
		return errorMsg;
	}

	try {
		await fetchCsrfToken();
	} catch (error) {
		console.error("√âchec de la r√©cup√©ration du jeton CSRF:", error);
		showToast("Erreur d'initialisation de la s√©curit√©. Veuillez rafra√Æchir.", 'error');
		const errorMsg = document.createElement('div');
		errorMsg.className = 'min-h-screen flex items-center justify-center text-xl text-red-500';
		errorMsg.textContent = 'Erreur de s√©curit√©. Veuillez rafra√Æchir la page.';
		return errorMsg;
	}

	const pageContainer = document.createElement('div');
	pageContainer.className = 'min-h-screen bg-gray-200 p-4 sm:p-8 flex flex-col items-center';

	const profileWrapper = document.createElement('div');
	profileWrapper.className = 'bg-white rounded-2xl shadow-2xl w-full max-w-6xl flex flex-col overflow-hidden';

	const headerElement = HeaderComponent({ currentUser: loggedInUser });
	profileWrapper.appendChild(headerElement);

	const mainSection = document.createElement('div');
	mainSection.className = 'flex flex-1 min-h-[calc(100vh-150px)]';
	profileWrapper.appendChild(mainSection);
	pageContainer.appendChild(profileWrapper);

	const contentArea = document.createElement('div');
	contentArea.className = 'flex flex-1';
	mainSection.appendChild(contentArea);

	const loadingProfileMsg = document.createElement('p');
	loadingProfileMsg.className = 'text-center text-gray-500 py-20 flex-1 text-lg';
	loadingProfileMsg.textContent = 'Chargement du profil...';
	contentArea.appendChild(loadingProfileMsg);

	try {
		const profiledUser = await fetchUserDetails(userIdToView);

		if (!profiledUser) {
			loadingProfileMsg.textContent = `Profil utilisateur avec ID ${userIdToView} non trouv√©.`;
			loadingProfileMsg.classList.remove('text-gray-500');
			loadingProfileMsg.classList.add('text-red-500');
			return pageContainer;
		}

		loadingProfileMsg.remove();

		// --- Sidebar (infos de l'utilisateur `profiledUser`) ---
		const sidebar = document.createElement('aside');
		sidebar.className = 'w-1/4 p-6 bg-gray-50 border-r border-gray-200 space-y-4 overflow-y-auto flex flex-col';

		function createSidebarItem(label: string, value: string | number | Date | undefined | null, isSensitive: boolean = false): HTMLElement | null {
			if (isSensitive && loggedInUser!.id !== profiledUser.id) {
				return null;
			}

			const item = document.createElement('div');
			item.className = 'p-3 bg-white border border-gray-200 rounded-lg shadow-sm';
			const labelEl = document.createElement('span');
			labelEl.className = 'text-xs text-gray-500 block mb-0.5 uppercase tracking-wider';
			labelEl.textContent = label;
			const valueEl = document.createElement('p');
			valueEl.className = 'text-sm text-gray-800 font-medium truncate';
			if (value instanceof Date) {
				valueEl.textContent = value.toLocaleDateString();
			} else {
				valueEl.textContent = value?.toString() || 'N/A';
			}
			item.appendChild(labelEl);
			item.appendChild(valueEl);
			return item;
		}

		// Affichage de l'avatar dans la sidebar
		const avatarContainer = document.createElement('div');
		avatarContainer.className = 'flex flex-col items-center mb-4';
		const avatarImg = document.createElement('img');
		avatarImg.src = profiledUser.avatar_url || `https://ui-avatars.com/api/?name=${encodeURIComponent(profiledUser.display_name)}&background=random&color=fff&size=128`;
		avatarImg.alt = `Avatar de ${profiledUser.display_name}`;
		avatarImg.className = 'w-24 h-24 sm:w-32 sm:h-32 rounded-full object-cover border-4 border-gray-200 shadow-md mb-2';
		avatarContainer.appendChild(avatarImg);

		const displayNameEl = document.createElement('h2');
		displayNameEl.className = 'text-xl font-semibold text-gray-800 text-center';
		displayNameEl.textContent = profiledUser.display_name;
		avatarContainer.appendChild(displayNameEl);

		sidebar.appendChild(avatarContainer);

		const infoItems = [
			createSidebarItem('Email', profiledUser.email, true), // isSensitive = true
			createSidebarItem('Date de cr√©ation', new Date(profiledUser.created_at)),
			createSidebarItem('Victoires', profiledUser.wins ?? 0),
			createSidebarItem('D√©faites', profiledUser.losses ?? 0),
			createSidebarItem('Statut', profiledUser.status),
		];
		infoItems.forEach(item => item && sidebar.appendChild(item));

		// --- Contenu principal (Match History uniquement) ---
		const contentWrapper = document.createElement('main');
		contentWrapper.className = 'w-3/4 p-6 flex flex-col overflow-y-auto';

		const matchHistoryElement = await MatchHistoryComponent({ userId: profiledUser.id });
		contentWrapper.appendChild(matchHistoryElement);

		contentArea.appendChild(sidebar);
		contentArea.appendChild(contentWrapper);

	} catch (error) {
		console.error("Erreur lors de la construction de la page de profil:", error);
		loadingProfileMsg.textContent = `Erreur lors du chargement du profil : ${(error as Error).message}. Veuillez r√©essayer.`;
		loadingProfileMsg.classList.remove('text-gray-500');
		loadingProfileMsg.classList.add('text-red-500');
	}

	return pageContainer;
}
// app/frontend/conf/pages/settingsPage.ts
// /pages/profilePage.ts
import { getUserDataFromStorage, updateUserProfile } from '../services/authService.js';
import { navigateTo } from '../services/router.js';
import { User, UpdateUserPayload } from '../shared/schemas/usersSchemas.js';
import { ApiResult } from '../utils/types.js';
import { SettingsForm } from '../components/settingsForm.js'; // Importer le composant
import { fetchCsrfToken } from '../services/csrf.js';

export async function SettingsPage(): Promise<HTMLElement> {
	const user: User | null = getUserDataFromStorage();

	const pageContainer = document.createElement('div'); // Conteneur principal de la page
	pageContainer.className = 'min-h-screen bg-gray-100 p-4 md:p-8';

	if (!user) {
		console.warn('Access unauthorized: User not authenticated.');
		navigateTo('/login');

		const deniedContainer = document.createElement('div');
		deniedContainer.className = 'flex items-center justify-center h-full'; // Pour centrer dans pageContainer
		deniedContainer.innerHTML = `
            <div class="bg-white rounded-xl shadow-lg p-8 text-center">
                <h1 class="text-2xl font-bold text-red-600 mb-4">Acc√®s Refus√©</h1>
                <p class="text-gray-700 mb-4">Vous devez √™tre connect√© pour acc√©der √† votre profil.</p>
                <p class="text-gray-700">Redirection vers la page de connexion...</p>
                <!-- <a href="/login" data-link class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                    Se connecter
                </a> -->
            </div>
        `;
		pageContainer.appendChild(deniedContainer);
		return pageContainer;
	}


	try {
		await fetchCsrfToken();
	} catch (error) {
		console.error("Failed to fetch CSRF token:", error);
		const errorMsg = document.createElement('div');
		errorMsg.className = 'min-h-screen flex items-center justify-center text-xl text-red-500';
		errorMsg.textContent = 'Error initializing page. Please try refreshing.';
		return errorMsg;
	}

	const contentWrapper = document.createElement('div');
	contentWrapper.className = 'max-w-xl mx-auto bg-white rounded-xl shadow-lg p-6 md:p-8';

	const title = document.createElement('h1');
	title.className = 'text-3xl font-bold text-gray-800 mb-6 border-b pb-4';
	title.textContent = 'Mon Profil';
	contentWrapper.appendChild(title);

	// Fonction de rappel pour la mise √† jour du profil
	const handleProfileUpdate = async (payload: UpdateUserPayload): Promise<ApiResult> => {
		const result = await updateUserProfile(payload);
		if (result.success) {
			console.log('Profile updated in service, local storage should be updated too.');
		}
		setTimeout(() => { navigateTo('/dashboard'); }, 500);
		return result;
	};

	// Cr√©er et ajouter le composant formulaire
	const profileFormComponent = SettingsForm({
		user: user, // Passer l'utilisateur actuel au composant
		onProfileUpdate: handleProfileUpdate,
	});
	contentWrapper.appendChild(profileFormComponent);

	// Lien de retour
	const backLink = document.createElement('a');
	backLink.href = '/dashboard';
	backLink.setAttribute('data-link', ''); // Pour le routeur
	backLink.className = 'block text-center text-gray-600 hover:text-gray-800 text-sm mt-6'; // Style ajust√©
	backLink.textContent = 'Retour au Tableau de Bord';

	// V√©rifier si le formulaire existe avant d'essayer de l'ins√©rer
	const formElement = contentWrapper.querySelector('#profile-form-component');
	if (formElement && formElement.parentNode) {
		// Ins√©rer le lien apr√®s la derni√®re div du formulaire (celle avec le bouton)
		const lastDivInForm = formElement.children[formElement.children.length - 1];
		if (lastDivInForm && lastDivInForm.parentNode) {
			(lastDivInForm.parentNode as HTMLElement).insertBefore(backLink, lastDivInForm.nextSibling);
		} else {
			contentWrapper.appendChild(backLink); // Fallback
		}
	} else {
		contentWrapper.appendChild(backLink); // Fallback
	}

	pageContainer.appendChild(contentWrapper);
	return pageContainer;
}
// app/frontend/conf/pages/homePage.ts
// import jungleBg from '../assets/jungle-background.jpg';

export function HomePage(): HTMLElement {

	const container = document.createElement('div');
	// --- LE FOND JUNGLE ---
	container.className = 'relative bg-cover bg-center min-h-screen text-white flex flex-col items-center justify-between p-4 sm:p-8';
	// container.style.backgroundImage = `url(${jungleBg})`;
  container.style.backgroundImage = "url('https://images.unsplash.com/photo-1470058869958-2a77ade41c02?w=500&auto=format&fit=crop&q=60&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MXx8anVuZ2xlfGVufDB8fDB8fHww')";
	// container.style.backgroundImage = "url('https://images.unsplash.com/photo-1516528387618-afa90b13e000?w=500&auto=format&fit=crop&q=60&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxzZWFyY2h8M3x8anVuZ2xlfGVufDB8fDB8fHww')";
	
  // --- SUPERPOSITION SOMBRE ---
	const overlay = document.createElement('div');
	overlay.className = 'absolute inset-0 bg-black/40';

	// --- EN-T√äTE (Login/Register) ---
	const header = document.createElement('header');
	header.className = 'relative z-10 w-full flex justify-between items-center';
	
	const logo = document.createElement('h1');
	logo.className = 'text-2xl sm:text-3xl font-bold tracking-wider text-shadow';
	logo.innerHTML = `üèì <span class="hidden sm:inline">King-Pong</span>`;
	
	const authLinks = document.createElement('div');
	authLinks.className = 'flex items-center space-x-2 sm:space-x-4';
	authLinks.innerHTML = `
		<a href="/login" data-link class="text-sm sm:text-base font-semibold px-4 py-2 rounded-full hover:bg-white hover:bg-opacity-20 transition-colors duration-300">
			Login
		</a>
		<a href="/register" data-link class="text-sm sm:text-base bg-green-600 hover:bg-green-500 text-white font-bold px-4 py-2 rounded-full shadow-lg transition-transform duration-300 transform hover:scale-105">
			Register
		</a>
	`;
	header.appendChild(logo);
	header.appendChild(authLinks);

	// --- SECTION PRINCIPALE (Titre et bouton PLAY) ---
	const mainContent = document.createElement('main');
	mainContent.className = 'relative z-10 flex flex-col items-center text-center';

	const title = document.createElement('h2');
	title.className = 'text-4xl sm:text-6xl md:text-7xl font-extrabold mb-4 text-shadow-lg';
	title.textContent = 'The Ultimate Jungle Pong';

	const subtitle = document.createElement('p');
	subtitle.className = 'text-lg sm:text-xl text-gray-200 mb-12 max-w-2xl text-shadow';
	subtitle.textContent = 'Dominate the table. Become the King.';
	
	const playButton = document.createElement('a');
	playButton.href = '/local-game';
	playButton.setAttribute('data-link', '');
	playButton.className = `
		bg-red-600 hover:bg-red-500 text-white font-black 
		text-2xl sm:text-4xl py-4 sm:py-6 px-10 sm:px-16 rounded-full shadow-2xl 
		uppercase tracking-widest 
		transition-all duration-300 ease-in-out 
		transform hover:scale-110 hover:shadow-red-500/50
	`;
	playButton.textContent = 'PLAY';

	mainContent.appendChild(title);
	mainContent.appendChild(subtitle);
	mainContent.appendChild(playButton);

	// --- PIED DE PAGE (Lien API discret) ---
	const footer = document.createElement('footer');
	footer.className = 'relative z-10 w-full text-center';
	
	const apiLink = document.createElement('a');
	apiLink.href = '/game';
	apiLink.setAttribute('data-link', '');
	apiLink.className = 'text-xs text-gray-400 hover:text-white hover:underline transition-colors duration-300';
	apiLink.textContent = 'Check Game API';
	
	footer.appendChild(apiLink);

	// --- Assemblage de la page ---
	container.appendChild(overlay);
	container.appendChild(header);
	container.appendChild(mainContent);
	container.appendChild(footer);

	// --- Ajout des styles ---
	const style = document.createElement('style');
	style.textContent = `
		.text-shadow { text-shadow: 0 2px 4px rgba(0,0,0,0.5); }
		.text-shadow-lg { text-shadow: 0 4px 8px rgba(0,0,0,0.5); }
	`;
	container.appendChild(style);

	return container;
}


	// app/frontend/conf/pages/loginPage.ts
// /pages/loginPage.ts
import { attemptLogin } from '../services/authService.js';
import { navigateTo } from '../services/router.js';
import { LoginForm } from '../components/loginForm.js';
import { LoginRequestBody } from '../shared/schemas/usersSchemas.js';
import { ApiResult } from '../utils/types.js';

export function LoginPage(): HTMLElement {
	const container = document.createElement('div');
	container.className = 'bg-white flex justify-center items-center min-h-screen p-8';
	
	const formContainer = document.createElement('div');
	formContainer.className = 'bg-white bg-opacity-90 backdrop-filter backdrop-blur-lg rounded-xl shadow-2xl p-8 max-w-md w-full';

	const title = document.createElement('h2');
	title.className = 'text-3xl font-bold mb-6 text-center text-gray-800';
	title.textContent = 'Login';

	formContainer.appendChild(title);

	// Fonction de rappel pour la soumission du formulaire
	const handleLoginAttempt = async (credentials: LoginRequestBody): Promise<ApiResult> => {
		return attemptLogin(credentials);
	};

	// Fonction de rappel pour le succ√®s de la connexion
	const handleLoginSuccess = (userData: any) => {
		setTimeout(() => { navigateTo('/dashboard'); }, 500);
	};

	// Cr√©er et ajouter le composant formulaire
	const loginFormComponent = LoginForm({
		onLoginAttempt: handleLoginAttempt,
		onLoginSuccess: handleLoginSuccess,
	});
	formContainer.appendChild(loginFormComponent);


	const linksDiv = document.createElement('div');
	linksDiv.className = 'mt-6 text-center';
	linksDiv.innerHTML = `
        <a href="/" data-link class="text-blue-600 hover:text-blue-800 text-sm">
            Back to Home
        </a>
        <span class="mx-2 text-gray-400">|</span>
        <a href="/register" data-link class="text-blue-600 hover:text-blue-800 text-sm">
            Don't have an account? Register
        </a>
    `;
	formContainer.appendChild(linksDiv);

	container.appendChild(formContainer);

	return container;
}
// app/frontend/conf/images.d.ts
declare module '*.jpg' {
  const value: string;
  export default value;
}// app/frontend/conf/main.ts
import { HomePage } from './pages/homePage.js';
import { LoginPage } from './pages/loginPage.js'
import { RegisterPage } from './components/registerPage.js'
import { UsersPage } from './pages/userPage.js';
import { GamePage } from './components/gamePage.js';
import { GameRoomPage } from './pages/gameRoomPage.js';
import { navigateTo } from './services/router.js';
import { DashboardPage } from './pages/dashboardPage.js'
import { SettingsPage } from './pages/settingsPage.js';
import { ProfilePage } from './pages/profilePage.js';
import { getUserDataFromStorage } from './services/authService.js';
import { promptAliasForm } from './components/aliasFormPage.js';
import { GameMode } from './components/gamePage.js'
// import './style/input.css';

// Conteneur o√π le contenu de la page sera inject√©
const appContainer = document.getElementById('main');

interface RouteConfig {
    component: (params?: { [key: string]: string }) => HTMLElement | Promise<HTMLElement>;
    requiredAuth?: boolean;
}

function renderNotFoundPage(): HTMLElement {
	const div = document.createElement('div');
	div.innerHTML = `
        <h1 class="text-3xl font-bold text-red-500 text-center p-8">404 - Page Non Trouv√©e</h1>
        <p class="text-center">Oups! Cette page n'existe pas.</p>
        <div class="text-center mt-4">
            <a href="/" data-link class="text-blue-500 hover:underline">Retour √† l'accueil</a>
        </div>
    `;
	return div;
}

const routes: { [key: string]: RouteConfig } = {
    '/': { component: HomePage },
    // '/users': { component: UsersPage },
    '/login': { component: LoginPage },
    '/register': { component: RegisterPage },
    '/dashboard': { component: DashboardPage, requiredAuth: true },
    '/profile': { component: SettingsPage, requiredAuth: true },
    '/profile/:id': {
        component: (params) => ProfilePage(params ?? {}),
        requiredAuth: true
    },
    '/game': { component: GamePage },
    '/local-game': { component: promptAliasForm },
    '/game-room': { component: () => GameRoomPageFromParams() },
};

function GameRoomPageFromParams(): HTMLElement {
	const urlParams = new URLSearchParams(window.location.search);
	const mode = urlParams.get('mode') as GameMode || 'local';
	return GameRoomPage(mode);
}

export async function router() {
    if (!appContainer) {
        console.error("ERREUR: Le conteneur #app est introuvable dans le DOM !");
        return;
    }
    const path = window.location.pathname;
    console.log(`navigateTo: ${path}`);

    let routeCfg = routes[path];
    let params: { [key: string]: string } = {};

    // Gestion des routes dynamiques (ex: /profile/:id)
    if (!routeCfg) {
        // Cherche une route dynamique qui matche
        for (const routePattern in routes) {
            if (routePattern.includes('/:')) {
                const base = routePattern.split('/:')[0];
                if (path.startsWith(base + '/')) {
                    const paramName = routePattern.split('/:')[1];
                    const paramValue = path.slice(base.length + 1);
                    routeCfg = routes[routePattern];
                    params[paramName] = paramValue;
                    break;
                }
            }
        }
    }

    if (!routeCfg) {
        appContainer.innerHTML = '';
        appContainer.appendChild(renderNotFoundPage());
        return;
    }
    if (routeCfg.requiredAuth) {
        const authData = getUserDataFromStorage();
        if (!authData) {
            console.log('Utilisateur non authentifi√©, redirection vers la page de connexion.');
            navigateTo('/login');
            return;
        }
    }
    const renderFunction = routeCfg.component;
    appContainer.innerHTML = '';
    try {
        // Passe les params √† la page si besoin
        params.userId = params.id;
        const pageContent = await renderFunction(params);
        appContainer.appendChild(pageContent);
    } catch (error) {
        console.error(`Erreur lors du rendu de la route ${path}:`, error);
        appContainer.innerHTML = `<p class="text-red-500 text-center p-8">Une erreur est survenue lors du chargement de la page.</p>`;
    }
}

// Se d√©clenche lorsque le HTML initial est charg√©
document.addEventListener('DOMContentLoaded', () => {
	document.body.addEventListener('click', (event) => {
		const target = event.target as HTMLElement;
		const linkElement = target.closest('a[data-link]') as HTMLAnchorElement | null;
		if (linkElement) {
			event.preventDefault();
			const destination = linkElement.getAttribute('href');
			if (destination) {
				navigateTo(destination);
			}
		}
	});
	router();
});

// Se d√©clenche lorsque l'utilisateur utilise les boutons Pr√©c√©dent/Suivant du navigateur
window.addEventListener('popstate', () => {
	router();
});
// app/frontend/conf/postcss.config.cjs
module.exports = {
  plugins: {
    '@tailwindcss/postcss': {},
    autoprefixer: {},
  },
}
// app/frontend/conf/vite.config.ts
import { defineConfig } from 'vite'

export default defineConfig({

})// app/frontend/conf/package.json
{
  "name": "frontend",
  "version": "1.0.0",
  "description": "Frontend application for Ping-Pong",
  "type": "module",
  "main": "index.js",
  "scripts": {
    "prepare:dist": "mkdir -p ./dist/css ./dist/js",
    "build:clean": "rm -rf ./dist/*",
    "build:html": "cp index.html ./dist/index.html",
    "build:ts": "tsc",
    "build:css": "./node_modules/.bin/tailwindcss -i ./style/input.css -o ./dist/css/style.css --minify",
    "build": "npm run build:clean && npm run prepare:dist && npm run build:html && npm run build:ts && npm run build:css",
    "watch:ts": "tsc --watch > ./logs/tsc.log 2>&1",
    "watch:css": "./node_modules/.bin/tailwindcss -i ./style/input.css -o ./dist/css/style.css --watch > ./logs/tailwind.log 2>&1",
    "dev": "npm run build && mkdir -p ./logs && concurrently \"npm run watch:ts\" \"npm run watch:css\""
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@tailwindcss/cli": "^4.1.4",
    "@tailwindcss/postcss": "^4.1.8",
    "@tailwindcss/vite": "^4.1.8",
    "@types/node": "^22.15.17",
    "@types/socket.io-client": "^1.4.36",
    "autoprefixer": "^10.4.21",
    "concurrently": "^9.1.2",
    "postcss": "^8.5.4",
    "tailwindcss": "^4.1.8"
  },
  "dependencies": {
    "@fastify/cookie": "^11.0.2",
    "@fastify/csrf-protection": "^7.1.0",
    "@tailwindcss/vite": "^4.1.8",
    "@types/bcrypt": "^5.0.2",
    "bcrypt": "^6.0.0",
    "commander": "^13.1.0",
    "dotenv": "^16.5.0",
    "fastify-type-provider-zod": "^4.0.2",
    "socket.io-client": "^4.8.1",
    "typescript": "^5.8.3",
    "vite": "^6.3.5",
    "zod": "^3.24.4"
  }
}
// app/frontend/conf/index.html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>King-Pong</title>
  <link href="css/style.css" rel="stylesheet">
</head>
<body>
  <div id="main"> <!-- contenu de main.ts -->
    <p>Loading application...</p>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/socket.io-client@4.7.2/dist/socket.io.min.js"></script>
<script type="importmap">
{
  "imports": {
    "zod": "https://cdn.jsdelivr.net/npm/zod@3.24.4/lib/index.mjs"
  }
}
</script>
  <script type="module" src="/js/main.js"></script> <!-- routeur principal -->
</body>
</html>

<!-- <script src="js/app.js" defer></script> -->
// app/frontend/conf/shared/schemas/friendsSchemas.ts
import { z } from 'zod';
import { UserBaseSchema, UserOnlineStatusSchema } from './usersSchemas.js';

export enum FriendshipStatus {
	PENDING = 'pending',
	ACCEPTED = 'accepted',
	DECLINED = 'declined', // Pertinent ?
	BLOCKED = 'blocked',
}
export const FriendshipStatusSchema = z.nativeEnum(FriendshipStatus);

// --- Base Schemas ---
export const FriendshipBaseSchema = z.object({
	id: z.number().int(),
	user1_id: z.number().int(),
	user2_id: z.number().int(),
	initiator_id: z.number().int(),
	status: FriendshipStatusSchema,
	created_at: z.string(), // Ou z.string().date()
});
export type Friendship = z.infer<typeof FriendshipBaseSchema>;

export const FriendSchema = z.object({
	friendship_id: z.number().int(),
	friendship_status: FriendshipStatusSchema,
	friend_id: z.number().int(),
	friend_username: z.string(),
	friend_display_name: z.string(),
	// friend_avatar_url: z.string().url().nullable().optional(), // re-tester : UserBaseSchema.shape.avatar_url
	friend_avatar_url: UserBaseSchema.shape.avatar_url.optional(),
	friend_wins: z.number().int().default(0),
	friend_losses: z.number().int().default(0),
	friend_online_status: UserOnlineStatusSchema,
});
export type Friend = z.infer<typeof FriendSchema>;

// --- Schemas for API requests (Body, Params, Responses) ---
export const SendFriendRequestBodySchema = z.object({
	friendId: z.number().int().min(1, "Friend ID must be a positive integer."),
});
export type SendFriendRequestBody = z.infer<typeof SendFriendRequestBodySchema>;

export const FriendshipIdParamsSchema = z.object({
	friendshipId: z.string().regex(/^\d+$/, "Friendship ID must be a positive integer."),
});
export type FriendshipIdParams = z.infer<typeof FriendshipIdParamsSchema>;

export const FriendRequestUserSchema = UserBaseSchema.pick({
	id: true,
	username: true,
	// email: true, // email ici ?
	display_name: true,
	avatar_url: true,
});
export type FriendRequestUserData = z.infer<typeof FriendRequestUserSchema>;

export const PendingFriendRequestSchema = z.object({
	friendship_id: z.number().int(),
	requester: FriendRequestUserSchema.optional(),
	receiver: FriendRequestUserSchema.optional(),
	created_at: z.string(),
});
export type PendingFriendRequest = z.infer<typeof PendingFriendRequestSchema>;

//--- Routes Schemas ---
export const SendFriendRequestRouteSchema = {
	body: SendFriendRequestBodySchema,
	response: {
		201: z.object({
			message: z.string(),
			friendship: FriendshipBaseSchema
		})
	}
};

export const FriendshipActionRouteSchema = {
	params: FriendshipIdParamsSchema,
	response: {
		200: z.object({ message: z.string() })
	}
};

export const FriendsListResponseSchema = z.array(FriendSchema);
export const GetFriendsListRouteSchema = {
	response: {
		200: FriendsListResponseSchema
	}
};

export const PendingRequestsResponseSchema = z.array(PendingFriendRequestSchema);
export const GetPendingRequestsRouteSchema = {
	response: {
		200: PendingRequestsResponseSchema
	}
};

export const MessageResponseSchema = z.object({ message: z.string() });
// app/frontend/conf/shared/schemas/usersSchemas.ts
import { z } from 'zod';

export enum UserOnlineStatus {
	ONLINE = 'online',
	OFFLINE = 'offline',
	IN_GAME = 'in-game',
}
export const UserOnlineStatusSchema = z.nativeEnum(UserOnlineStatus);

// --- Base Schemas ---
export const UserBaseSchema = z.object({
    id: z.number().int(),
    username: z.string().min(3).max(20),
    email: z.string().email(),
    display_name: z.string().min(3).max(20),
    avatar_url: z.string().url().nullable(),
    wins: z.number().int().default(0),
    losses: z.number().int().default(0),
    status: UserOnlineStatusSchema.default(UserOnlineStatus.OFFLINE),
    created_at: z.string(), // Ou z.date()
    updated_at: z.string(), // Ou z.date()
});
export type User = z.infer<typeof UserBaseSchema>;

export const UserWithPasswordHashSchema = UserBaseSchema.extend({
    password_hash: z.string(),
});
export type UserWithPasswordHash = z.infer<typeof UserWithPasswordHashSchema>;

// --- Schemas for API requests (Body, Params, Responses) ---

// REGISTER
export const RegisterBodySchema = z.object({
    username: UserBaseSchema.shape.username,
    email: UserBaseSchema.shape.email,
    password: z.string().min(8).max(100),
    display_name: UserBaseSchema.shape.display_name,
    avatar_url: UserBaseSchema.shape.avatar_url.optional(),
});
export type RegisterRequestBody = z.infer<typeof RegisterBodySchema>;

export const RegisterRouteSchema = {
    body: RegisterBodySchema,
    response: {
        201: z.object({ message: z.string() })
    }
};

// LOGIN
export const LoginBodySchema = z.object({
    identifier: z.string().min(1),
    password: z.string().min(1),
});
export type LoginRequestBody = z.infer<typeof LoginBodySchema>;

export const LoginRouteSchema = {
    body: LoginBodySchema,
    response: {
        200: z.object({
            message: z.string(),
            user: UserBaseSchema
        })
    }
};

export const LogoutRouteSchema = {
    response: {
        200: z.object({
            message: z.string()
        })
    }
};

// GET ALL USERS
export const GetUsersListRouteSchema = {
    response: {
        200: z.array(UserBaseSchema)
    }
};

// GET /me
export const GetMeRouteSchema = {
    response: {
        200: UserBaseSchema
    }
};

// UPDATE USER
export const UpdateUserBodySchema = z.object({
    email: UserBaseSchema.shape.email.optional(),
    display_name: UserBaseSchema.shape.display_name.optional(),
    avatar_url: UserBaseSchema.shape.avatar_url.optional(),
}).refine(data => Object.keys(data).length > 0, {
    message: "At least one change."
});
export type UpdateUserPayload = z.infer<typeof UpdateUserBodySchema>;

export const UpdateUserRouteSchema = {
    body: UpdateUserBodySchema,
    response: {
        200: z.object({
            message: z.string(),
            user: UserBaseSchema
        })
    }
};

export const UpdatedDbResultSchema = z.object({
	changes: z.number().int().optional(),
});
export type UpdatedUserResult = z.infer<typeof UpdatedDbResultSchema>;

// GET USER BY ID
export const UserIdParamsSchema = z.object({
    userId: z.string().regex(/^\d+$/, "User ID must be a positive integer."),
});
export type UserIdParams = z.infer<typeof UserIdParamsSchema>;

export const GetUserByIdRouteSchema = {
    params: UserIdParamsSchema,
    response: {
        200: UserBaseSchema,
        404: z.object({ error: z.string() })
    }
};

// --- Sch√©mas pour la couche Service/Mod√®le (si diff√©rent de l'API) ---
export const CreateUserPayloadSchema = z.object({
    username: UserBaseSchema.shape.username,
    email: UserBaseSchema.shape.email,
    password_hash: z.string(),
    display_name: UserBaseSchema.shape.display_name,
    avatar_url: UserBaseSchema.shape.avatar_url.optional(),
});
export type CreateUserPayload = z.infer<typeof CreateUserPayloadSchema>;

export const JWTPayloadSchema = z.object({
    id: z.number().int(),
    username: z.string(),
    iat: z.number().optional(), // JWT ajoute ces champs automatiquement
    exp: z.number().optional(),
});
export type JWTPayload = z.infer<typeof JWTPayloadSchema>;

// app/frontend/conf/shared/schemas/matchesSchemas.ts
// Game match schemas
import { z } from 'zod';

export enum MatchStatus {
    PENDING = 'pending',
    IN_PROGRESS = 'in_progress',
    FINISHED = 'finished'
}

export const MatchStatusSchema = z.nativeEnum(MatchStatus);

// --- Base Schemas ---
export const MatchBaseSchema = z.object({
    id: z.number().int(),
    matchId: z.string(), // ou i min
    player1_id: z.number().int(),
    player2_id: z.number().int(),
    player1_socket: z.string(),
    player2_socket: z.string(),
    player1_score: z.number().int().min(0).max(10),
    player2_score: z.number().int().min(0).max(10),
    winner_id: z.number().int(),
    win_type: z.string(),
    created_at: z.string(), // Ou z.date()
    // game_type: z.string(), // ajout arthur au cas ou
    // tournament_id: z.number().int().nullable(), // ajout arthur au cas ou
    // isLocal: z.boolean().default(false), // ajout arthur au cas ou
    status: MatchStatusSchema.default(MatchStatus.PENDING)

});

export type Match = z.infer<typeof MatchBaseSchema>;

// --- Schemas for API requests (Body, Params, Responses) ---

//-- Match creation for localGame
export const createLocalMatchBody = z.object({
    player1: z.string().min(1),
    player2: z.string().min(1),
    isLocal: z.boolean(),
}).strict();

export type createLocalMatchRequestBody = z.infer<typeof createLocalMatchBody>;

export const createLocalMatchRouteSchema = {
    body: createLocalMatchBody,
    response: {
        201: z.object({ message: z.string() })
    }
};

// GET MATCH by MATCH_ID (unique URL)
export const MatchIdParamsSchema = z.object({
    matchId: z.string().uuid()
})

export type MatchIdParams = z.infer<typeof MatchIdParamsSchema>;

export const GetMatchIdRouteSchema = {
    params: MatchIdParamsSchema,
    response: {
        200: MatchBaseSchema,
        404: z.object({ error: z.string() })
    }
};

// GET MATCH HISTORY by USER_ID
export const MatchUserIdParamsSchema = z.object({
    userId: z.string().regex(/^\d+$/, "User ID must be a positive integer."),
    // userId: z.number().int(), // check avec arthur ? pourquoi il utilise regex -> parce que fastify t'envoie une string
});

export type MatchUserIdParams = z.infer<typeof MatchUserIdParamsSchema>;

export const GetMatchByUserIdRouteSchema = {
    params: MatchUserIdParamsSchema,
    response: {
        200: z.array(MatchBaseSchema),
        400: z.object({ error: z.string() }),
        500: z.object({ error: z.string() })
    }
}// app/frontend/conf/tsconfig.json
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "outDir": "./dist/js",
    "rootDir": "./",
    "strict": true,
    "esModuleInterop": true,     // Meilleure interop√©rabilit√© avec les modules CommonJS
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "lib": ["ESNext", "DOM"],
    // "noEmit": true
  //  "allowJs": true
  },
  "include": ["**/*.ts", "**/*.d.ts"],
  "exclude": ["node_modules", "dist"]
}