// app/services/users/utils/dbConfig.ts
// app/services/users/utils/dbConfig.ts
import sqlite3, { Database as SQLite3Database } from 'sqlite3';
import { open, Database } from 'sqlite';
import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

let db: Database | undefined;

export function getDb(): Database {
	if (!db) throw new Error('DB not initialized');
	return db;
}

export async function initializeDb(): Promise<Database> {
	if (db) return db;

	const dbDir = path.join(__dirname, '..', 'db');
	const dbPath = path.join(dbDir, 'database.sqlite');

	if (!fs.existsSync(dbDir)) {
		fs.mkdirSync(dbDir, { recursive: true });
	}

	if (fs.existsSync(dbPath)) {
		fs.unlinkSync(dbPath);
		console.log('Old database.sqlite removed.');
	}

	try {
		db = await open({
			filename: dbPath,
			driver: sqlite3.Database
		});
		console.log('Database connected!');

		let initSQLPath = path.join(__dirname, '..', 'db', 'init.sql');
		if (!fs.existsSync(initSQLPath)) {
			initSQLPath = path.join(__dirname, '..', '..', 'db', 'init.sql');
		}
		if (fs.existsSync(initSQLPath)) {
			const sql = fs.readFileSync(initSQLPath, 'utf-8');
			await db.exec(sql);
			console.log('Database initialized from init.sql.');
		} else {
			console.warn('init.sql not found. Database not initialized.');
		}
		if (!db) throw new Error("DB failed to initialize after setup.");
		return db;
	} catch (err: any) {
		console.error('Error while connecting to the database:', err.message);
		throw new Error(err.message || 'Database initialization failed');
	}
}
// app/services/users/Dockerfile
FROM node:22-alpine

WORKDIR /app

COPY package*.json ./

RUN npm install

COPY . .

#RUN npm run build

#EXPOSE 4000

CMD ["npm", "run", "dev"]
// app/services/users/services/userService.ts
// app/services/users/services/userService.ts
import * as userModel from '../models/userModel.js';
import * as passwordUtils from '../shared/auth-plugin/pswdUtils.js';
import { ERROR_MESSAGES, ConflictError, ValidationError, NotFoundError } from '../shared/auth-plugin/appError.js';
import { User, LoginRequestBody, RegisterRequestBody, UpdateUserPayload, CreateUserPayload } from '../shared/types.js';

/**
 * Generates a default avatar URL using ui-avatars.com.
 * @param {string} name - The name to use for generating the avatar.
 * @returns {string} The generated avatar URL.
 */
function generateDefaultAvatarUrl(name: string): string {
	const encodedName = encodeURIComponent(name);
	return `https://ui-avatars.com/api/?name=${encodedName}&background=random&color=fff&size=128`;
}

/**
 * Checks if a string is a valid HTTP/HTTPS URL.
 * @param {string} urlString - The string to validate.
 * @returns {boolean} True if valid, false otherwise.
 */
function isValidHttpUrl(urlString: string | undefined | null): boolean {
	if (typeof urlString !== 'string' || !urlString) return false;
	try {
		const url = new URL(urlString);
		return url.protocol === "http:" || url.protocol === "https:";
	} catch (_) {
		return false;
	}
}

/**
 * Checks if a string is a valid email format.
 * @param {string} emailString - The string to validate.
 * @returns {boolean} True if valid, false otherwise.
 */
function isValidEmailFormat(emailString: string | undefined | null): boolean {
	if (typeof emailString !== 'string' || !emailString) return false;
	return emailString.includes('@') && emailString.length > 3;
}

/**
 * Logs in a user by verifying their credentials.
 * @param {string} params.identifier - The username or email of the user.
 * @param {string} params.password - The user's password.
 * @throws {ValidationError} If the credentials are invalid.
 * @returns {Promise<User>} The user object without the password hash.
 */
export async function loginUser({ identifier, password }: LoginRequestBody): Promise<User> {
	console.log(`Attempting to log user with identifier: ${identifier}`);
	let userEntity;
	const isEmail = identifier.includes('@');
	if (isEmail) {
		userEntity = await userModel.getUserByEmailFromDb(identifier);
	} else {
		userEntity = await userModel.getUserByUsernameFromDb(identifier);
	}

	if (!userEntity || !(await passwordUtils.comparePassword(password, userEntity.password_hash))) {
		throw new ValidationError('Invalid username/email or password.');
	}

	const { password_hash, ...userPassLess } = userEntity;
	return userPassLess;
}

/**
 * Creates a new user account.
 * @param {RegisterRequestBody} userData - The user data for account creation.
 * @throws {ConflictError} If the username or email already exists.
 * @returns {Promise<void>}
 */
export async function createUserAccount(userData: RegisterRequestBody): Promise<void> {
	console.log('Creating a new user account');
	const { username, email, password, display_name, avatar_url } = userData;

	if (await userModel.isUsernameInDb(username)) {
		throw new ConflictError(ERROR_MESSAGES.USERNAME_ALREADY_EXISTS);
	}
	if (await userModel.isEmailInDb(email)) {
		throw new ConflictError(ERROR_MESSAGES.EMAIL_ALREADY_EXISTS);
	}

	const hashedPassword = await passwordUtils.hashPassword(password);

	const payload: CreateUserPayload = {
		username,
		email,
		password_hash: hashedPassword,
		display_name,
		avatar_url: avatar_url && avatar_url.trim() !== "" ? avatar_url : generateDefaultAvatarUrl(display_name),
	};

	await userModel.createUser(payload);
}

/**
 * Retrieves all users from the database.
 * @returns {Promise<Array>} A list of all users.
 */
export async function getAllUsers(): Promise<User[]> {
	console.log('Fetching all users from the database');
	return userModel.getAllUsersFromDb();
}

/**
 * Retrieves a user by their ID.
 * @param {number} userId - The ID of the user to retrieve.
 * @throws {NotFoundError} If the user does not exist.
 * @returns {Promise<Object>} The user object.
 */
export async function getUserById(userId: number): Promise<User> {
	console.log('Fetching user by ID from the database');
	const user = await userModel.getUserByIdFromDb(userId);
	if (!user) {
		throw new NotFoundError('User not found');
	}
	return user;
}


/**
 * Retrieves the matches of a user by their ID.
 * @param {number} userId - The ID of the user whose matches to retrieve.
 * @throws {NotFoundError} If no matches are found for the user.
 * @returns {Promise<Array>} A list of matches for the user.
 */
export async function getUserMatches(userId: number): Promise<any[]> { // TODO: Use Match[] type
	console.log('Fetching user matches from the database');
	const matches = await userModel.getUserMatchesFromDb(userId);
	if (!matches) {
		throw new NotFoundError('No matches found for this user'); // TODO: virer le if car matches deja undefined si vide
	}
	return matches;
}

/**
 * Updates the profile of a user.
 * @param {number} userId - The ID of the user to update.
 * @param {Object} updates - The updates to apply to the user's profile.
 * @throws {NotFoundError} If the user does not exist.
 * @throws {ValidationError} If the updates are invalid.
 * @throws {ConflictError} If the updated email or display name is already taken.
 * @returns {Promise<Object>} The updated user object without the password hash.
 */
export async function updateUserProfile(userId: number, updates: UpdateUserPayload): Promise<User> {
	console.log(`Attempting to update profile for user ID: ${userId}`);

	const currentUser = await userModel.getUserByIdFromDb(userId);
	if (!currentUser) {
		throw new NotFoundError(`User with ID ${userId} not found`);
	}

	const processedUpdates: UpdateUserPayload = {};

	if (updates.display_name !== undefined) {
		if (typeof updates.display_name === 'string' && updates.display_name.trim().length > 0) {
			processedUpdates.display_name = updates.display_name.trim();
		} else {
			throw new ValidationError('Display name cannot be empty');
		}
	}

	if (updates.email !== undefined) {
		const potentialEmail = updates.email;
		if (potentialEmail && isValidEmailFormat(potentialEmail)) {
			processedUpdates.email = potentialEmail.trim();
		} else {
			throw new ValidationError('Invalid email format provided.');
		}
	}

	if (updates.avatar_url !== undefined) {
		const potentialAvatar = updates.avatar_url;
		if (potentialAvatar === null) {
			processedUpdates.avatar_url = undefined;
		} else if (potentialAvatar && isValidHttpUrl(potentialAvatar)) {
			processedUpdates.avatar_url = potentialAvatar;
		} else if (potentialAvatar && !isValidHttpUrl(potentialAvatar)) {
			throw new ValidationError('Invalid avatar URL format provided.');
		}
	}

	const changesToApply: Partial<UpdateUserPayload> = {};
	for (const key in processedUpdates) {
		const typedKey = key as keyof UpdateUserPayload;
		if (processedUpdates[typedKey] !== currentUser[typedKey as keyof User]) {
			changesToApply[typedKey] = processedUpdates[typedKey];
		}
	}

	if (Object.keys(changesToApply).length === 0) {
		console.log(`No effective changes detected for user ${userId}. Profile remains unchanged.`);
		return currentUser;
	}

	if (changesToApply.display_name && await userModel.isDisplayNameInDb(changesToApply.display_name, userId)) {
		throw new ConflictError(`Display name '${changesToApply.display_name}' is already taken.`);
	}

	if (changesToApply.email && await userModel.isEmailInDb(changesToApply.email, userId)) {
		throw new ConflictError(`Email '${changesToApply.email}' is already taken.`);
	}

	try {
		const result = await userModel.updateUserInDb(userId, changesToApply);
		if (!result.changes || result.changes === 0) {
			const finalUserCheck = await userModel.getUserByIdFromDb(userId);
			if (!finalUserCheck) throw new NotFoundError(`User ${userId} disappeared after update attempt or no changes made.`);
			return finalUserCheck;
		}
	} catch (dbError: any) {
		console.error(`Database error during profile update for user ${userId}:`, dbError);
		throw new Error(`Failed to update profile for user ${userId} due to a database issue.`);
	}

	const updatedUser = await userModel.getUserByIdFromDb(userId);
	if (!updatedUser) {
		throw new Error(`Failed to retrieve user ${userId} immediately after successful update.`);
	}
	return updatedUser;
}

/**
 * Retrieves a user by their email.
 * @param {string} email - The email of the user to retrieve.
 * @throws {NotFoundError} If the user does not exist.
 * @returns {Promise<Object>} The user object.
 */
export async function getUserByEmail(email: string): Promise<User> {
	console.log('Fetching user by email from the database');
	const userWithHash = await userModel.getUserByEmailFromDb(email);
	if (!userWithHash) {
		throw new NotFoundError('User not found');
	}
	const { password_hash, ...user } = userWithHash;
	return user as User;
}

/**
 * Retrieves a user by their username.
 * @param {string} username - The username of the user to retrieve.
 * @throws {NotFoundError} If the user does not exist.
 * @returns {Promise<Object>} The user object.
 */
export async function getUserByUsername(username: string): Promise<User> {
	console.log('Fetching user by username from the database');
	// Note: getUserByUsernameFromDb retourne UserWithPasswordHash, mais on ne veut pas exposer le hash.
	// Il faudrait une version de getUserByUsernameFromDb qui omet le hash, ou le filtrer ici.
	const userWithHash = await userModel.getUserByUsernameFromDb(username);
	if (!userWithHash) {
		throw new NotFoundError('User not found');
	}
	const { password_hash, ...user } = userWithHash;
	return user as User;
}
// app/services/users/services/friendService.ts
// services/friendService.js
import * as friendModel from '../models/friendModel.js';
import * as userModel from '../models/userModel.js';
import { ConflictError, NotFoundError, ValidationError, ForbiddenError } from '../shared/auth-plugin/appError.js';
import { Friendship } from '../shared/types.js';

/**
 * Creates a friend request.
 * @param {number} requesterId - ID of the user sending the request.
 * @param {string} receiverUsername - Username of the user receiving the request.
 * @throws {ValidationError} If required parameters are missing or invalid.
 * @throws {NotFoundError} If the receiver does not exist.
 * @throws {ConflictError} If a friendship or request already exists.
 * @returns {Promise<Object>} The created friendship request.
 */
export async function sendFriendRequest(requesterId: number, receiverId: number): Promise<Friendship> {
	if (requesterId === undefined || receiverId === undefined) {
		throw new ValidationError('Requester ID and receiver username are required.');
	}

	const receiver = await userModel.getUserByIdFromDb(receiverId);
	if (!receiver) {
		throw new NotFoundError(`User with username '${receiverId}' not found.`);
	}

	if (requesterId === receiverId) {
		throw new ValidationError("You cannot send a friend request to yourself.");
	}

	const [id1, id2] = requesterId < receiverId ? [requesterId, receiverId] : [receiverId, requesterId];
	const existingFriendship = await friendModel.getFriendshipByUsersInDb(id1, id2);

	if (existingFriendship) {
		if (existingFriendship.status === 'accepted') {
			throw new ConflictError('You are already friends with this user.');
		} else if (existingFriendship.status === 'pending') {
			if (existingFriendship.initiator_id === requesterId) {
				throw new ConflictError('A friend request to this user is already pending from you.');
			} else {
				throw new ConflictError('This user has already sent you a friend request. Please respond to it.');
			}
		} else if (existingFriendship.status === 'declined' || existingFriendship.status === 'blocked') {
			throw new ConflictError(`A previous interaction (${existingFriendship.status}) exists with this user.`);
		}
	}
	return friendModel.createFriendshipRequestInDb(id1, id2, requesterId);
}

/**
 * Accepts a friend request.
 * @param {number} friendshipId - ID of the friendship request.
 * @param {number} currentUserId - ID of the user accepting the request.
 * @throws {NotFoundError} If the friendship request does not exist.
 * @throws {ConflictError} If the request is not pending.
 * @throws {ForbiddenError} If the user is not authorized to accept the request.
 * @returns {Promise<Object>} A success message.
 */
export async function acceptFriendRequest(friendshipId: number, currentUserId: number): Promise<{ message: string }> {
	const friendship = await friendModel.getFriendshipByIdInDb(friendshipId);

	if (!friendship) {
		throw new NotFoundError('Friend request not found.');
	}
	if (friendship.status !== 'pending') {
		throw new ConflictError(`This friend request is already '${friendship.status}'.`);
	}
	if (friendship.initiator_id === currentUserId) {
		throw new ForbiddenError("You cannot accept a friend request you initiated.");
	}
	if (friendship.user1_id !== currentUserId && friendship.user2_id !== currentUserId) {
		throw new ForbiddenError("You are not part of this friendship request.");
	}

	const result = await friendModel.updateFriendshipStatusInDb(friendshipId, 'accepted');
	if (result.changes === 0) {
		throw new Error('Failed to accept friend request, database reported no changes.');
	}
	return { message: 'Friend request accepted.' };
}

/**
 * Declines or cancels a friend request, or removes an existing friendship.
 * @param {number} friendshipId - ID of the friendship.
 * @param {number} currentUserId - ID of the user performing the action.
 * @throws {NotFoundError} If the friendship does not exist.
 * @throws {ForbiddenError} If the user is not part of the friendship.
 * @returns {Promise<Object>} A success message.
 */
export async function declineOrCancelFriendRequest(friendshipId: number, currentUserId: number): Promise<{ message: string }> {
	const friendship = await friendModel.getFriendshipByIdInDb(friendshipId);

	if (!friendship) {
		throw new NotFoundError('Friendship or request not found.');
	}
	if (friendship.user1_id !== currentUserId && friendship.user2_id !== currentUserId) {
		throw new ForbiddenError("You are not part of this friendship.");
	}

	let actionMessage = '';
	if (friendship.status === 'pending') {
		if (friendship.initiator_id === currentUserId) {
			actionMessage = 'Friend request cancelled.';
		} else {
			actionMessage = 'Friend request declined.';
		}
		await friendModel.deleteFriendshipInDb(friendshipId);
	} else if (friendship.status === 'accepted') {
		await friendModel.deleteFriendshipInDb(friendshipId);
		actionMessage = 'Friend removed successfully.';
	} else {
		await friendModel.deleteFriendshipInDb(friendshipId);
		actionMessage = `Friendship with status '${friendship.status}' removed.`;
	}
	return { message: actionMessage };
}

/**
 * Retrieves the list of accepted friends for a user.
 * @param {number} userId - ID of the user.
 * @throws {NotFoundError} If the user does not exist.
 * @returns {Promise<Array>} List of friends.
 */
export async function getFriends(userId: number): Promise<any[]> {
	const user = await userModel.getUserByIdFromDb(userId);
	if (!user) {
		throw new NotFoundError('User not found.');
	}
	return friendModel.getAcceptedFriendsForUserInDb(userId);
}

/**
 * Retrieves pending friend requests received by a user.
 * @param {number} userId - ID of the user.
 * @throws {NotFoundError} If the user does not exist.
 * @returns {Promise<Array>} List of received friend requests.
 */
export async function getReceivedFriendRequests(userId: number): Promise<any[]> {
	const user = await userModel.getUserByIdFromDb(userId);
	if (!user) {
		throw new NotFoundError('User not found.');
	}
	return friendModel.getPendingReceivedFriendRequestsInDb(userId);
}

/**
 * Retrieves pending friend requests sent by a user.
 * @param {number} userId - ID of the user.
 * @throws {NotFoundError} If the user does not exist.
 * @returns {Promise<Array>} List of sent friend requests.
 */
export async function getSentFriendRequests(userId: number): Promise<any[]> {
	const user = await userModel.getUserByIdFromDb(userId);
	if (!user) {
		throw new NotFoundError('User not found.');
	}
	return friendModel.getPendingSentFriendRequestsInDb(userId);
}

export async function removeFriendship(friendshipId: number, currentUserId: number): Promise<{ message: string }> {

    const friendship = await friendModel.getFriendshipByIdInDb(friendshipId);
	console.log('[removeFriendship] Called with friendshipId:', friendshipId, 'currentUserId:', currentUserId);
    console.log('[removeFriendship] DB result for friendship:', friendship);

    if (!friendship) {
        throw new NotFoundError('Friendship not found.');
    }
    if (friendship.user1_id !== currentUserId && friendship.user2_id !== currentUserId) {
        throw new ForbiddenError("You are not part of this friendship.");
    }
    if (friendship.status !== 'accepted') {
        throw new ConflictError('You can only remove an accepted friend.');
    }

    const result = await friendModel.deleteFriendshipInDb(friendshipId);
    if (result.changes === 0) {
        throw new Error('Failed to remove friend, database reported no changes.');
    }
    return { message: 'Friend removed successfully.' };
}

/**
 * Retrieves all friendships (admin only).
 * @returns {Promise<Array>} List of all friendships.
 */
export async function getAllFriendships(): Promise<any[]> {
	return friendModel.getAllFriendshipsInDb();
}

/**
 * Blocks a user.
 * @param {number} blockerId - ID of the user blocking.
 * @param {number} blockedUserId - ID of the user to block.
 * @throws {ValidationError} If the blocker tries to block themselves.
 * @throws {NotFoundError} If the user to block does not exist.
 * @returns {Promise<{ message: string }>} A success message.
 */
export async function blockUser(
	blockerId: number,
	blockedUserId: number
): Promise<{ message: string }> {
	if (blockerId === blockedUserId) {
		throw new ValidationError("You cannot block yourself.");
	}
	const userToBlock = await userModel.getUserByIdFromDb(blockedUserId);
	if (!userToBlock) {
		throw new NotFoundError("User to block not found.");
	}

	const [id1, id2] = blockerId < blockedUserId ? [blockerId, blockedUserId] : [blockedUserId, blockerId];
	let friendship = await friendModel.getFriendshipByUsersInDb(id1, id2);

	if (friendship) {
		await friendModel.updateFriendshipStatusInDb(friendship.id, 'blocked');
	} else {
		friendship = await friendModel.createFriendshipRequestInDb(id1, id2, blockerId);
		await friendModel.updateFriendshipStatusInDb(friendship.id, 'blocked');
	}
	return { message: `User ${userToBlock.username} has been blocked.` };
}

/**
 * Unblocks a user.
 * @param {number} unblockerId - ID of the user unblocking.
 * @param {number} unblockedUserId - ID of the user to unblock.
 * @throws {NotFoundError} If no active block exists.
 * @returns {Promise<{ message: string }>} A success message.
 */
export async function unblockUser(
	unblockerId: number,
	unblockedUserId: number
): Promise<{ message: string }> {
	const [id1, id2] = unblockerId < unblockedUserId ? [unblockerId, unblockedUserId] : [unblockedUserId, unblockerId];
	const friendship = await friendModel.getFriendshipByUsersInDb(id1, id2);

	if (!friendship || friendship.status !== 'blocked') {
		throw new NotFoundError("No active block found for this user or you cannot unblock.");
	}
	await friendModel.deleteFriendshipInDb(friendship.id);
	return { message: "User has been unblocked. They can send/receive friend requests again." };
}
// app/services/users/models/friendModel.ts
// app/services/users/models/friendModel.ts
import { getDb } from '../utils/dbConfig.js';
import { Friendship, User } from '../shared/types.js'; // Importez vos types

export interface CreateFriendshipResult extends Omit<Friendship, 'created_at'> {} // `created_at` est géré par DB

/**
 * Creates a new friendship request in the database.
 * @param {number} user1Id - ID of the first user.
 * @param {number} user2Id - ID of the second user.
 * @param {number} initiatorId - ID of the user initiating the request.
 * @returns {Promise<CreateFriendshipResult>} The created friendship object with its ID.
 */
export async function createFriendshipRequestInDb(user1Id: number, user2Id: number, initiatorId: number): Promise<CreateFriendshipResult> {
    const db = getDb();
    const [id1, id2] = user1Id < user2Id ? [user1Id, user2Id] : [user2Id, user1Id];

    const result = await db.run(
        `INSERT INTO friendships (user1_id, user2_id, initiator_id, status) VALUES (?, ?, ?, 'pending')`,
        [id1, id2, initiatorId]
    );
    if (result.lastID === undefined) {
        throw new Error("Failed to create friendship, no lastID returned.");
    }
    return { id: result.lastID, user1_id: id1, user2_id: id2, initiator_id: initiatorId, status: 'pending' };
}

/**
 * Retrieves a specific friendship by the IDs of the two users.
 * @param {number} user1Id - ID of the first user.
 * @param {number} user2Id - ID of the second user.
 * @returns {Promise<Friendship | undefined>} The friendship object or undefined if not found.
 */
export async function getFriendshipByUsersInDb(user1Id: number, user2Id: number): Promise<Friendship | undefined> {
    const db = getDb();
    const [id1, id2] = user1Id < user2Id ? [user1Id, user2Id] : [user2Id, user1Id];
    return db.get<Friendship>(
        `SELECT * FROM friendships WHERE user1_id = ? AND user2_id = ?`,
        [id1, id2]
    );
}

/**
 * Retrieves a friendship by its ID.
 * @param {number} friendshipId - ID of the friendship.
 * @returns {Promise<Friendship | undefined>} The friendship object or undefined if not found.
 */
export async function getFriendshipByIdInDb(friendshipId: number): Promise<Friendship | undefined> {
    const db = getDb();
    return db.get<Friendship>(`SELECT * FROM friendships WHERE id = ?`, [friendshipId]);
}

interface UpdateResult {
    changes?: number;
}
/**
 * Updates the status of a friendship.
 * @param {number} friendshipId - ID of the friendship to update.
 * @param {string} status - New status ('accepted', 'declined', 'blocked').
 * @returns {Promise<UpdateResult>} The result of the database operation.
 */
export async function updateFriendshipStatusInDb(friendshipId: number, status: Friendship['status']): Promise<UpdateResult> {
    const db = getDb();
    const result = await db.run(
        `UPDATE friendships SET status = ? WHERE id = ?`,
        [status, friendshipId]
    );
    return { changes: result.changes };
}

/**
 * Deletes a friendship from the database.
 * @param {number} friendshipId - ID of the friendship to delete.
 * @returns {Promise<UpdateResult>} The result of the database operation.
 */
export async function deleteFriendshipInDb(friendshipId: number): Promise<UpdateResult> {
    const db = getDb();
    const result = await db.run(`DELETE FROM friendships WHERE id = ?`, [friendshipId]);
    return { changes: result.changes };
}

// Type pour les amis avec leurs détails
export interface DetailedFriend {
    friendship_id: number;
    friendship_status: Friendship['status'];
    friend_id: number;
    friend_display_name: string;
    friend_username: string;
    friend_wins: number;
    friend_losses: number;
    friend_online_status: User['status'];
    friend_avatar_url: string | null;
}
/**
 * Retrieves all accepted friendships for a specific user.
 * Includes details about the friend (display_name, wins, losses, status, avatar_url).
 * @param {number} userId - ID of the user.
 * @returns {Promise<DetailedFriend[]>} List of friends with their details.
 */
export async function getAcceptedFriendsForUserInDb(userId: number): Promise<DetailedFriend[]> {
    const db = getDb();
    // Le query est long, on assume qu'il retourne les champs correspondants à DetailedFriend
    const query = `
        SELECT
            f.id as friendship_id,
            f.status as friendship_status,
            CASE WHEN f.user1_id = ? THEN u2.id ELSE u1.id END as friend_id,
            CASE WHEN f.user1_id = ? THEN u2.display_name ELSE u1.display_name END as friend_display_name,
            CASE WHEN f.user1_id = ? THEN u2.username ELSE u1.username END as friend_username,
            CASE WHEN f.user1_id = ? THEN u2.wins ELSE u1.wins END as friend_wins,
            CASE WHEN f.user1_id = ? THEN u2.losses ELSE u1.losses END as friend_losses,
            CASE WHEN f.user1_id = ? THEN u2.status ELSE u1.status END as friend_online_status,
            CASE WHEN f.user1_id = ? THEN u2.avatar_url ELSE u1.avatar_url END as friend_avatar_url
        FROM friendships f
        JOIN users u1 ON f.user1_id = u1.id
        JOIN users u2 ON f.user2_id = u2.id
        WHERE (f.user1_id = ? OR f.user2_id = ?) AND f.status = 'accepted'
    `;
    return db.all<DetailedFriend[]>(query, userId, userId, userId, userId, userId, userId, userId, userId, userId);
}

// Type pour les requêtes reçues
export interface ReceivedFriendRequest {
    friendship_id: number;
    created_at: string; // ou Date
    requester: Omit<User, 'wins' | 'losses' | 'status' | 'created_at' | 'updated_at' | 'password_hash'>; // Ajuster les Omit
}
/**
 * Retrieves all pending friend requests received by a user.
 * Includes details about the requester.
 * @param {number} userId - ID of the user who received the requests.
 * @returns {Promise<ReceivedFriendRequest[]>} List of received requests with requester details.
 */
export async function getPendingReceivedFriendRequestsInDb(userId: number): Promise<ReceivedFriendRequest[]> {
    const db = getDb();
    const query = `
        SELECT
            f.id as friendship_id, f.created_at,
            u_initiator.id, u_initiator.username, u_initiator.email,
            u_initiator.display_name, u_initiator.avatar_url
        FROM friendships f
        JOIN users u_initiator ON f.initiator_id = u_initiator.id
        WHERE (f.user1_id = ? OR f.user2_id = ?) AND f.status = 'pending' AND f.initiator_id != ?
        ORDER BY f.created_at DESC;
    `;
    const rows = await db.all<any[]>(query, userId, userId, userId); // any[] pour l'instant
    return rows.map(row => ({
        friendship_id: row.friendship_id,
        created_at: row.created_at,
        requester: {
            id: row.id, username: row.username, email: row.email,
            display_name: row.display_name, avatar_url: row.avatar_url,
        },
    }));
}


// Type pour les requêtes envoyées
export interface SentFriendRequest {
    friendship_id: number;
    created_at: string; // ou Date
    receiver: Omit<User, 'wins' | 'losses' | 'status' | 'created_at' | 'updated_at' | 'password_hash'>; // Ajuster
}
/**
 * Retrieves all pending friend requests sent by a user.
 * Includes details about the receiver.
 * @param {number} userId - ID of the user who sent the requests.
 * @returns {Promise<SentFriendRequest[]>} List of sent requests with receiver details.
 */
export async function getPendingSentFriendRequestsInDb(userId: number): Promise<SentFriendRequest[]> {
    const db = getDb();
    const query = `
        SELECT
            f.id as friendship_id, f.created_at,
            CASE WHEN f.user1_id = f.initiator_id THEN u2.id ELSE u1.id END as id,
            CASE WHEN f.user1_id = f.initiator_id THEN u2.username ELSE u1.username END as username,
            CASE WHEN f.user1_id = f.initiator_id THEN u2.email ELSE u1.email END as email,
            CASE WHEN f.user1_id = f.initiator_id THEN u2.display_name ELSE u1.display_name END as display_name,
            CASE WHEN f.user1_id = f.initiator_id THEN u2.avatar_url ELSE u1.avatar_url END as avatar_url
        FROM friendships f
        JOIN users u1 ON f.user1_id = u1.id
        JOIN users u2 ON f.user2_id = u2.id
        WHERE f.initiator_id = ? AND f.status = 'pending'
        ORDER BY f.created_at DESC;
    `;
    const rows = await db.all<any[]>(query, userId); // any[] pour l'instant
    return rows.map(row => ({
        friendship_id: row.friendship_id,
        created_at: row.created_at,
        receiver: {
            id: row.id, username: row.username, email: row.email,
            display_name: row.display_name, avatar_url: row.avatar_url,
        },
    }));
}


export interface AdminFullFriendship extends Friendship {
    user1_username: string;
    user2_username: string;
    initiator_username: string;
}
/**
 * Retrieves all friendships, regardless of their status.
 * @returns {Promise<AdminFullFriendship[]>} List of all friendships.
 */
export async function getAllFriendshipsInDb(): Promise<AdminFullFriendship[]> {
    const db = getDb();
    return db.all<AdminFullFriendship[]>(`
        SELECT
            f.*, u1.username as user1_username, u2.username as user2_username, ui.username as initiator_username
        FROM friendships f
        JOIN users u1 ON f.user1_id = u1.id
        JOIN users u2 ON f.user2_id = u2.id
        JOIN users ui ON f.initiator_id = ui.id
    `);
}

/**
 * Retrieves a paginated list of friends for a specific user.
 * @param {number} userId - ID of the user.
 * @param {number} limit - Maximum number of friends to retrieve.
 * @param {number} offset - Number of records to skip.
 * @returns {Promise<Friendship[]>} List of friends with their details.
 */
export async function getFriends(userId: number, limit: number = 10, offset: number = 0): Promise<Friendship[]> {
    const db = getDb();
    const query = `
        SELECT * FROM friendships
        WHERE (user1_id = ? OR user2_id = ?) AND status = 'accepted'
        LIMIT ? OFFSET ?
    `;
    return db.all<Friendship[]>(query, userId, userId, limit, offset);
}
// app/services/users/models/userModel.ts
// app/services/users/models/userModel.ts
import { getDb } from '../utils/dbConfig.js';
import { ERROR_MESSAGES } from '../shared/auth-plugin/appError.js';
import { User, UserWithPasswordHash, CreateUserPayload, UpdatedUserResult, UpdateUserPayload } from '../shared/types.js'; // Importez vos types

/**
 * Retrieves all users from the database.
 * @returns {Promise<User[]>} A list of all users.
 */
export async function getAllUsersFromDb(): Promise<User[]> {
	const db = getDb();
	return db.all<User[]>('SELECT id, username, email, display_name, avatar_url, wins, losses, status, created_at, updated_at FROM users');
}

/**
 * Retrieves a user by their display name.
 * @param {string} displayName - The display name of the user.
 * @returns {Promise<UserWithPasswordHash | undefined>} The user object or undefined if not found.
 */
export async function getUserByDisplayNameFromDb(displayName: string): Promise<UserWithPasswordHash | undefined> {
	const db = getDb();
	return db.get<UserWithPasswordHash>('SELECT * FROM users WHERE display_name = ?', [displayName]);
}

/**
 * Retrieves a user by their username.
 * @param {string} username - The username of the user.
 * @returns {Promise<UserWithPasswordHash | undefined>} The user object or undefined if not found.
 */
export async function getUserByUsernameFromDb(username: string): Promise<UserWithPasswordHash | undefined> {
	const db = getDb();
	return db.get<UserWithPasswordHash>('SELECT * FROM users WHERE username = ?', [username]);
}

/**
 * Retrieves a user by their email.
 * @param {string} email - The email of the user.
 * @returns {Promise<UserWithPasswordHash | undefined>} The user object or undefined if not found.
 */
export async function getUserByEmailFromDb(email: string): Promise<UserWithPasswordHash | undefined> {
	const db = getDb();
	return db.get<UserWithPasswordHash>('SELECT * FROM users WHERE email = ?', [email]);
}

/**
 * Retrieves a user by their ID.
 * @param {number} userId - The ID of the user.
 * @returns {Promise<User | undefined>} The user object or undefined if not found.
 */
export async function getUserByIdFromDb(userId: number): Promise<User | undefined> {
	const db = getDb();
	return db.get<User>('SELECT id, username, email, display_name, avatar_url, wins, losses, status, created_at, updated_at FROM users WHERE id = ?', [userId]);
}

/**
 * Retrieves all matches for a specific user.
 * @param {number} userId - The ID of the user.
 * @returns {Promise<any[]>} A list of matches for the user. // TODO: Définir un type Match et l'utiliser
 */
export async function getUserMatchesFromDb(userId: number): Promise<any[]> { // Remplacez any[] par Match[]
	const db = getDb();
	// TODO: Implémentez la requête SQL correcte pour récupérer les matchs
	// Exemple: return db.all('SELECT * FROM matches WHERE player1_id = ? OR player2_id = ?', [userId, userId]);
	console.warn("getUserMatchesFromDb query needs to be implemented correctly for user ID:", userId);
	return db.all('SELECT * FROM matches WHERE player1_id = ? OR player2_id = ?', [userId, userId]); // Placeholder, ajustez
}

/**
 * Creates a new user in the database.
 * @param {CreateUserPayload} user - The user data to insert.
 * @returns {Promise<void>} 
 */
export async function createUser(
	{ username, email, password_hash, display_name, avatar_url = null }: CreateUserPayload
): Promise<void> {
	const db = getDb();
	const result = await db.run(
		`INSERT INTO users (username, email, password_hash, display_name, avatar_url) VALUES (?, ?, ?, ?, ?)`,
		[username, email, password_hash, display_name, avatar_url]
	);
	if (result.lastID === undefined) {
		throw new Error("Failed to create user, no lastID returned.");
	}
}

/**
 * Updates a user's details in the database.
 * @param {number} userId - The ID of the user to update.
 * @param {UpdateUserPayload} updates - The fields to update and their new values.
 * @returns {Promise<UpdatedUserResult>} The result of the database operation.
 * @throws {Error} If an error occurs during the update.
 */
export async function updateUserInDb(userId: number, updates: UpdateUserPayload): Promise<UpdatedUserResult> {
	const db = getDb();
	const fields = Object.keys(updates).filter(k => typeof k === 'string') as Array<keyof UpdateUserPayload>; // Clés typées
	if (fields.length === 0) {
		return { changes: 0 };
	}
	const setClause = fields.map((field) => `${String(field)} = ?`).join(', ');
	const values: (string | number )[] = fields.map((field) => updates[field] as string | number);

	const sql = `UPDATE users SET ${setClause}, updated_at = CURRENT_TIMESTAMP WHERE id = ?`;
	values.push(userId);

	try {
		const result = await db.run(sql, values);
		return { changes: result.changes };
	} catch (error: any) {
		console.error('Error updating user:', error);
		throw new Error(ERROR_MESSAGES.DATABASE_ERROR);
	}
}

export async function deleteUserFromDb(userId: number): Promise<void> {
	const db = getDb();
	const result = await db.run('DELETE FROM users WHERE id = ?', [userId]);
	if (result.changes === 0) {
		throw new Error(ERROR_MESSAGES.USER_NOT_FOUND);
	}
}

export async function isUsernameInDb(username: string, id?: number): Promise<boolean> {
	const db = getDb();
	let query = 'SELECT EXISTS(SELECT 1 FROM users WHERE username = ?';
	const params: (string | number)[] = [username];
	if (id !== undefined) {
		query += ' AND id != ?';
		params.push(id);
	}
	query += ') AS "exists"';
	const row = await db.get<{ exists: number }>(query, params);
	return row?.exists === 1;
}

export async function isEmailInDb(email: string, id?: number): Promise<boolean> {
	const db = getDb();
	let query =	'SELECT EXISTS(SELECT 1 FROM users WHERE email = ?';
	const params: (string | number)[] = [email];
	if (id !== undefined) {
		query += ' AND id != ?';
		params.push(id);
	}
	query += ') AS "exists"';
    const row = await db.get<{ exists: number }>(query, params);
	return row?.exists === 1;
}

export async function isDisplayNameInDb(display_name: string, id?: number): Promise<boolean> {
    const db = getDb();
    let query = 'SELECT EXISTS(SELECT 1 FROM users WHERE display_name = ?';
    const params: (string | number)[] = [display_name];
    if (id !== undefined) {
        query += ' AND id != ?';
        params.push(id);
    }
    query += ') AS "exists"';
    const row = await db.get<{ exists: number }>(query, params);
    return row?.exists === 1;
}
// app/services/users/db/init.sql
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT UNIQUE NOT NULL,
    email TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    display_name TEXT UNIQUE NOT NULL,
    avatar_url TEXT,
    wins INTEGER DEFAULT 0,
    losses INTEGER DEFAULT 0,
    status TEXT NOT NULL DEFAULT 'offline',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS friendships (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user1_id INTEGER NOT NULL,
    user2_id INTEGER NOT NULL,
    initiator_id INTEGER NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY(user1_id) REFERENCES users(id),
    FOREIGN KEY(user2_id) REFERENCES users(id),
    FOREIGN KEY(initiator_id) REFERENCES users(id),
    CONSTRAINT user_order CHECK (user1_id < user2_id),
    CONSTRAINT unique_pair UNIQUE (user1_id, user2_id)
);

CREATE TABLE IF NOT EXISTS matches (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    player1_id INTEGER NOT NULL,
    player2_id INTEGER NOT NULL,
    player1_score INTEGER NOT NULL,
    player2_score INTEGER NOT NULL,
    winner_id INTEGER NOT NULL,
    win_type TEXT NOT NULL DEFAULT 'score',
    match_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    game_type TEXT DEFAULT 'pong',
    tournament_id INTEGER,
    FOREIGN KEY(player1_id) REFERENCES users(id),
    FOREIGN KEY(player2_id) REFERENCES users(id),
    FOREIGN KEY(winner_id) REFERENCES users(id)
);

INSERT OR IGNORE INTO users (username, email, password_hash, display_name, avatar_url)
VALUES
	('Serge', 'serge@student.42.fr', '$2b$10$3Gy9uzvm61CTJ0kuPN3FYu1vJrmylnrmKNmkdoHNTF2owheMzkucu', 'Serge P', 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSq2Q26rH3nI4ossmbYm8jpCyYwuytbyk6iYXJ4_C4tO8FFgv4Wk488h9CB24G5jB46Qjk&usqp=CAU'),
	('Xavier', 'xavier@student.42.fr', '$2b$10$3Gy9uzvm61CTJ0kuPN3FYu1vJrmylnrmKNmkdoHNTF2owheMzkucu', 'Xavier N', 'https://www.lemediaplus.com/wp-content/uploads/2023/02/Xavier-niel-fortune.png'),
	('Donkey_Kong', 'donkeyKong@nitendo.com', '$2b$10$3Gy9uzvm61CTJ0kuPN3FYu1vJrmylnrmKNmkdoHNTF2owheMzkucu', 'Donkey Kong', 'https://m1.quebecormedia.com/emp/emp/dk1b93f6bb-34a1-498c-8234-fb9c7c6f794a_ORIGINAL.jpg?impolicy=crop-resize&x=0&y=0&w=1200&h=675&width=925'),
	('jane_doe', 'jane@example.com', '$2b$10$3Gy9uzvm61CTJ0kuPN3FYu1vJrmylnrmKNmkdoHNTF2owheMzkucu', 'Jane Doe', 'https://ui-avatars.com/api/?name=Jane+Doe&background=random&color=fff&size=128'),
	('alice_smith', 'alice@example.com', '$2b$10$3Gy9uzvm61CTJ0kuPN3FYu1vJrmylnrmKNmkdoHNTF2owheMzkucu', 'Alice Smith', 'https://gravatar.com/avatar/3bd177d6fdf72eecc626c6cc19dfbdc6?s=400&d=identicon&r=g'),
	('Alexis B', 'alexb@example.com', '$2b$10$3Gy9uzvm61CTJ0kuPN3FYu1vJrmylnrmKNmkdoHNTF2owheMzkucu', 'Alexis le Brun', 'https://media.ouest-france.fr/v1/pictures/MjAyMzA5NjIyNGQ3MmNlNzkyNTdjYzgwY2IyNDllOWQ2MmQzYzM?width=1260&height=708&focuspoint=50%2C36&cropresize=1&client_id=bpeditorial&sign=06fccb8b939b1ef4f9042a38edab621665dc6428590f6fa79a643ed33535af5f');



INSERT OR IGNORE INTO friendships (user1_id, user2_id, initiator_id, status)
VALUES
    (1, 5, 1, 'accepted'),-- Serge et alice sont amis (Serge a initié)
    (1, 4, 4, 'accepted'),-- Serge et jane sont amis (jane a initié)
    (1, 3, 3, 'pending'),-- Donkey_kong a envoyé une demande d'ami à Serge (en attente)
    (1, 2, 2, 'pending'),-- Xavier a envoyé une demande d'ami à Serge (en attente)
    (2, 5, 5, 'blocked');-- Alice a bloqué Xavier
// app/services/users/server.ts
import Fastify, { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import dotenv from 'dotenv';
import { initializeDb } from './utils/dbConfig.js';
import { setupPlugins } from './shared/auth-plugin/tokens.js';
import friendRoutes from './routes/friends.js';
import userRoutes from './routes/users.js';
import authRoutes from './routes/auth.js';
import { setupErrorHandler } from './shared/auth-plugin/appError.js';

dotenv.config();

const fastify: FastifyInstance = Fastify({ logger: { level: process.env.LOG_LEVEL || 'debug' } });

function setupHooks(): void {
	fastify.addHook('onRequest', async (req: FastifyRequest, reply: FastifyReply) => {
		if (fastify.log.level === 'trace') {
			req.log.trace({ path: req.raw.url, cookies: req.cookies, headers: req.headers }, '[Logging Hook]');
		} else {
			req.log.debug({ path: req.raw.url, method: req.method }, '[Request Received]');
		}
	});
	fastify.log.info('Logging onRequest hook registered');
}

function setupRoutes(): void {
	fastify.get('/api/users/csrf-token', async (request: FastifyRequest, reply: FastifyReply) => {
		const token: string = await reply.generateCsrf();
		request.log.debug(`[CSRF Endpoint] Token CSRF fourni au client: ${token}`);
		return { csrfToken: token };
	});
	fastify.log.info('CSRF token endpoint /api/users/csrf-token registered');

	fastify.register(userRoutes);
	fastify.register(authRoutes, { prefix: '/api/users/auth' });
	fastify.register(friendRoutes, { prefix: '/api/users/friends' });
	fastify.log.info('Routes registered');
}

async function buildApp(): Promise<FastifyInstance> {
	try {
		await initializeDb();
		fastify.log.info('Database initialized');
		await setupPlugins(fastify);
		setupHooks();
		setupRoutes();
		setupErrorHandler(fastify);
		return fastify;
	} catch (err: any) {
		fastify.log.error({ err: err.message, stack: err.stack }, 'Error initializing app');
		process.exit(1);
	}
}

async function start() {
	let app: FastifyInstance | undefined;
	try {
		app = await buildApp();
		await app.listen({ port: parseInt(process.env.PORT || "4000", 10), host: '0.0.0.0' });
		const address = app.server.address();
		const port = typeof address === 'string' ? address : (address?.port);
		app.log.info(`Server listening on ${port || 'unknown port'}`);
	} catch (err: any) {
		const logger = app?.log || console;
		logger.error({ err: err.message, stack: err.stack }, 'Failed to start server:');
		process.exit(1);
	}
}

start();
// app/services/users/handlers/friendsHandlers.ts
import { FastifyRequest, FastifyReply } from 'fastify';
import * as friendService from '../services/friendService.js';
import { ERROR_MESSAGES, AppError } from '../shared/auth-plugin/appError.js';
import { JWTPayload } from '../shared/types.js';

// Types pour les requêtes avec params
interface FriendshipIdRequest extends FastifyRequest<{ Params: { friendshipId: string } }> {
	user: JWTPayload;
}
interface BlockUserRequest extends FastifyRequest<{ Params: { userIdToBlock: string } }> {
	user: JWTPayload;
}
interface UnblockUserRequest extends FastifyRequest<{ Params: { userIdToUnblock: string } }> {
	user: JWTPayload;
}

export async function sendFriendRequestHandler(req: FastifyRequest, reply: FastifyReply) {
	const requesterId = (req.user as JWTPayload).id;
	const { friendId } = req.body as { friendId: number };

	req.log.info({ requesterId, friendId }, 'Attempting to send friend request');
	const newFriendship = await friendService.sendFriendRequest(requesterId, friendId);
	return reply.code(201).send({
		message: 'Friend request sent successfully.',
		friendship: newFriendship
	});
}

export async function getReceivedRequestsHandler(req: FastifyRequest, reply: FastifyReply) {
	const userId = (req.user as JWTPayload).id;
	req.log.info({ userId }, 'Fetching received friend requests');
	const requests = await friendService.getReceivedFriendRequests(userId);
	return reply.send(requests);
}

export async function getSentRequestsHandler(req: FastifyRequest, reply: FastifyReply) {
	const userId = (req.user as JWTPayload).id;
	req.log.info({ userId }, 'Fetching sent friend requests');
	const requests = await friendService.getSentFriendRequests(userId);
	return reply.send(requests);
}

export async function acceptFriendRequestHandler(req: FastifyRequest, reply: FastifyReply) {
	const currentUserId = (req.user as JWTPayload).id;
	const friendshipId = parseInt((req.params as any).friendshipId, 10);

	if (isNaN(friendshipId)) {
		throw new AppError(ERROR_MESSAGES.INVALID_FRIENDSHIP_ID, 400);
	}

	req.log.info({ currentUserId, friendshipId }, 'Attempting to accept friend request');
	const result = await friendService.acceptFriendRequest(friendshipId, currentUserId);
	return reply.send(result);
}

export async function declineFriendRequestHandler(req: FastifyRequest, reply: FastifyReply) {
	const currentUserId = (req.user as JWTPayload).id;
	const friendshipId = parseInt((req.params as any).friendshipId, 10);

	if (isNaN(friendshipId)) {
		throw new AppError(ERROR_MESSAGES.INVALID_FRIENDSHIP_ID, 400);
	}

	req.log.info({ currentUserId, friendshipId }, 'Attempting to decline friend request');
	const result = await friendService.declineOrCancelFriendRequest(friendshipId, currentUserId);
	return reply.send(result);
}

export async function cancelFriendRequestHandler(req: FastifyRequest, reply: FastifyReply) {
	const currentUserId = (req.user as JWTPayload).id;
	const friendshipId = parseInt((req.params as any).friendshipId, 10);

	if (isNaN(friendshipId)) {
		throw new AppError(ERROR_MESSAGES.INVALID_FRIENDSHIP_ID, 400);
	}

	req.log.info({ currentUserId, friendshipId }, 'Attempting to cancel friend request');
	const result = await friendService.declineOrCancelFriendRequest(friendshipId, currentUserId);
	return reply.send(result);
}

export async function getMyFriendsHandler(req: FastifyRequest, reply: FastifyReply) {
	const userId = (req.user as JWTPayload).id;
	req.log.info({ userId }, 'Fetching user friends list');
	const friends = await friendService.getFriends(userId);
	return reply.send(friends);
}

export async function removeFriendshipHandler(
//    req: FastifyRequest<{ Params: { friendshipId: string } }>,
    req: FastifyRequest,
    reply: FastifyReply
) {
    const currentUserId = (req.user as JWTPayload).id;
    const friendshipId = parseInt((req.params as any).friendshipId, 10);

    if (isNaN(friendshipId)) {
        return reply.code(400).send({ error: "Invalid friendship ID." });
    }

    req.log.info({ currentUserId, friendshipId }, 'Attempting to remove friendship');
    const result = await friendService.removeFriendship(friendshipId, currentUserId);
    return reply.send(result);
}

export async function blockUserHandler(req: BlockUserRequest, reply: FastifyReply) {
	const blockerId = req.user.id;
	const userIdToBlock = parseInt(req.params.userIdToBlock, 10);

	if (isNaN(userIdToBlock)) {
		throw new AppError('Invalid user ID to block.', 400);
	}
	req.log.info({ blockerId, userIdToBlock }, 'Attempting to block user');
	const result = await friendService.blockUser(blockerId, userIdToBlock);
	return reply.send(result);
}

export async function unblockUserHandler(req: UnblockUserRequest, reply: FastifyReply) {
	const unblockerId = req.user.id;
	const userIdToUnblock = parseInt(req.params.userIdToUnblock, 10);

	if (isNaN(userIdToUnblock)) {
		throw new AppError('Invalid user ID to unblock.', 400);
	}
	req.log.info({ unblockerId, userIdToUnblock }, 'Attempting to unblock user');
	const result = await friendService.unblockUser(unblockerId, userIdToUnblock);
	return reply.send(result);
}

export async function getAllFriendshipsHandler(req: FastifyRequest, reply: FastifyReply) {
	req.log.info('Admin fetching all friendships');
	const friendships = await friendService.getAllFriendships();
	return reply.send(friendships);
}
// app/services/users/handlers/userHandlers.ts
// Gère les requêtes Fastify (req, reply)
import { FastifyRequest, FastifyReply } from 'fastify';
import * as userService from '../services/userService.js';
import { JWTPayload, UpdateUserPayload } from '../shared/types.js';

export type AuthenticatedRequest = FastifyRequest & { user: JWTPayload };

export type UpdateRequest = FastifyRequest<{ Body: UpdateUserPayload }> & { user: JWTPayload };

export async function getUsersHandler(req: FastifyRequest, reply: FastifyReply) {
	const users = await userService.getAllUsers();
	return reply.code(200).send(users);
}

export async function getUserMeHandler(req: AuthenticatedRequest, reply: FastifyReply) {
	const user = await userService.getUserById(req.user.id);
	return reply.code(200).send(user);
}

export async function getUserMeMatchHandler(req: AuthenticatedRequest, reply: FastifyReply) {
	const matches = await userService.getUserMatches(req.user.id);
	return reply.code(200).send(matches);
}

export async function updateUserMeHandler(req: UpdateRequest, reply: FastifyReply) {
	const userId = req.user.id;
	const updates = req.body;

	req.log.info({ userId, updates }, 'Attempting to update user profile');
	const updatedUser = await userService.updateUserProfile(userId, updates);

	return reply.code(200).send({
		message: 'User updated successfully',
		user: updatedUser
	});
}
// app/services/users/handlers/authHandlers.ts
import { FastifyRequest, FastifyReply } from 'fastify';
import { createUserAccount, loginUser } from '../services/userService.js';
import { jwtToken, cookieOptions } from '../shared/auth-plugin/tokens.js';
import { ERROR_MESSAGES } from '../shared/auth-plugin/appError.js';
import { JWTPayload, User, RegisterRequestBody, LoginRequestBody } from '../shared/types.js';

export async function registerHandler(req: FastifyRequest<{ Body: RegisterRequestBody }>, reply: FastifyReply) {
	await createUserAccount(req.body);

	return reply.code(201).send({
		message: 'Registration successful. Please log in.'
	});
}

export async function loginHandler(req: FastifyRequest<{ Body: LoginRequestBody }>, reply: FastifyReply) {
	const user = await loginUser(req.body);
	const tokenPayload: JWTPayload = { id: user.id, username: user.username };
	const token = reply.server.jwt.sign(tokenPayload);
	const decodedToken = reply.server.jwt.decode(token) as { exp: number };

	reply.setCookie(jwtToken, token, {
		...cookieOptions,
		expires: new Date(decodedToken.exp * 1000),
	});

	return reply.send({
		message: 'Login accepted',
		user,
	});
}

export async function logoutHandler(req: FastifyRequest, reply: FastifyReply) {
	reply.clearCookie(jwtToken, cookieOptions);
	return reply.send({ message: 'Logout successful' });
}

export async function refreshTokenHandler(req: FastifyRequest, reply: FastifyReply) {
	const refreshToken = (req.cookies as any).refreshToken;
	if (!refreshToken) {
		return reply.code(401).send({ error: ERROR_MESSAGES.REFRESH_TOKEN_MISSING });
	}

	try {
		const decoded = reply.server.jwt.verify(refreshToken, { ignoreExpiration: false }) as JWTPayload & { exp: number };
		const newToken = reply.server.jwt.sign({ id: decoded.id, username: decoded.username });
		reply.setCookie(jwtToken, newToken, {
			...cookieOptions,
			expires: new Date(decoded.exp * 1000),
		});
		return reply.send({ message: 'Token refreshed successfully' });
	} catch (err) {
		return reply.code(401).send({ error: ERROR_MESSAGES.INVALID_REFRESH_TOKEN });
	}
}
// app/services/users/.dockerignore
# Node modules (can be installed with npm install)
node_modules/
# ignore git history
.git
# ignore cache directory
.DS_Store// app/services/users/package.json
{
  "name": "users",
  "version": "1.0.0",
  "main": "dist/server.js",
  "type": "module",
  "description": "Fastify app with SQLite",
  "scripts": {
    "clean": "rm -rf dist",
    "build": "npm run clean && tsc",
    "start": "node dist/server.js",
    "dev": "npm run build && concurrently \"tsc -w\" \"nodemon dist/server.js\" | pino-pretty",
    "start:dev": "node --inspect dist/server.js"
},
  "dependencies": {
    "@fastify/static": "^6.0.1",
    "@fastify/jwt": "^9.1.0",
    "@fastify/cookie": "^11.0.2",
    "@fastify/csrf-protection": "^7.1.0",
    "fastify": "^5.3.2",
    "concurrently": "^9.1.2",
    "dotenv": "^16.5.0",
    "bcrypt": "^5.1.1",
    "sqlite3": "^5.1.7",
    "sqlite": "^5.1.1"
  },
  "devDependencies": {
    "typescript": "^5.3.3",
    "@types/node": "^22.15.18",
    "@types/bcrypt": "^5.0.2",
    "@types/sqlite3": "^5.1.0",
	"pino": "^9.6.0",
	"pino-pretty": "^13.0.0",
    "nodemon": "^3.1.10",
    "dotenv-cli": "^8.0.0"
  }
}
// app/services/users/routes/users.ts
import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import {
	getUsersHandler,
	getUserMeHandler,
	getUserMeMatchHandler,
	updateUserMeHandler,
} from '../handlers/userHandlers.js';
import { UpdateUserPayload } from '../shared/types.js';
import { updateUserSchema } from '../schemas/userSchemas.js';

export default async function userRoutes(fastify: FastifyInstance, options: FastifyPluginOptions) {
	const URL_ALL_USERS = process.env.URL_ALL_USERS;
	const URL_USER = process.env.URL_USER;
	const URL_USER_MATCH = process.env.URL_USER_MATCH;

	if (!URL_ALL_USERS) {
		throw new Error('Missing required environment variable: URL_ALL_USERS');
	}
	if (!URL_USER) {
		throw new Error('Missing required environment variable: URL_USER');
	}
	if (!URL_USER_MATCH) {
		throw new Error('Missing required environment variable: URL_USER_MATCH');
	}

	fastify.get(URL_ALL_USERS, getUsersHandler);

	fastify.get(URL_USER,
		{ onRequest: [fastify.authenticate] },
		getUserMeHandler
	);

	fastify.patch<{ Body: UpdateUserPayload }>(URL_USER,
		{
			onRequest: [fastify.authenticate, fastify.csrfProtection],
			schema: updateUserSchema
		},
		updateUserMeHandler
	);

	fastify.get(URL_USER_MATCH,
		{ onRequest: [fastify.authenticate] },
		getUserMeMatchHandler
	);
}// app/services/users/routes/auth.ts
import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { loginHandler, logoutHandler, registerHandler } from '../handlers/authHandlers.js';
import { registerSchema, loginSchema, logoutSchema } from '../schemas/userSchemas.js';

export default async function authRoute(fastify: FastifyInstance, options: FastifyPluginOptions) {
	fastify.post(
		'/login',
		{ schema: loginSchema },
		loginHandler
	);
	fastify.post(
		'/register',
		{ schema: registerSchema },
		registerHandler
	);
	fastify.post(
		'/logout',
		{ schema: logoutSchema },
		logoutHandler
	);
}
// app/services/users/routes/friends.ts
import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import {
	acceptFriendRequestHandler,
	declineFriendRequestHandler,
	getReceivedRequestsHandler,
	getSentRequestsHandler,
	sendFriendRequestHandler,
	cancelFriendRequestHandler,
	getMyFriendsHandler,
	removeFriendshipHandler,
} from "../handlers/friendsHandlers.js";
import {
	sendFriendRequestSchema,
	friendshipIdParamSchema,
} from "../schemas/friendsSchemas.js";

type FriendshipIdRoute = {
	Params: { friendshipId: string }
};

export default async function friendRoutes(fastify: FastifyInstance, options: FastifyPluginOptions) {
	fastify.post(
		'/requests',
		{
			onRequest: [fastify.authenticate, fastify.csrfProtection],
			schema: sendFriendRequestSchema
		},
		sendFriendRequestHandler
	);
	fastify.get(
		'/requests/received',
		{ onRequest: [fastify.authenticate] },
		getReceivedRequestsHandler
	);
	fastify.get(
		'/requests/sent',
		{ onRequest: [fastify.authenticate] },
		getSentRequestsHandler
	);
	fastify.post(
		'/requests/:friendshipId/accept',
		{
			onRequest: [fastify.authenticate, fastify.csrfProtection],
			schema: friendshipIdParamSchema
		},
		acceptFriendRequestHandler
	);
	fastify.post(
		'/requests/:friendshipId/decline',
		{
			onRequest: [fastify.authenticate, fastify.csrfProtection],
			schema: friendshipIdParamSchema
		},
		declineFriendRequestHandler
	);
	fastify.post(
		'/requests/:friendshipId/cancel',
		{
			onRequest: [fastify.authenticate, fastify.csrfProtection],
			schema: friendshipIdParamSchema
		},
		cancelFriendRequestHandler
	);
	fastify.get(
		'/friends',
		{ onRequest: [fastify.authenticate] },
		getMyFriendsHandler
	);
	fastify.post(
//	fastify.post<FriendshipIdRoute>(
		'/:friendshipId/remove',
		{
			onRequest: [fastify.authenticate, fastify.csrfProtection],
			schema: friendshipIdParamSchema
		},
		removeFriendshipHandler
	);
};
// app/services/users/tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "rootDir": "./", // Tous les fichiers .ts sont à la racine ou dans des sous-dossiers
    "outDir": "./dist", // Où les fichiers .js compilés iront
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true, // Impose la casse correcte des noms de fichiers
    "strict": true,
    "skipLibCheck": true, // Accélère la compilation en ne vérifiant pas les .d.ts des libs
    "resolveJsonModule": true, // Permet d'importer des fichiers .json
    "sourceMap": true, // Génère les sourcemaps pour le débogage
    "allowJs": true,
  },
  "include": ["**/*.ts"],
  "exclude": [
    "node_modules",
    "dist"
  ]
}
// app/services/users/schemas/friendsSchemas.ts
export const friendshipIdParamSchema = {
	params: {
		type: 'object',
		properties: {
			friendshipId: { type: 'integer', minimum: 1 },
		},
		required: ['friendshipId'],
	},
};

export const sendFriendRequestSchema = {
	body: {
		type: 'object',
		properties: {
			receiverUsername: { type: 'string', minLength: 1 },
		},
		required: ['friendId'],
	}
};

export const friendResponseSchema = {
	type: 'object',
	properties: {
		friendship_id: { type: 'integer' },
		friend_id: { type: 'integer' },
		friend_username: { type: 'string' },
		friend_display_name: { type: 'string' },
		friend_avatar_url: { type: 'string', format: 'url', nullable: true },
		friend_online_status: { type: 'string', enum: ['online', 'offline', 'in-game'] },
	},
	required: ['friendship_id', 'friend_id', 'friend_username'],
};
// app/services/users/schemas/userSchemas.ts
export const postUserSchema = {
	body: {
		type: 'object',
		required: ['username', 'email', 'password', 'display_name'],
		properties: {
			username: { type: 'string' },
			email: { type: 'string', format: 'email' },
			password: { type: 'string' },
			display_name: { type: 'string' },
			avatar_url: { type: 'string', nullable: true }
		}
	}
};

export const registerSchema = {
	body: {
		type: 'object',
		required: ['username', 'email', 'password', 'display_name'],
		properties: {
			username: { type: 'string', minLength: 3, maxLength: 20 },
			email: { type: 'string', format: 'email' },
			password: { type: 'string', minLength: 8, maxLength: 100 },
			display_name: { type: 'string', minLength: 3, maxLength: 20 },
			avatar_url: { type: 'string', format: 'url', nullable: true }
		}
	}
};

export const loginSchema = {
	body: {
		type: 'object',
		required: ['identifier', 'password'],
		properties: {
			identifier: { type: 'string' },
			password: { type: 'string' }
		}
	}
};

export const updateUserSchema = {
	body: {
		type: 'object',
		properties: {
			email: { type: 'string', format: 'email' },
			display_name: { type: 'string', minLength: 3, maxLength: 20 },
			avatar_url: { type: 'string', format: 'url', nullable: true },
		},
		minProperties: 1,
		additionalProperties: false
	}
};

export const userResponseSchema = {
    type: 'object',
    properties: {
        id: { type: 'integer' },
        username: { type: 'string' },
        email: { type: 'string', format: 'email' },
        display_name: { type: 'string' },
        avatar_url: { type: 'string', format: 'url', nullable: true },
        wins: { type: 'integer' },
        losses: { type: 'integer' },
        status: { type: 'string', enum: ['online', 'offline', 'in-game'] },
        created_at: { type: 'string', format: 'date-time' },
        updated_at: { type: 'string', format: 'date-time' },
    },
    required: ['id', 'username', 'email', 'display_name', 'created_at', 'updated_at'],
};

export const logoutSchema = {
  description: 'Logout the current user by clearing the JWT cookie',
  tags: ['auth'],
  response: {
    200: {
      type: 'object',
      properties: {
        message: { type: 'string' }
      },
      required: ['message']
    }
  }
};// app/frontend/conf/tailwind.config.js
module.exports = {
    content: [
      './src/**/*.{html,js,ts}',
      './dist/**/*.html',
    ],
    theme: {
      extend: {
        keyframes: {
          'fade-in': {
            '0%': { opacity: '0', transform: 'translateY(10px)', boxShadow: 'none' },
            '100%': { opacity: '1', transform: 'translateY(0)', boxShadow: '0px 4px 20px rgba(0, 0, 0, 0.1)' },
          },
        },
        animation: {
          'fade-in': 'fade-in 0.5s ease-out forwards',
        },
      },
    },
    plugins: [],
  }
  // app/frontend/conf/components/headerComponent.ts
// src/components/headerComponent.ts
import { User } from '../shared/types.js';
import { navigateTo } from '../services/router.js'; // Assuming navigateTo handles data-link
import { logout } from '../services/authService.js';
import { showToast } from './toast.js';

interface HeaderProps {
    currentUser: User;
    // onLanguageChange?: () => void;
}

interface NavLink {
    href: string;
    text: string;
}

export function HeaderComponent(props: HeaderProps): HTMLElement {
    const { currentUser } = props;

    const headerContainer = document.createElement('div');
    headerContainer.className = 'flex justify-between items-center p-4 border-b border-gray-200 bg-white';

    // --- Left side: Language Button ---
    const leftSection = document.createElement('div');
    const langButton = document.createElement('button');
    langButton.className = 'bg-blue-500 text-white font-bold py-2 px-4 rounded-lg text-sm hover:bg-blue-600 transition-colors';
    langButton.textContent = 'ENG';
    // langButton.addEventListener('click', () => { /* ... */ });
    leftSection.appendChild(langButton);

    // --- Center: Navigation Links ---
    const centerSection = document.createElement('div');
    centerSection.className = 'flex-grow flex justify-center space-x-4 sm:space-x-6'; // flex-grow to push others, justify-center

    const navLinks: NavLink[] = [
        { href: '/', text: 'Home' },
        { href: '/game', text: 'Game' },
        { href: '/dashboard', text: 'Dashboard' },
    ];

    navLinks.forEach(linkInfo => {
        const linkElement = document.createElement('a');
        linkElement.href = linkInfo.href;
        linkElement.textContent = linkInfo.text;
        linkElement.className = 'text-gray-600 hover:text-blue-600 font-medium transition-colors px-2 py-1 text-sm sm:text-base';
        linkElement.setAttribute('data-link', '');
        centerSection.appendChild(linkElement);
    });

    // --- Right side: User Header (Avatar & Menu) ---
    const rightSection = document.createElement('div');
    const userHeader = document.createElement('div');
    userHeader.className = 'flex items-center space-x-4 relative';

    const avatarDisplayWrapper = document.createElement('div');
    avatarDisplayWrapper.className = 'bg-orange-400 p-2 rounded-lg flex items-center space-x-3 cursor-pointer select-none';
    
    const displayNameHeader = document.createElement('span');
    displayNameHeader.className = 'text-white font-semibold text-sm';
    displayNameHeader.textContent = currentUser.display_name || currentUser.username;
    
    const avatarHeader = document.createElement('img');
    avatarHeader.className = 'w-10 h-10 rounded-full object-cover border-2 border-white';
    const avatarFallbackName = currentUser.display_name || currentUser.username;
    avatarHeader.src = currentUser.avatar_url || `https://ui-avatars.com/api/?name=${encodeURIComponent(avatarFallbackName)}&background=0D8ABC&color=fff&size=128`;
    avatarHeader.alt = 'User Avatar';

    avatarDisplayWrapper.appendChild(displayNameHeader);
    avatarDisplayWrapper.appendChild(avatarHeader);

    const miniMenu = document.createElement('div');
    miniMenu.className = 'absolute right-0 mt-2 w-40 bg-white rounded-lg shadow-lg border border-gray-200 z-50 hidden flex-col';
    miniMenu.style.top = '110%'; 

    const settingsButton = document.createElement('a');
    settingsButton.href = '/profile';
    settingsButton.setAttribute('data-link', '');
    settingsButton.className = 'block px-4 py-2 text-gray-700 hover:bg-gray-100 rounded-t-lg';
    settingsButton.textContent = 'Settings';

    const logoutButtonEl = document.createElement('button');
    logoutButtonEl.className = 'block w-full text-left px-4 py-2 text-gray-700 hover:bg-gray-100 rounded-b-lg';
    logoutButtonEl.textContent = 'Logout';
    logoutButtonEl.addEventListener('click', async (e) => {
        e.stopPropagation();
        try {
            await logout();
            showToast('You have been logged out.', 'success');
        } catch (error) {
            showToast('Error logging out.', 'error');
        } finally {
            navigateTo('/login');
        }
    });

    miniMenu.appendChild(settingsButton);
    miniMenu.appendChild(logoutButtonEl);
    userHeader.appendChild(avatarDisplayWrapper);
    userHeader.appendChild(miniMenu);
    rightSection.appendChild(userHeader);


    // Menu open/close logic
    let menuOpen = false;
    const toggleMenu = (show: boolean) => {
        menuOpen = show;
        miniMenu.classList.toggle('hidden', !menuOpen);
    };

    avatarDisplayWrapper.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleMenu(!menuOpen);
    });

    const globalClickListener = (event: MouseEvent) => {
        if (menuOpen && !userHeader.contains(event.target as Node)) {
            toggleMenu(false);
        }
    };
    document.addEventListener('click', globalClickListener);
    // Consider cleanup only if this component could be frequently removed/re-added or if multiple such components exist on one page.

    // Assemble the header sections
    headerContainer.appendChild(leftSection);
    headerContainer.appendChild(centerSection);
    headerContainer.appendChild(rightSection);

    return headerContainer;
}// app/frontend/conf/components/userList.ts
import { User as ApiUser, Friend, PendingFriendRequest, FriendRequestUserData } from '../shared/types.js'; // Ajout de FriendRequestUserData si ce n'est pas déjà dans ApiUser

// Définition des props pour UserList
export interface UserListProps {
    users: ApiUser[];
    friends: Friend[];
    sentRequests: PendingFriendRequest[];
    receivedRequests: PendingFriendRequest[];
    currentUserId: number;
    onSendRequest: (targetUserId: number) => Promise<void>;
    onCancelRequest: (friendshipId: number) => Promise<void>;
    onAcceptRequest: (friendshipId: number) => Promise<void>;
    onDeclineRequest: (friendshipId: number) => Promise<void>;
    onRemoveFriend?: (targetUserId: number) => Promise<void>; // Rendu optionnel
}

export function UserList(props: UserListProps): HTMLElement {
    const {
        users,
        friends,
        sentRequests,
        receivedRequests,
        currentUserId,
        onSendRequest,
        onCancelRequest,
        onAcceptRequest,
        onDeclineRequest
    } = props;

    const ul = document.createElement('ul');
    ul.className = 'space-y-4';

    const otherUsers = users.filter(user => user.id !== currentUserId);

    if (otherUsers.length === 0) {
        ul.innerHTML = '<li class="text-center text-gray-500 py-4">Aucun autre utilisateur à afficher.</li>';
        return ul;
    }

    otherUsers.forEach(user => {
        const li = document.createElement('li');
        li.className = 'flex items-center p-4 border border-gray-200 rounded-lg bg-white shadow-sm hover:shadow-md transition-shadow duration-200';
        li.dataset.userId = user.id.toString();

        const avatar = document.createElement('img');
        avatar.className = 'w-12 h-12 rounded-full object-cover mr-4';
        const avatarFallbackName = user.display_name || user.username;
        avatar.src = user.avatar_url || `https://ui-avatars.com/api/?name=${encodeURIComponent(avatarFallbackName)}&background=random&color=fff&size=128`;
        avatar.alt = `${user.username} avatar`;

        const info = document.createElement('div');
        info.className = 'flex-1';

        const topInfo = document.createElement('div');
        topInfo.className = 'flex items-center justify-between mb-1';

        const username = document.createElement('h2');
        username.className = 'text-lg font-semibold text-blue-700';
        username.textContent = user.display_name || user.username;
        
        const displayName = document.createElement('span');
        displayName.className = 'text-gray-500 text-xs ml-2';
        // Afficher le username seulement s'il est différent du display_name ET que display_name existe
        if (user.display_name && user.display_name !== user.username) { 
            displayName.textContent = `(@${user.username})`;
        }


        let onlineStatusIndicator = '';
        const statusProperty = user.status;
        if (statusProperty) {
            const statusColor = statusProperty === 'online' ? 'bg-green-500' : (statusProperty === 'in-game' ? 'bg-yellow-500' : 'bg-gray-400');
            onlineStatusIndicator = `<span class="inline-block w-2.5 h-2.5 ${statusColor} rounded-full mr-2" title="${statusProperty}"></span>`;
        }
        
        const usernameWrapper = document.createElement('div');
        usernameWrapper.className = 'flex items-center';
        usernameWrapper.innerHTML = onlineStatusIndicator;
        usernameWrapper.appendChild(username);
        usernameWrapper.appendChild(displayName);

        topInfo.appendChild(usernameWrapper);

        const email = document.createElement('p');
        email.className = 'text-gray-600 text-xs';
        email.textContent = `📧 ${user.email}`;

        info.appendChild(topInfo);
        info.appendChild(email);

        li.appendChild(avatar);
        li.appendChild(info);

        const actionContainer = document.createElement('div');
        actionContainer.className = 'ml-4 flex flex-col items-end space-y-1 text-sm';

        const friendshipStatus = document.createElement('span');
        friendshipStatus.className = 'text-xs italic text-gray-500 mb-1';

        let actionButton: HTMLButtonElement | null = null;

        const isFriend = friends.some(f => f.friend_id === user.id);
        // CORRECTION ICI: Accéder à .id sur l'objet receiver/requester
        const sentRequestToThisUser = sentRequests.find(r => r.receiver?.id === user.id);
        const receivedRequestFromThisUser = receivedRequests.find(r => r.requester?.id === user.id);

        if (isFriend) {
            friendshipStatus.textContent = 'Ami';
            friendshipStatus.className += ' text-green-600 font-semibold';
            // if (props.onRemoveFriend) { // Vérifier si la prop est fournie
            //     actionButton = createActionButton('Supprimer', 'bg-red-500', () => props.onRemoveFriend!(user.id));
            // }
        } else if (sentRequestToThisUser) {
            friendshipStatus.textContent = 'Demande envoyée';
            friendshipStatus.className += ' text-yellow-600';
            actionButton = createActionButton('Annuler', 'bg-yellow-500 text-black', () => onCancelRequest(sentRequestToThisUser.friendship_id));
        } else if (receivedRequestFromThisUser) {
            friendshipStatus.textContent = 'Demande reçue';
            friendshipStatus.className += ' text-indigo-600';
            const receivedButtonsContainer = document.createElement('div');
            receivedButtonsContainer.className = 'flex space-x-1';
            const acceptBtn = createActionButton('Accepter', 'bg-green-500', () => onAcceptRequest(receivedRequestFromThisUser.friendship_id));
            const declineBtn = createActionButton('Refuser', 'bg-red-500', () => onDeclineRequest(receivedRequestFromThisUser.friendship_id));
            receivedButtonsContainer.appendChild(acceptBtn);
            receivedButtonsContainer.appendChild(declineBtn);
            actionContainer.appendChild(receivedButtonsContainer);
        } else {
            friendshipStatus.textContent = 'Non ami';
            actionButton = createActionButton('Inviter', 'bg-blue-500', () => onSendRequest(user.id));
        }
        
        actionContainer.prepend(friendshipStatus);
        if (actionButton && !actionContainer.querySelector('button')) {
            actionContainer.appendChild(actionButton);
        }
        
        li.appendChild(actionContainer);
        ul.appendChild(li);
    });

    return ul;
}

function createActionButton(text: string, baseClass: string, onClick: () => Promise<void>): HTMLButtonElement {
    const button = document.createElement('button');
    button.textContent = text;
    button.className = `${baseClass} text-white text-xs font-semibold py-1 px-2.5 rounded hover:opacity-80 transition-opacity disabled:opacity-50`;
    button.addEventListener('click', async (e) => {
        e.stopPropagation();
        button.disabled = true;
        const originalText = button.textContent; // originalText est une string ici, pas null
        button.textContent = '...';
        try {
            await onClick();
        } catch (error) {
            // CORRECTION ICI: Vérifier originalText avant .toLowerCase()
            const actionText = originalText || 'action'; // Fournir une valeur par défaut
            console.error(`Error performing action "${actionText}":`, error);
            alert(`Failed to ${actionText.toLowerCase()}.`);
            button.textContent = originalText;
            button.disabled = false;
        }
    });
    return button;
}
// app/frontend/conf/components/friendsList.ts
// /components/friendsList.ts
import { Friend, UserOnlineStatus } from '../shared/types.js';
import { navigateTo } from '../services/router.js';

interface FriendsListProps {
    friends: Friend[];
    onRemoveFriend: (friendshipId: number) => Promise<void>;
}

export function FriendsListComponent(props: FriendsListProps): HTMLElement {
    const { friends, onRemoveFriend } = props;

    const section = document.createElement('div');
    section.id = 'friends-list-section';
    section.className = 'mt-8 p-6 bg-white border border-gray-200 rounded-lg shadow-lg'; // Changed background for better contrast

    const title = document.createElement('h2');
    title.className = 'text-2xl font-semibold text-gray-800 mb-6';
    title.innerHTML = `Mes Amis (<span id="friends-count">${friends.length}</span>)`;

    const ul = document.createElement('ul');
    ul.id = 'friends-list';
    ul.className = 'space-y-4';

    if (!friends.length) {
        ul.innerHTML = `<li class="text-gray-500 italic p-4 text-center">Vous n'avez pas encore d'amis.</li>`;
    } else {
        friends.forEach(friend => {
            const displayName = friend.friend_display_name;
            const avatarUrl = friend.friend_avatar_url;
            const friendId = friend.friend_id;
            const friendshipId = friend.friendship_id;
            const status = friend.friend_online_status;
            const wins = friend.friend_wins ?? 0;
            const losses = friend.friend_losses ?? 0;

            const avatarFallbackName = displayName.charAt(0).toUpperCase();
            const avatar = avatarUrl || `https://ui-avatars.com/api/?name=${encodeURIComponent(displayName)}&background=random&color=fff&size=40`;

            let statusIndicatorClass = 'bg-gray-400';
            let statusText = 'Offline';

            if (status === UserOnlineStatus.ONLINE) {
                statusIndicatorClass = 'bg-green-500';
                statusText = 'Online';
            } else if (status === UserOnlineStatus.IN_GAME) {
                statusIndicatorClass = 'bg-yellow-500';
                statusText = 'In Game';
            }

            const li = document.createElement('li');
            li.dataset.friendId = friendId.toString();
            li.dataset.friendshipId = friendshipId.toString();
            li.className = 'p-4 bg-gray-50 border border-gray-200 rounded-lg shadow-sm flex flex-col sm:flex-row justify-between items-start sm:items-center space-y-3 sm:space-y-0';
            li.innerHTML = `
                <div class="flex items-center w-full sm:w-auto">
                    <img src="${avatar}" alt="${displayName}" class="w-12 h-12 rounded-full mr-4 object-cover">
                    <div class="flex-grow">
                        <div class="flex items-center mb-1">
                            <span class="inline-block w-3 h-3 ${statusIndicatorClass} rounded-full mr-2" title="${statusText}"></span>
                            <strong class="text-lg text-gray-700">${displayName}</strong>
                        </div>
                        <div class="text-xs text-gray-500">
                            <span>Wins: ${wins}</span> | <span>Losses: ${losses}</span>
                        </div>
                    </div>
                </div>
                <div class="flex space-x-2 self-end sm:self-center pt-2 sm:pt-0">
                    <button data-action="view-profile" data-user-id="${friendId}" class="text-xs bg-blue-500 hover:bg-blue-600 text-white font-semibold py-1.5 px-3 rounded-md">Profil</button>
                    <button data-action="remove-friend" data-friendship-id="${friendshipId}" class="text-xs bg-red-500 hover:bg-red-600 text-white font-semibold py-1.5 px-3 rounded-md">Supprimer</button>
                </div>
            `;
            ul.appendChild(li);
        });
    }

    section.appendChild(title);
    section.appendChild(ul);

    ul.addEventListener('click', async (event) => {
        const target = event.target as HTMLElement;
        const button = target.closest('button[data-action]') as HTMLButtonElement | null;
        if (!button) return;

        const action = button.dataset.action;       
        if (action === 'view-profile') {
            const userIdToView = button.dataset.userId; // Get userId from button
            if (userIdToView) {
                navigateTo(`/profile/${userIdToView}`);
            }
        } else if (action === 'remove-friend') {
            const friendshipIdToRemove = button.dataset.friendshipId; // Get friendshipId from button
            if (friendshipIdToRemove && confirm(`Êtes-vous sûr de vouloir supprimer cet ami ?`)) {
                button.disabled = true;
                button.textContent = '...';
                try {
                    await onRemoveFriend(parseInt(friendshipIdToRemove, 10));
                    // button.closest('li')?.remove();
                } catch (error: any) {
                    console.error('Erreur lors de la suppression de l\'ami:', error);
                    alert(`Erreur: ${error.message || 'Impossible de supprimer l\'ami.'}`);
                    button.disabled = false;
                    button.textContent = 'Supprimer';
                }
            }
        }
    });

    return section;
}// app/frontend/conf/components/gamePage.ts
import { getUserDataFromStorage } from '../services/authService.js';
import { navigateTo } from '../services/router.js';
import { handleOnlineGame } from '../services/initOnlineGame.js';
import { User } from '../shared/types.js';

export type GameMode = 'local' | 'remote';

export function GamePage(): HTMLElement {
    
    // --- Main Container ---
    const container: HTMLDivElement = document.createElement('div');
    container.className = 'bg-gradient-to-r from-blue-500 to-purple-600 flex justify-center items-center min-h-screen p-8';
    
    const formContainer: HTMLDivElement = document.createElement('div');
    formContainer.className = 'bg-white bg-opacity-90 backdrop-filter backdrop-blur-lg rounded-xl shadow-2xl p-8 max-w-md w-full';
    
    // --- Title ---
    const title: HTMLHeadElement = document.createElement('h2');
    title.textContent = 'Welcome to the Game';
    title.className = 'text-3xl font-bold mb-6 text-center text-gray-800';
    
    // --- Buttons ---
    const buttonsContainer: HTMLDivElement = document.createElement('div');
    buttonsContainer.id = 'buttons-container';
    buttonsContainer.className = 'flex flex-col items-center';
    
    const localGameButton: HTMLButtonElement = document.createElement('button');
    localGameButton.id = 'local-butto| nulln';
    localGameButton.className = 'bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline w-full mb-4 transition duration-300 ease-in-out';
    localGameButton.textContent = 'Local game';
    
    const onlineGameButton: HTMLButtonElement  = document.createElement('button');
    onlineGameButton.id = 'online-button';
    onlineGameButton.className = 'bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline w-full mb-4 transition duration-300 ease-in-out';
    onlineGameButton.textContent = 'Online game';
    
    // TODO (not finished at all)
    const customSettingsButton: HTMLButtonElement  = document.createElement('button');
    customSettingsButton.id = 'custom-settings-button';
    customSettingsButton.className = 'bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline w-full transition duration-300 ease-in-out';
    customSettingsButton.textContent = 'Custom Settings';
    
    buttonsContainer.append(localGameButton, onlineGameButton, customSettingsButton); 
    
    // --- Le pied du page ---
    const footer: HTMLDivElement = document.createElement('div');
    footer.className = 'mt-6 text-center';
    
    const homeLink: HTMLAnchorElement = document.createElement('a');
    homeLink.href = '/'; // lien vers la page d'accueil
    homeLink.textContent = 'Back to Home';
    homeLink.setAttribute('data-link', ''); // intercepte par le router dans le main.ts
    homeLink.className = 'text-blue-600 hover:text-blue-800 text-sm';
    
    footer.appendChild(homeLink);
    
    // --- Ajout des éléments au conteneur principal ---
    formContainer.append(title, buttonsContainer, footer);
    container.appendChild(formContainer); 
    
    // --- Event: Local button clicked 
    localGameButton.addEventListener('click', async () =>  {
        navigateTo('/local-game'); // la page avec un formulaire a remplir pour le jeu en local
    });
    
    // --- Event: Online button clicked ---
    onlineGameButton.addEventListener('click', async () => { 
        
        // TODO: fetch to /api/user/me to check if registred, ca me donne le type User
        const authData = getUserDataFromStorage();
        if (!authData) {
            alert("You must be logged in to play online");
            return;
        }

        let display_name: string = authData.display_name;

        sessionStorage.setItem('gameMode', 'online');

        await handleOnlineGame(display_name, buttonsContainer, onlineGameButton);
    });

        return container;
}
    // app/frontend/conf/components/friendRequests.ts
// /components/friendRequests.ts
import { PendingFriendRequest } from '../shared/types.js';

interface FriendRequestsProps {
	receivedRequests: PendingFriendRequest[];
	sentRequests: PendingFriendRequest[];
	onAcceptRequest: (friendshipId: number) => Promise<void>;
	onDeclineRequest: (friendshipId: number) => Promise<void>;
	onCancelRequest: (friendshipId: number) => Promise<void>;
}

export function FriendRequestsComponent(props: FriendRequestsProps): HTMLElement {
	const { receivedRequests, sentRequests, onAcceptRequest, onDeclineRequest, onCancelRequest } = props;

	const section = document.createElement('div');
	section.id = 'friend-requests-section';
	section.className = 'mt-8 p-6 bg-indigo-50 border border-indigo-200 rounded-lg shadow-sm';
	section.innerHTML = `
        <h2 class="text-2xl font-semibold text-indigo-800 mb-4">Demandes d'amis</h2>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
                <h3 class="text-xl font-medium text-indigo-700 mb-3">Reçues (<span id="received-requests-count">${receivedRequests.length}</span>)</h3>
                <ul id="received-requests-list" class="space-y-3">
                    ${renderReceivedItems(receivedRequests)}
                </ul>
            </div>
            <div>
                <h3 class="text-xl font-medium text-indigo-700 mb-3">Envoyées (<span id="sent-requests-count">${sentRequests.length}</span>)</h3>
                <ul id="sent-requests-list" class="space-y-3">
                    ${renderSentItems(sentRequests)}
                </ul>
            </div>
        </div>
    `;

	// Gestionnaire d'événements unifié pour les demandes d'amis
	section.addEventListener('click', async (event) => {
		const target = event.target as HTMLElement;
		if (target.tagName !== 'BUTTON' || !target.dataset.action) return;

		const button = target as HTMLButtonElement;
		const listItem = target.closest('li[data-friendship-id]') as HTMLLIElement;
		if (!listItem) return;

		const friendshipId = parseInt(listItem.dataset.friendshipId || '', 10);
		if (isNaN(friendshipId)) return;

		const action = target.dataset.action;
		button.disabled = true;
		button.textContent = '...';

		try {
			let message = '';
			if (action === 'accept') {
				await onAcceptRequest(friendshipId);
			} else if (action === 'decline') {
				await onDeclineRequest(friendshipId);
			} else if (action === 'cancel') {
				await onCancelRequest(friendshipId);
			}
		} catch (error: any) {
			console.error(`Erreur lors de l'action '${action}':`, error);
			alert(`Erreur: ${error.message || 'Une erreur est survenue.'}`);
			button.disabled = false; // Restaurer le bouton en cas d'erreur
			button.textContent = action.charAt(0).toUpperCase() + action.slice(1); // Restaurer le texte original
		}
	});

	return section;
}

// Fonctions utilitaires de rendu (pourrait être dans le composant ou séparées)
function renderReceivedItems(requests: PendingFriendRequest[]): string {
	if (!requests.length) {
		return `<li class="text-gray-500 italic">Aucune demande reçue.</li>`;
	}
	return requests.map(req => `
        <li data-friendship-id="${req.friendship_id}" class="p-3 bg-white border border-gray-200 rounded-md shadow-sm flex justify-between items-center">
            <div>
                <strong class="text-indigo-600">${req.requester?.display_name || req.requester?.username}</strong>
                <span class="text-xs text-gray-500 block">(${req.requester?.username})</span>
            </div>
            <div>
                <button data-action="accept" class="text-xs bg-green-500 hover:bg-green-600 text-white font-semibold py-1 px-2 rounded mr-1">Accepter</button>
                <button data-action="decline" class="text-xs bg-red-500 hover:bg-red-600 text-white font-semibold py-1 px-2 rounded">Refuser</button>
            </div>
        </li>
    `).join('');
}

function renderSentItems(requests: PendingFriendRequest[]): string {
	if (!requests.length) {
		return `<li class="text-gray-500 italic">Aucune demande envoyée.</li>`;
	}
	return requests.map(req => `
        <li data-friendship-id="${req.friendship_id}" class="p-3 bg-white border border-gray-200 rounded-md shadow-sm flex justify-between items-center">
             <div>
                <strong class="text-indigo-600">${req.receiver?.display_name || req.receiver?.username}</strong>
                 <span class="text-xs text-gray-500 block">(${req.receiver?.username})</span>
            </div>
            <button data-action="cancel" class="text-xs bg-yellow-500 hover:bg-yellow-600 text-black font-semibold py-1 px-2 rounded">Annuler</button>
        </li>
    `).join('');
}// app/frontend/conf/components/profileForm.ts
// /components/profileForm.ts
import { User, UpdateUserPayload, ApiResult } from '../shared/types.js'; // S'assurer que ApiResult est importé

interface ProfileFormProps {
	user: User;
	onProfileUpdate: (payload: UpdateUserPayload) => Promise<ApiResult>;
}

export function ProfileForm(props: ProfileFormProps): HTMLElement {
	const { user, onProfileUpdate } = props;

	const formElement = document.createElement('form');
	formElement.id = 'profile-form-component'; // ID unique
	formElement.innerHTML = `
        <!-- Message d'état -->
        <div id="profile-message" class="mb-4 text-center text-sm min-h-[1.25rem]"></div>

        <!-- Champ Username (souvent non modifiable) -->
        <div class="mb-4">
            <label for="username" class="block text-gray-700 text-sm font-bold mb-2">Nom d'utilisateur</label>
            <input type="text" id="username" name="username" readonly
                   value="${user.username}"
                   class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 bg-gray-200 cursor-not-allowed leading-tight focus:outline-none focus:shadow-outline">
            <p class="text-xs text-gray-500 mt-1">Le nom d'utilisateur ne peut pas être modifié.</p>
        </div>

        <!-- Champ Email -->
        <div class="mb-4">
            <label for="email" class="block text-gray-700 text-sm font-bold mb-2">Adresse Email</label>
            <input type="email" id="email" name="email" required
                   value="${user.email || ''}"
                   placeholder="Votre adresse email"
                   class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
        </div>

        <!-- Champ Display Name -->
        <div class="mb-4">
            <label for="display_name" class="block text-gray-700 text-sm font-bold mb-2">Nom Affiché</label>
            <input type="text" id="display_name" name="display_name" required
                   value="${user.display_name || ''}"
                   placeholder="Comment voulez-vous être appelé ?"
                   class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
        </div>

        <!-- Champ Avatar URL (Optionnel) -->
        <div class="mb-6">
            <label for="avatar_url" class="block text-gray-700 text-sm font-bold mb-2">URL de l'Avatar (Optionnel)</label>
            <input type="url" id="avatar_url" name="avatar_url"
                   value="${user.avatar_url || ''}"
                   placeholder="https://example.com/avatar.png"
                   class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
             <p class="text-xs text-gray-500 mt-1">Laissez vide si vous n'avez pas d'avatar.</p>
        </div>

        <div class="flex items-center justify-between mt-6 border-t pt-6">
            <button type="submit" id="save-profile-button"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline w-full sm:w-auto transition duration-300 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
                Enregistrer les modifications
            </button>
            <!-- Le lien de retour est mieux géré par la page parente -->
        </div>
    `;

	const emailInput = formElement.querySelector('#email') as HTMLInputElement;
	const displayNameInput = formElement.querySelector('#display_name') as HTMLInputElement;
	const avatarUrlInput = formElement.querySelector('#avatar_url') as HTMLInputElement;
	const messageDiv = formElement.querySelector('#profile-message') as HTMLDivElement;
	const saveButton = formElement.querySelector('#save-profile-button') as HTMLButtonElement;

	formElement.addEventListener('submit', async (event) => {
		event.preventDefault();
		messageDiv.textContent = 'Sauvegarde en cours...';
		messageDiv.className = 'mb-4 text-center text-sm text-gray-600 min-h-[1.25rem]';
		saveButton.disabled = true;
		saveButton.textContent = 'Sauvegarde...';

		const updatedEmail = emailInput.value.trim();
		const updatedDisplayName = displayNameInput.value.trim();
		const updatedAvatarUrl = avatarUrlInput.value.trim();

		if (!updatedEmail || !updatedDisplayName) {
			messageDiv.textContent = 'Veuillez remplir les champs Email et Nom affiché.';
			messageDiv.className = 'mb-4 text-center text-sm text-red-600 font-semibold min-h-[1.25rem]';
			saveButton.disabled = false;
			saveButton.textContent = 'Enregistrer les modifications';
			return;
		}

		const payload: UpdateUserPayload = {
			email: updatedEmail,
			display_name: updatedDisplayName,
			avatar_url: updatedAvatarUrl,
		};

		const result = await onProfileUpdate(payload);

		saveButton.disabled = false;
		saveButton.textContent = 'Enregistrer les modifications';

		if (result.success) {
			messageDiv.textContent = 'Profil mis à jour avec succès !';
			messageDiv.className = 'mb-4 text-center text-sm text-green-600 font-semibold min-h-[1.25rem]';

			// Mettre à jour les valeurs des champs avec les données retournées par l'API
			// Cela est important si le backend effectue une sanitisation ou une transformation
			emailInput.value = result.data.user.email;
			displayNameInput.value = result.data.user.display_name;
			avatarUrlInput.value = result.data.user.avatar_url || '';

			setTimeout(() => {
				if (messageDiv.textContent === 'Profil mis à jour avec succès !') {
					messageDiv.textContent = ''; // Effacer le message de succès
				}
			}, 3000);
		} else {
			messageDiv.textContent = `Erreur: ${result.error || 'Une erreur inconnue est survenue.'}`;
			messageDiv.className = 'mb-4 text-center text-sm text-red-600 font-semibold min-h-[1.25rem]';
		}
	});

	return formElement;
}// app/frontend/conf/components/aliasFormPage.ts
import { navigateTo } from "../services/router.js";
import { initLocalGame } from "../services/initLocalGame.js";

export function promptAliasForm(): HTMLDivElement {

    // --- Main Container ---
    const container: HTMLDivElement = document.createElement('div');
    container.className = 'bg-gradient-to-r from-blue-500 to-purple-600 flex justify-center items-center min-h-screen p-8';

    const formContainer: HTMLDivElement = document.createElement('div');
    formContainer.className = 'bg-white bg-opacity-90 backdrop-filter backdrop-blur-lg rounded-xl shadow-2xl p-8 max-w-md w-full';

    // --- Title ---
    const title: HTMLHeadingElement = document.createElement('h2');
    title.textContent = 'Select Game Mode';
    title.className = 'text-3xl font-bold mb-6 text-center text-gray-800';

    // --- Input form ---
    const form: HTMLFormElement = document.createElement('form');
    form.className = 'space-y-6';

    const gameModeField = createSelectField('gameMode', 'Game Mode', ['1v1', 'Tournament', 'Battle Royale']);
    const dynamicInputs = document.createElement('div');

    // --- Buttons ---
    const buttonsContainer: HTMLDivElement = document.createElement('div');
    buttonsContainer.id = 'buttons-container';
    buttonsContainer.className = 'flex justify-end space-x-4';

    const cancelButton: HTMLButtonElement = document.createElement('button');
    cancelButton.type = 'button';
    cancelButton.id = 'cancel-button';
    cancelButton.textContent = 'Cancel';
    cancelButton.className = 'bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 px-4 rounded transition duration-200';

    const submitButton: HTMLButtonElement = document.createElement('button');
    submitButton.id = 'submit-button';
    submitButton.textContent = 'Start';
    submitButton.className = 'bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition duration-200';

    buttonsContainer.append(cancelButton, submitButton);
    
    // --- Le pied de page ---
    const footer: HTMLDivElement = document.createElement('div');
    footer.className = 'mt-6 text-center';

    const homeLink: HTMLAnchorElement = document.createElement('a');
    homeLink.href = '/'; // lien vers la page d'accueil
    homeLink.textContent = 'Back to Home';
    homeLink.setAttribute('data-link', ''); // intercepte par le router dans le main.ts
    homeLink.className = 'text-blue-600 hover:text-blue-800 text-sm';

    // --- Ajout des éléments au conteneur principal ---
    footer.appendChild(homeLink);
    form.append(gameModeField, dynamicInputs, buttonsContainer);
    formContainer.append(title, form, footer);
    container.appendChild(formContainer);

    // --- Event: Cancel button clicked
    cancelButton.addEventListener('click', async () => {
        // need to abort the fetch ?
        navigateTo('/game');
    });
    
    // --- Input depends on gameMode
    const selectElement: HTMLSelectElement = (gameModeField.querySelector('select') as HTMLSelectElement);
    selectElement.addEventListener('change', (e) => {
        const value = (e.target as HTMLSelectElement).value;
        dynamicInputs.innerHTML = ''; // reset a chaque changement

        if (value === '1v1') {
            dynamicInputs.append(
                createInputField('alias1', 'Player1'),
                createInputField('alias2', 'Player2')
            );
        } else if (value === 'Tournament' || value === 'Battle Royale') {
            const countField = createInputField('playerCount', 'How many players?');
            const inputElement = countField.querySelector('input') as HTMLInputElement;
            inputElement.placeholder = 'Enter a number between 3 and 10';
            
            dynamicInputs.append(countField);

            // generate as many inputs as recieved in countField
            const aliasFields = document.createElement('div');
            dynamicInputs.append(aliasFields);

            inputElement.type = 'number';
            inputElement.min = '3';
            inputElement.max = '10';

            inputElement.addEventListener('input', () => {
                aliasFields.innerHTML = ''; // reset a chaque changement
                const count: number = parseInt(inputElement.value);
                if (isNaN(count) || count < 3 || count > 10) return;

                for (let i = 1; i <= count; i++) {
                    const field = createInputField(`alias${i}`, `Player ${i}`);
                    field.classList.add('animate-fade-in');
                    aliasFields.appendChild(field);
                }
            });
        }
    });

    // diffuser l'event 'change'
    selectElement.dispatchEvent(new Event('change'));

    // --- Event: Submit form event triggered
    form.addEventListener('submit', async (event) => {
        event.preventDefault(); // prevents the page from refreshing
        await initLocalGame(form);
    });
    
    return container;
}


// -- Helper function for input
function createInputField(id: string, labelText: string): HTMLDivElement {
    const fieldDiv = document.createElement('div');

    const label = document.createElement('label');
    label.htmlFor = id;
    label.textContent = labelText;
    label.className = 'block text-sm font-medium text-gray-700 mb-1';

    const input = document.createElement('input');
    input.type = 'text';
    input.id = id;
    input.required = true;
    input.className = 'w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500';

    fieldDiv.append(label, input);
    
    return fieldDiv;
}

// --- Helper function for game mode (menu delurant avec 3 options)
function createSelectField(id: string, labelText: string, options: string[]): HTMLDivElement {
    const fieldDiv = document.createElement('div');

    const label = document.createElement('label');
    label.htmlFor = id;
    label.textContent = labelText;
    label.className = 'block text-sm font-medium text-gray-700 mb-1';

    const select = document.createElement('select');
    select.id = id;
    select.required = true;
    select.className = 'w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500';

    for (const optionValue of options) {
        const option = document.createElement('option');
        option.value = optionValue;
        option.textContent = optionValue;
        select.appendChild(option);
    }

    fieldDiv.append(label, select);
    return fieldDiv;
}
// app/frontend/conf/components/loginForm.ts
// /components/loginForm.ts
import { LoginRequestBody, ApiResult } from '../shared/types.js';

interface LoginFormProps {
	onLoginAttempt: (credentials: LoginRequestBody) => Promise<ApiResult>;
	onLoginSuccess: (userData: any) => void; // Callback pour informer la page du succès
}

export function LoginForm(props: LoginFormProps): HTMLElement {
	const { onLoginAttempt, onLoginSuccess } = props;

	const formWrapper = document.createElement('div');
	// Pas besoin de classes spécifiques ici si elles sont déjà sur formContainer dans la page

	formWrapper.innerHTML = `
        <form id="login-form-component"> <!-- ID unique pour ce composant -->
            <div class="mb-4">
                <label for="identifier" class="block text-gray-700 text-sm font-bold mb-2">Username or Email</label>
                <input type="text" id="identifier" name="identifier" required placeholder="Enter your username or email"
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
            </div>
            <div class="mb-6">
                <label for="password" class="block text-gray-700 text-sm font-bold mb-2">Password</label>
                <input type="password" id="password" name="password" required
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:shadow-outline">
            </div>
            <div class="flex items-center justify-between">
                <button type="submit" id="login-button"
                        class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline w-full transition duration-300 ease-in-out">
                    Sign In
                </button>
            </div>
        </form>
        <div id="login-message-component" class="mt-4 text-center text-sm"></div>
    `;

	const form = formWrapper.querySelector('#login-form-component') as HTMLFormElement;
	const identifierInput = formWrapper.querySelector('#identifier') as HTMLInputElement;
	const passwordInput = formWrapper.querySelector('#password') as HTMLInputElement;
	const messageDiv = formWrapper.querySelector('#login-message-component') as HTMLDivElement;
	const loginButton = formWrapper.querySelector('#login-button') as HTMLButtonElement;

	form.addEventListener('submit', async (event) => {
		event.preventDefault();
		messageDiv.textContent = 'Attempting login...';
		messageDiv.className = 'mt-4 text-center text-sm text-gray-600';
		loginButton.disabled = true;
		loginButton.textContent = 'Signing In...';

		const identifier = identifierInput.value.trim();
		const password = passwordInput.value;

		if (!identifier || !password) {
			messageDiv.textContent = 'Please enter both username/email and password.';
			messageDiv.className = 'mt-4 text-center text-sm text-red-600';
			loginButton.disabled = false;
			loginButton.textContent = 'Sign In';
			return;
		}

		const result = await onLoginAttempt({ identifier, password });

		loginButton.disabled = false;
		loginButton.textContent = 'Sign In';

		if (result.success) {
			messageDiv.textContent = `Login successful! Welcome ${result.data.user.display_name || result.data.user.username}!`;
			messageDiv.className = 'mt-4 text-center text-sm text-green-600';
			onLoginSuccess(result.data.user); // Appeler le callback de succès
		} else {
			messageDiv.textContent = result.error || 'Login failed. Please try again.';
			messageDiv.className = 'mt-4 text-center text-sm text-red-600';
			passwordInput.value = ''; // Vider le mot de passe en cas d'échec
		}
	});

	return formWrapper;
}
// app/frontend/conf/components/toast.ts
export function showToast(message: string, type: 'success' | 'error' = 'success') {
    let toast = document.createElement('div');
    toast.textContent = message;
    toast.className = `fixed top-6 left-6 z-50 px-6 py-3 rounded-lg shadow-lg text-white font-semibold transition-all
        ${type === 'success' ? 'bg-green-600' : 'bg-red-600'}`;
    toast.style.opacity = '0';
    toast.style.pointerEvents = 'none';
    document.body.appendChild(toast);
    setTimeout(() => { toast.style.opacity = '1'; }, 10);
    setTimeout(() => {
        toast.style.opacity = '0';
        setTimeout(() => toast.remove(), 400);
    }, 3000);
}// app/frontend/conf/components/homePage.ts
export function HomePage(): HTMLElement {
	const container = document.createElement('div');
	container.className = 'bg-gradient-to-r from-blue-500 to-purple-600 flex flex-col justify-center items-center min-h-screen text-white p-8'; // Styles du body/conteneur principal

	const innerDiv = document.createElement('div');
	innerDiv.className = 'text-center bg-grey-300 bg-opacity-20 backdrop-filter backdrop-blur-lg rounded-xl shadow-2xl p-8 container mx-auto'; // Styles de la div interne

	innerDiv.innerHTML = `
        <h1 class="text-5xl font-bold mb-8 drop-shadow-lg">
          Welcome to Ping-Pong! 🏓
        </h1>
        <p class="text-xl mb-10 drop-shadow-md">
          The ultimate online Pong experience. Ready to play?
        </p>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <a href="/users" data-link class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition duration-300 ease-in-out transform hover:scale-105">
            View User List
          </a>
          <a href="/login" data-link class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition duration-300 ease-in-out transform hover:scale-105">
            Login
          </a>
          <a href="/register" data-link class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition duration-300 ease-in-out transform hover:scale-105">
            Register
          </a>
          <a href="/game" data-link class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition duration-300 ease-in-out transform hover:scale-105">
            Check Game API
          </a>
        </div>
    `;
	container.appendChild(innerDiv);
	return container;
}
// app/frontend/conf/components/registerPage.ts
import { attemptRegister } from '../services/authService.js';
import { RegisterRequestBody, ApiResult } from '../shared/types.js'
import { fetchCsrfToken } from '../services/csrf.js';
import { navigateTo } from '../services/router.js';

export async function RegisterPage(): Promise<HTMLElement> {

	
	const container = document.createElement('div');
	container.className = 'bg-gradient-to-r from-blue-500 to-purple-600 flex justify-center items-center min-h-screen p-8';

	const formContainer = document.createElement('div');
	formContainer.className = 'bg-white bg-opacity-90 backdrop-filter backdrop-blur-lg rounded-xl shadow-2xl p-8 max-w-md w-full';

	formContainer.innerHTML = `
        <h2 class="text-3xl font-bold mb-6 text-center text-gray-800">Register</h2>
        <form id="register-form">
            <div class="mb-4">
                <label for="username" class="block text-gray-700 text-sm font-bold mb-2">Username</label>
                <input type="text" id="username" name="username" required minlength="3" maxlength="20"
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                <p class="text-xs text-gray-600 mt-1">3 to 20 characters.</p>
            </div>
            <div class="mb-4">
                <label for="email" class="block text-gray-700 text-sm font-bold mb-2">Email</label>
                <input type="email" id="email" name="email" required
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
            </div>
             <div class="mb-4">
                <label for="display_name" class="block text-gray-700 text-sm font-bold mb-2">Display Name</label>
                <input type="text" id="display_name" name="display_name" required minlength="3" maxlength="20"
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                <p class="text-xs text-gray-600 mt-1">3 to 20 characters.</p>
            </div>
            <div class="mb-4">
                <label for="password" class="block text-gray-700 text-sm font-bold mb-2">Password</label>
                <input type="password" id="password" name="password" required minlength="8" maxlength="100"
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                 <p class="text-xs text-gray-600 mt-1">8 to 100 characters.</p>
            </div>
             <div class="mb-6">
                <label for="confirm_password" class="block text-gray-700 text-sm font-bold mb-2">Confirm Password</label>
                <input type="password" id="confirm_password" name="confirm_password" required minlength="8" maxlength="100"
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:shadow-outline">
            </div>
            <div class="mb-6">
                <label for="avatar_url" class="block text-gray-700 text-sm font-bold mb-2">Avatar URL (Optional)</label>
                <input type="url" id="avatar_url" name="avatar_url" placeholder="https://example.com/avatar.jpg"
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
            </div>
            <div class="flex items-center justify-between">
                <button type="submit" id="register-button"
                        class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline w-full transition duration-300 ease-in-out">
                    Register
                </button>
            </div>
        </form>
        <div id="register-message" class="mt-4 text-center text-sm"></div>
        <div class="mt-6 text-center">
          <a href="/" data-link class="text-blue-600 hover:text-blue-800 text-sm">
            Back to Home
          </a>
          <span class="mx-2 text-gray-400">|</span>
          <a href="/login" data-link class="text-blue-600 hover:text-blue-800 text-sm">
            Already have an account? Login
          </a>
        </div>
    `;

	container.appendChild(formContainer);

	// --- Logique du formulaire d'inscription ---
	const form = container.querySelector('#register-form') as HTMLFormElement;
	const usernameInput = container.querySelector('#username') as HTMLInputElement;
	const emailInput = container.querySelector('#email') as HTMLInputElement;
	const displayNameInput = container.querySelector('#display_name') as HTMLInputElement;
	const passwordInput = container.querySelector('#password') as HTMLInputElement;
	const confirmPasswordInput = container.querySelector('#confirm_password') as HTMLInputElement;
	const avatarUrlInput = container.querySelector('#avatar_url') as HTMLInputElement;
	const messageDiv = container.querySelector('#register-message') as HTMLDivElement;
	const registerButton = container.querySelector('#register-button') as HTMLButtonElement;

	form.addEventListener('submit', async (event) => {
		event.preventDefault();
		messageDiv.textContent = ''; // Clear previous messages
		messageDiv.className = 'mt-4 text-center text-sm'; // Reset style

		const username = usernameInput.value.trim();
		const email = emailInput.value.trim();
		const displayName = displayNameInput.value.trim();
		const password = passwordInput.value; // No trim on password
		const confirmPassword = confirmPasswordInput.value;
		const avatarUrl = avatarUrlInput.value.trim();
		
		// --- Validation des champs ---
		if (!username || !email || !displayName || !password || !confirmPassword) {
			messageDiv.textContent = 'Please fill in all required fields.';
			messageDiv.className = 'mt-4 text-center text-sm text-red-600';
			return;
		}
		if (password !== confirmPassword) {
			messageDiv.textContent = 'Passwords do not match.';
			messageDiv.className = 'mt-4 text-center text-sm text-red-600';
			passwordInput.value = ''; // Clear passwords
			confirmPasswordInput.value = '';
			return;
		}
		if (password.length < 8) {
			messageDiv.textContent = 'Password must be at least 8 characters long.';
			messageDiv.className = 'mt-4 text-center text-sm text-red-600';
			return;
		}
		// Simple check for avatar URL format if provided
		if (avatarUrl && !isValidHttpUrl(avatarUrl)) {
			messageDiv.textContent = 'Avatar URL must be a valid HTTP/HTTPS URL.';
			messageDiv.className = 'mt-4 text-center text-sm text-red-600';
			return;
		}

		// --- Appel à l'API ---
		messageDiv.textContent = 'Attempting registration...';
		messageDiv.className = 'mt-4 text-center text-sm text-gray-600';
		registerButton.disabled = true;
		registerButton.textContent = 'Registering...';

		const credentials: RegisterRequestBody = {
			username,
			email,
			password,
			display_name: displayName,
		};
		// Only add avatar_url if it's not empty
		if (avatarUrl) {
			credentials.avatar_url = avatarUrl;
		}

		const registrationResult: ApiResult = await attemptRegister(credentials);

		registerButton.disabled = false; // Re-enable button
		registerButton.textContent = 'Register';

		if (registrationResult.success) {
			messageDiv.textContent = `Registration successful for ${username}! Redirecting to login...`;
			messageDiv.className = 'mt-4 text-center text-sm text-green-600';
			form.reset(); // Clear the form fields
			setTimeout(() => { navigateTo('/login'); }, 500);

		} else {
			messageDiv.textContent = 'Registration failed. Please check the details and try again.'; // Message générique post-alert
			messageDiv.className = 'mt-4 text-center text-sm text-red-600';
			passwordInput.value = ''; // Clear password fields on failure
			confirmPasswordInput.value = '';
		}
	});

	return container;
}

// Helper function for basic URL validation
function isValidHttpUrl(string: string): boolean {
	let url;
	try {
		url = new URL(string);
	} catch (_) {
		return false;
	}
	return url.protocol === "http:" || url.protocol === "https:";
}
// app/frontend/conf/style/input.css
@import 'tailwindcss';
// app/frontend/conf/services/csrf.ts
export let csrfToken: string | null = null;

export function setCsrfToken(token: string) {
	csrfToken = token;
	localStorage.setItem('csrfToken', token);
}

export function getCsrfTokenOrThrow(): string {
	if (!csrfToken) {
		csrfToken = localStorage.getItem('csrfToken');
	}
	if (!csrfToken) throw new Error('CSRF token missing. Please refresh the page.');
	return csrfToken;
}

export async function fetchWithCsrf(url: string, options: RequestInit = {}): Promise<Response> {
	const token = getCsrfTokenOrThrow();
	const headers = new Headers(options.headers || {});
	headers.set('x-csrf-token', token);
	return fetch(url, {
		...options,
		headers,
		credentials: 'include',
	});
}

export async function fetchCsrfToken() {
	try {
		const response = await fetch('/api/users/csrf-token', { credentials: 'include' });
		if (!response.ok) throw new Error('Failed to fetch CSRF token');
		const data = await response.json();
		csrfToken = data.csrfToken;
		console.log('CSRF Token fetched and stored:', csrfToken);
	} catch (error) {
		console.error('Error fetching CSRF token:', error);
	}
}
// app/frontend/conf/services/initOnlineGame.ts
import { UUID } from "crypto";
import { navigateTo } from "./router.js";
import socket from "./socket.js";

// --- Main Fonction for online game: 
// post /api/game/match + socket initialisaztion + waiting room + 
// matchmaking + then navigaTo(/game-room)
export async function handleOnlineGame(display_name: string, container: HTMLElement, button: HTMLButtonElement): Promise<void> {
    button.disabled = true; // pour eviter les multiples click (data race)
    try {
        await initOnlineGame(display_name, container);
    } catch (err: unknown) {
        console.log(err);
        alert('Error creating waiting room. Please try again.');
        navigateTo('/game'); // !! maybe redirect to error page instead of alert()
    } finally {
        button.disabled = false;
    }
}

// --- Fonction pour initialiser le client socket et le mettre dans le waiting room ---
export async function initOnlineGame(display_name: string, buttonsContainer: HTMLElement) {
    const controller: AbortController = new AbortController();

    if (!socket.connected) {
        socket.connect();
    }
    
    socket.on('connect', () => {
        console.log('Connected to the server');
        socket.emit('authenticate', display_name);
        showWaitingMessage(buttonsContainer, socket, controller);
    });
    
    // --- Socket listener on matchFound event --> if opponenet is found
    socket.on('matchFound', ({ matchId, displayName, side, opponent }: { matchId: UUID; displayName: string, side: 'left' | 'right'; opponent: string}) => {

        // FOR DEBUGGING
        console.log(matchId);
        console.log(side);
        console.log(opponent);
        // -------------------
        
        sessionStorage.setItem('matchId', matchId);
        sessionStorage.setItem('displayName', displayName);
        sessionStorage.setItem('side', side);
        sessionStorage.setItem('opponent', opponent);

        // socket.emit('startOnlineGame', matchId); je suis pas sure qu'on a besoin de cet emit: a voir ?
        navigateTo(`/game-room?matchId=${matchId}`);

    });
    
    // --- Socket listeners on errors from the server side
    socket.on('disconnect', (reason: string, details?: any) => { 
        console.log(`Disconnected from the server: reason ${reason},
            details: ${details.message}, ${details.description}, ${details.context}`);
    });
    
    socket.on('error', (err: Error) => {
        console.error('Socket error:', err);
    });

    socket.on('connect_error', (err: Error) => {
        console.error(`Connection to the server is failed: ${err.message}`);
        alert('Failed to connect to server.');
        cleanupSocket(socket);
      });

    // --- TODO: emit on server side ---
    socket.on('matchTimeout', () => {
        alert('No opponent found. Please try again later.');
        cleanupSocket(socket);
        navigateTo('/game');
    });

}

// --- Fonction pour afficher le message d'attente + Cancel button ---
export function showWaitingMessage(buttonsContainer: HTMLElement, socket: SocketIOClient.Socket, controller: AbortController) {
    buttonsContainer.innerHTML = ''; // clear the buttons
    
    const waitingMessage = document.createElement('div');
    waitingMessage.textContent = 'Waiting for an opponent...';
    waitingMessage.className = 'text-gray-700 font-semibold text-lg animate-pulse';
    
    const cancelButton = document.createElement('button');
    cancelButton.textContent = 'Cancel';
    cancelButton.className = 'bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline w-full transition duration-300 ease-in-out';

    cancelButton.addEventListener('click', () => {
        controller.abort(); // abort the fetch request
        socket.emit('cancelMatch'); // inform the server that client
                                    //  is going to leave a waiting room
        cleanupSocket(socket);
        navigateTo('/game');
    });

    buttonsContainer.append(waitingMessage, cancelButton);
}

// // --- Fonction pour créer une salle d'attente ---
// export async function createOnlineMatch(token: string, opponentId: string, display_name: string, signal: AbortSignal): Promise<string | null> {
//     try {
//         const requestBody = {
//             player1: display_name,
//             player2: opponentId,
//             isLocal: false,
//         }

//         console.log("Request Body:", requestBody);
//         const response = await fetch('/api/game/match', {
//             method: 'POST',
//             headers: {
//                 'Authorization': `Bearer ${token}`,
//                 'Content-Type': 'application/json',
//             },
//             body: JSON.stringify({
//                 player1: display_name,
//                 player2: opponentId,
//                 isLocal: false,
//             }),
//             signal: signal,
//           //  cache: 'default',
//         });
        
//         if (!response.ok) { // la reponse echouee (true if (res > 200 && res < 299))
//             throw new Error(`Failed to create online match: ${await response.text}`);
//         };
      
//         const data = await response.json();  
//         const matchId = data.matchId;

//         return matchId;
//     } catch (err: unknown) {
//         if (err instanceof DOMException && err.name === 'AbortError'){
//             console.log('Fetch aborted by user');
//         } else {
//             alert('Error creating online match');
//             console.log(err);
//         }
//         return null;
//     }
// }


// --- Helper to cleanup Socket connexion ---
export function cleanupSocket(socket: SocketIOClient.Socket) {
    socket.removeAllListeners();
    socket.disconnect();
}// app/frontend/conf/services/socket.ts
import { Socket } from "socket.io-client"

const socket: typeof Socket = io('http://localhost:3001', {
    transports: ['websocket'],
    autoConnect: false,
});

export default socket;// app/frontend/conf/services/initLocalGame.ts
import { navigateTo } from "./router.js";

export async function initLocalGame(form: HTMLFormElement) {
    const gameMode = form.querySelector<HTMLSelectElement>('#gameMode');
    if (!gameMode) { // optional check ?
        alert('Please select a game mode.');
        return;
    }
    switch (gameMode.value) {
        case '1v1':
            const isValidAlias = (alias: string) => /^[a-zA-Z0-9_-]+$/.test(alias);
            const alias1 = form.querySelector<HTMLInputElement>('#alias1')?.value.trim();
            const alias2 = form.querySelector<HTMLInputElement>('#alias2')?.value.trim();
            
            if (!alias1 || !alias2 ) {
                alert('Please enter aliases for both players.');
                return;
            }
            // sanitaze check (maybe not necessery on client side ?)
            if (!isValidAlias(alias1) || !isValidAlias(alias2)) {
                alert('Aliases can only contain letters, numbers, dashes, and underscores.');
                return;
            }
            if (alias1 === alias2) {
                alert('Aliases should be unique');
                return;
            }
            
            await createLocalMatch(alias1, alias2);
            break;
        case 'Tournament':
        case 'Battle Royale':
        default:
            alert('Unknown game mode selected');
    }
}

// --- Helper function to call an API
async function createLocalMatch(alias1: string, alias2: string) {
    try {
        const response = await fetch('/api/game/match/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                player1: alias1,
                player2: alias2,
                isLocal: true,
            }),
        });
        
        if (!response.ok) {
            throw new Error(`Failed to create local match: ${await response.text}`);
        }
        
        const data = await response.json();
        const matchId = data.matchId;

        if (!matchId) {
            throw new Error('Missing match ID from server.')
        }
        // ! sessionStorage store all data locally 
        // + not erased after page refresh (but after closing the tab)
        sessionStorage.setItem('player1', data.player1);
        sessionStorage.setItem('player2', data.player2);
        sessionStorage.setItem('gameMode', 'local');

        navigateTo(`/game-room?matchId=${matchId}`);

    } catch (err: unknown) {
        alert('Error creating local match');
        console.log(err);
    }
}
// app/frontend/conf/services/router.ts
import { router } from '../main.js';

export function navigateTo(url: string) {
	window.history.pushState({}, '', url);	// Met à jour l'URL dans la barre d'adresse sans recharger
	router();
}
// app/frontend/conf/services/api.ts
import { User } from "../shared/types.js";

export async function fetchUsers(): Promise<User[]> {
	try {
		const response = await fetch('/api/users/'); // NGINX ADDRESS
		if (!response.ok) {
			console.error(`HTTP error! status: ${response.status}`);
			return [];
		}
		const users = await response.json() as User[];
		return users;
	} catch (error) {
		console.error("Failed to fetch users:", error);
		return [];
	}
}
// app/frontend/conf/services/friendService.ts
import { fetchWithCsrf, setCsrfToken, getCsrfTokenOrThrow, csrfToken } from './csrf.js';
import { ApiErrorResponse, Friend, PendingFriendRequest } from '../shared/types.js';
/**
 * Handles API responses by checking for errors and parsing the response JSON.
 * @param response The HTTP response object.
 * @returns The parsed JSON data if the response is successful.
 * @throws An error if the response is not successful.
 */
const handleApiResponse = async (response: Response) => {
	if (!response.ok) {
		let errorData: ApiErrorResponse = { error: `Server error (${response.status})` };
		try {
			errorData = await response.json();
		} catch (jsonError) {
			console.error("Unable to parse JSON error response:", jsonError);
		}
		throw new Error(errorData.error || response.statusText);
	}
	return response.json();
};

/**
 * Retrieves the friend requests received by the logged-in user.
 * @returns A list of pending friend requests.
 */
export async function getReceivedFriendRequests(): Promise<PendingFriendRequest[]> {
	const response = await fetch('/api/users/friends/requests/received', {
		method: 'GET',
		headers: { 'Content-Type': 'application/json' },
		credentials: 'include',
	});
	return handleApiResponse(response);
}

/**
 * Retrieves the list of friends of the logged-in user.
 * @returns A list of friends.
 */
export async function getFriendsList(): Promise<Friend[]> {
	const response = await fetch('/api/users/friends/friends', {
		method: 'GET',
		headers: { 'Content-Type': 'application/json' },
		credentials: 'include',
	});
	return handleApiResponse(response);
}

/**
 * Retrieves the friend requests sent by the logged-in user.
 * @returns A list of sent friend requests.
 */
export async function getSentFriendRequests(): Promise<PendingFriendRequest[]> {
	const response = await fetch('/api/users/friends/requests/sent', {
		method: 'GET',
		headers: { 'Content-Type': 'application/json' },
		credentials: 'include',
	});
	return handleApiResponse(response);
}

/**
 * Accepts a friend request.
 * @param friendshipId The ID of the friendship (obtained from a received request).
 * @returns A message indicating the result of the operation.
 */
export async function acceptFriendRequest(friendshipId: number): Promise<{ message: string }> {
	const response = await fetchWithCsrf(`/api/users/friends/requests/${friendshipId}/accept`, {
		method: 'POST',
	});
	return handleApiResponse(response);
}

/**
 * Declines a received friend request.
 * @param friendshipId The ID of the friendship.
 * @returns A message indicating the result of the operation.
 */
export async function declineFriendRequest(friendshipId: number): Promise<{ message: string }> {
	const response = await fetchWithCsrf(`/api/users/friends/requests/${friendshipId}/decline`, {
		method: 'POST',
	});
	return handleApiResponse(response);
}

/**
 * Cancels a sent friend request.
 * @param friendshipId The ID of the friendship.
 * @returns A message indicating the result of the operation.
 */
export async function cancelFriendRequest(friendshipId: number): Promise<{ message: string }> {
	const response = await fetchWithCsrf(`/api/users/friends/requests/${friendshipId}/cancel`, {
		method: 'POST',
	});
	return handleApiResponse(response);
}

/**
 * Sends a friend request to another user.
 * @param friendId The ID of the friend to be added.
 * @returns A message indicating the result of the operation.
 */
export async function sendFriendRequest(friendId: number): Promise<{ message: string }> {
	const response = await fetchWithCsrf('/api/users/friends/requests', {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({ friendId }),
	});
	return handleApiResponse(response);
}

/**
 * Removes a friend by friendshipId.
 * @param friendshipId The ID of the friendship to remove.
 * @returns A message indicating the result of the operation.
 */
export async function removeFriend(friendshipId: number): Promise<{ message: string }> {
    const response = await fetchWithCsrf(`/api/users/friends/${friendshipId}/remove`, {
        method: 'POST',
    });
    return handleApiResponse(response);
}
// app/frontend/conf/services/authService.ts
import { fetchWithCsrf, setCsrfToken } from './csrf.js';
import { User, LoginRequestBody, RegisterRequestBody, UpdateUserPayload, ApiErrorResponse, ApiSuccessResponse, ApiResult } from '../shared/types.js';

const USER_DATA_KEY = 'userDataKey';
const USER_DATA_EXPIRATION_KEY = 'userDataExpiration';

/**
 * Retrieves user data (not the token) from localStorage.
 * The presence of this data does not guarantee that the user is still authenticated
 * (the JWT cookie might have expired). An API call is required to confirm authentication.
 * @returns User if available, null otherwise.
 */
export function getUserDataFromStorage(): User | null {
	const expiration = localStorage.getItem(USER_DATA_EXPIRATION_KEY);
	if (expiration && new Date().getTime() > parseInt(expiration, 10)) {
		localStorage.removeItem(USER_DATA_KEY);
		localStorage.removeItem(USER_DATA_EXPIRATION_KEY);
		return null;
	}

	const data = localStorage.getItem(USER_DATA_KEY);
	try {
		const parsedData = data ? JSON.parse(data) as User : null;
		if (parsedData && parsedData.id && parsedData.username) {
			return parsedData;
		}
		localStorage.removeItem(USER_DATA_KEY);
		return null;
	} catch (e) {
		console.error("Error reading user data", e);
		localStorage.removeItem(USER_DATA_KEY);
		return null;
	}
}

export function setUserDataInStorage(User: User): void {
	localStorage.setItem(USER_DATA_KEY, JSON.stringify(User));
	const expiration = new Date().getTime() + 24 * 60 * 60 * 1000; // 24 hours
	localStorage.setItem(USER_DATA_EXPIRATION_KEY, expiration.toString());
}

/**
 * Attempts to verify the authentication status by calling a protected endpoint.
 * The server will verify the JWT cookie.
 * @returns User if authenticated, null otherwise.
 */
export async function checkAuthStatus(): Promise<User | null> {
	const meUrl = '/api/users/me';
	try {
		const response = await fetch(meUrl, {
			method: 'GET',
			headers: { 'Content-Type': 'application/json' },
			credentials: 'include', // Important to send cookie
		});
		if (response.ok) {
			const User: User = await response.json();
			localStorage.setItem(USER_DATA_KEY, JSON.stringify(User)); // sync
			return User;
		}
		localStorage.removeItem(USER_DATA_KEY);
		return null;
	} catch (error) {
		console.error("Error verifying authentication status:", error);
		localStorage.removeItem(USER_DATA_KEY);
		return null;
	}
}

/**
 * Attempts to log in with the provided credentials.
 * @param credentials Login credentials (identifier and password).
 * @returns LoginResult indicating success or failure.
 */
export async function attemptLogin(credentials: LoginRequestBody): Promise<ApiResult> {
	if (!credentials.identifier || !credentials.password) {
		return { success: false, error: "Identifier and password are required." };
	}

	const loginUrl = '/api/users/auth/login';

	try {
		const response = await fetch(loginUrl, {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify(credentials),
			credentials: 'include',
		});

		if (!response.ok) {
			console.error(`HTTP error! status: ${response.status} ${response.statusText}`);
			let errorData: ApiErrorResponse = { error: `Server error (${response.status})` };
			try {
				errorData = await response.json();
			} catch (jsonError) {
				console.error("Unable to parse JSON error response:", jsonError);
			}
			return { success: false, error: errorData.error || response.statusText };
		}

		const data: ApiSuccessResponse & { csrfToken: string } = await response.json();

		if (data && data.user) {
			localStorage.setItem(USER_DATA_KEY, JSON.stringify(data.user));
			setCsrfToken(data.csrfToken); // Stocker le token CSRF
			return { success: true, data: data };
		} else {
			console.warn("No user data received in login response.");
			return { success: false, error: "Problem receiving user data." };
		}
	} catch (error) {
		console.error("Network error or other issue during fetch call:", error);
		const errorMessage = error instanceof Error ? error.message : "Unknown error";
		return { success: false, error: `Server connection error (${errorMessage})` };
	}
}

/**
 * Logs out the user by removing local data and invalidating the server-side session.
 */
export async function logout(): Promise<void> {
	const logoutUrl = '/api/users/auth/logout';
	localStorage.removeItem(USER_DATA_KEY);
	console.log("User data removed from localStorage.");

	try {
		const response = await fetch(logoutUrl, {
			method: 'POST',
			credentials: 'include',
		});
		if (response.ok) {
			console.log("Server-side logout successful (cookie invalidated).");
		} else {
			console.warn("Server-side logout may have failed:", response.status);
		}
	} catch (error) {
		console.error("Error attempting server logout:", error);
	}
	// Redirect ?
}

/**
 * Attempts to register a new user with the provided credentials.
 * @param credentials Registration credentials (username, email, password, etc.).
 * @returns RegisterResult indicating success or failure.
 */
export async function attemptRegister(credentials: RegisterRequestBody): Promise<ApiResult> {
    const registerUrl = '/api/users/auth/register';

    try {
        const payload: any = { ...credentials };
        if (!payload.avatar_url) {
            delete payload.avatar_url;
        }

        const response = await fetch(registerUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
        });

        const data: ApiSuccessResponse = await response.json();

        if (!response.ok) {
            console.error(`HTTP error! status: ${response.status} ${response.statusText}`);
            const errorMsg = (data && typeof data === 'object' && 'error' in data && typeof data.error === 'string')
                ? data.error
                : response.statusText;
            return { success: false, error: errorMsg };
        }

        // Succès : le backend ne renvoie qu'un message
        return { success: true, data };

    } catch (error) {
        console.error("Network error during registration:", error);
        const errorMessage = error instanceof Error ? error.message : "Unknown error";
        return { success: false, error: `Server connection error during registration (${errorMessage})` };
    }
}

/**
 * Updates the user's profile with the provided payload.
 * @param payload Profile update payload (email, display name, avatar URL, etc.).
 * @returns UpdateProfileResult indicating success or failure.
 */
export async function updateUserProfile(payload: UpdateUserPayload): Promise<ApiResult> {
	const profileUpdateUrl = '/api/users/me';

	const cleanPayload = { ...payload };
	if (cleanPayload.avatar_url === undefined || cleanPayload.avatar_url === null || cleanPayload.avatar_url === '') {
		delete cleanPayload.avatar_url;
	}
	try {
		const response = await fetchWithCsrf(profileUpdateUrl, {
			method: 'PATCH',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify(cleanPayload),
			credentials: 'include', // IMPORTANT
		});

		if (!response.ok) {
			console.error(`HTTP error! status: ${response.status} ${response.statusText}`);
			let errorData: ApiErrorResponse = { error: `Server error (${response.status})` };
			try {
				errorData = await response.json();
			} catch (jsonError) {
				console.error("Unable to parse JSON error response:", jsonError);
			}
			if (response.status === 401) {
				logout();
				return { success: false, error: "Session expired or invalid. Please log in again." };
			}
			return { success: false, error: errorData.error || response.statusText };
		}

		const data: ApiSuccessResponse = await response.json();
		console.log("Profile successfully updated via API:", data);

		if (data.user) {
			localStorage.setItem(USER_DATA_KEY, JSON.stringify(data.user));
			console.log("User data updated in localStorage.");
		}
		return { success: true, data: data };

	} catch (error) {
		console.error("Network error during profile update:", error);
		const errorMessage = error instanceof Error ? error.message : "Unknown error";
		return { success: false, error: `Server connection error during update (${errorMessage})` };
	}
}
// app/frontend/conf/pages/userPage.ts
import { fetchUsers } from '../services/api.js';
import { UserList } from '../components/userList.js';

export async function UsersPage(): Promise<HTMLElement> {
    const container = document.createElement('div');
    container.className = 'container mx-auto p-8';

    const title = document.createElement('h1');
    title.className = 'text-3xl font-bold mb-6 text-center text-blue-700';
    title.textContent = '🏓 King-Pong User List 🏓';

    const userListElement = document.createElement('div');
    userListElement.id = 'user-list';
    userListElement.className = 'mt-6 bg-white p-6 rounded-lg shadow-md';
    userListElement.innerHTML = '<p class="text-center text-gray-500">Loading users...</p>';

    container.appendChild(title);
    container.appendChild(userListElement);

    try {
        const users = await fetchUsers();
        userListElement.innerHTML = '';

        // Fournir des valeurs par défaut pour les props requises
        const userListProps = {
            users,
            friends: [],
            sentRequests: [],
            receivedRequests: [],
            currentUserId: -1, // ou null/undefined si tu adaptes UserList
            onSendRequest: async () => {},
            onCancelRequest: async () => {},
            onAcceptRequest: async () => {},
            onDeclineRequest: async () => {},
        };
        userListElement.appendChild(UserList(userListProps));
    } catch (error) {
        console.error("Failed to load users for UsersPage:", error);
        userListElement.innerHTML = '<p class="text-center text-red-500">Error loading users.</p>';
    }

    return container;
}
// app/frontend/conf/pages/dashboardPage.ts
import { navigateTo } from '../services/router.js';
import { getUserDataFromStorage, logout } from '../services/authService.js';
import { fetchCsrfToken } from '../services/csrf.js';
import { User as AuthUserType, User as ApiUserType } from '../shared/types.js';
import {
	getReceivedFriendRequests,
	getSentFriendRequests,
	acceptFriendRequest,
	declineFriendRequest,
	cancelFriendRequest,
	getFriendsList,
	sendFriendRequest,
	removeFriend,
} from '../services/friendService.js';
import { fetchUsers } from '../services/api.js';
import { FriendsListComponent } from '../components/friendsList.js';
import { FriendRequestsComponent } from '../components/friendRequests.js';
import { UserList, UserListProps } from '../components/userList.js';
import { HeaderComponent } from '../components/headerComponent.js';
import { showToast } from '../components/toast.js';

// Placeholder pour l'historique des matchs
function MatchHistoryComponent(): HTMLElement {
	const el = document.createElement('div');
	el.className = 'p-4 text-center';
	el.innerHTML = '<p class="text-gray-500">L\'historique des matchs sera affiché ici.</p>';
	return el;
}

export async function DashboardPage(): Promise<HTMLElement> {
	const currentUser: AuthUserType | null = getUserDataFromStorage();

	if (!currentUser) {
		navigateTo('/login');
		const redirectMsg = document.createElement('div');
		redirectMsg.className = 'min-h-screen flex items-center justify-center text-xl';
		redirectMsg.textContent = 'Redirecting to login...';
		return redirectMsg;
	}

	try {
		await fetchCsrfToken();
	} catch (error) {
		console.error("Failed to fetch CSRF token:", error);
		const errorMsg = document.createElement('div');
		errorMsg.className = 'min-h-screen flex items-center justify-center text-xl text-red-500';
		errorMsg.textContent = 'Error initializing page. Please try refreshing.';
		return errorMsg;
	}

	// --- Conteneur principal de la page ---
	const pageContainer = document.createElement('div');
	pageContainer.className = 'min-h-screen bg-gray-200 p-4 sm:p-8 flex flex-col items-center';

	// --- Le "Dashboard" lui-même ---
	const dashboardWrapper = document.createElement('div');
	dashboardWrapper.className = 'bg-white rounded-2xl shadow-2xl w-full max-w-6xl flex flex-col overflow-hidden';

	// --- Section du haut (Langue, User Header) ---
	const headerElement = HeaderComponent({ currentUser: currentUser! });
	// Note: The global click listener for menu close is in HeaderComponent.

	// --- Section principale (Sidebar + Contenu à onglets) ---
	const mainSection = document.createElement('div');
	mainSection.className = 'flex flex-1 min-h-[calc(100vh-150px)]'; // Hauteur minimale pour le contenu

	// --- Sidebar ---
	const sidebar = document.createElement('div');
	sidebar.className = 'w-1/4 p-6 bg-gray-50 border-r border-gray-200 space-y-3 overflow-y-auto';

	function createSidebarItem(label: string, value: string | number | Date | undefined | null): HTMLElement {
		const item = document.createElement('div');
		item.className = 'p-2.5 bg-white border border-gray-200 rounded-lg shadow-sm';
		const labelEl = document.createElement('span');
		labelEl.className = 'text-xs text-gray-500 block mb-0.5';
		labelEl.textContent = label;
		const valueEl = document.createElement('p');
		valueEl.className = 'text-sm text-gray-800 font-medium truncate';
		if (value instanceof Date) {
			valueEl.textContent = value.toLocaleDateString();
		} else {
			valueEl.textContent = value?.toString() || 'N/A';
		}
		item.appendChild(labelEl);
		item.appendChild(valueEl);
		return item;
	}

	sidebar.appendChild(createSidebarItem('Username', currentUser.username));
	sidebar.appendChild(createSidebarItem('Display Name', currentUser.display_name));
	sidebar.appendChild(createSidebarItem('Email', currentUser.email));
	sidebar.appendChild(createSidebarItem('Creation Date', new Date(currentUser.created_at)));
	sidebar.appendChild(createSidebarItem('Wins', currentUser.wins ?? 'N/A'));
	sidebar.appendChild(createSidebarItem('Losses', currentUser.losses ?? 'N/A'));

	// --- Contenu à onglets ---
	const tabContentWrapper = document.createElement('div');
	tabContentWrapper.className = 'w-3/4 p-6 flex flex-col overflow-y-auto';

	const tabNavigation = document.createElement('div');
	tabNavigation.className = 'flex space-x-1 border-b border-gray-200 mb-6';

	const TABS = [
		{ id: 'users', label: 'All Users', componentLoader: loadUsersContent },
		{ id: 'friends', label: 'Friends', componentLoader: loadFriendsContent },
		{ id: 'pending', label: 'Pending', componentLoader: loadPendingRequestsContent },
		{ id: 'history', label: 'History Match', componentLoader: loadMatchHistoryContent },
	];
	let activeTabId = TABS[0].id;

	const activeTabContentContainer = document.createElement('div');
	activeTabContentContainer.id = 'active-tab-content';
	activeTabContentContainer.className = 'flex-1';

	TABS.forEach(tabInfo => {
		const tabButton = document.createElement('button');
		tabButton.dataset.tabId = tabInfo.id;
		tabButton.textContent = tabInfo.label;
		tabButton.className = `py-2 px-4 text-sm font-medium focus:outline-none transition-colors`;
		if (tabInfo.id === activeTabId) {
			tabButton.classList.add('border-b-2', 'border-blue-600', 'text-blue-600');
		} else {
			tabButton.classList.add('text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
		}
		tabButton.addEventListener('click', () => switchTab(tabInfo.id));
		tabNavigation.appendChild(tabButton);
	});

	tabContentWrapper.appendChild(tabNavigation);
	tabContentWrapper.appendChild(activeTabContentContainer);

	mainSection.appendChild(sidebar);
	mainSection.appendChild(tabContentWrapper);

	dashboardWrapper.appendChild(headerElement);
	dashboardWrapper.appendChild(mainSection);
	pageContainer.appendChild(dashboardWrapper);

	// --- Fonctions de rappel pour les actions d'amitié (utilisées par UserList) ---
	const handleSendFriendRequest = async (targetUserId: number) => {
		const result = await sendFriendRequest(targetUserId);
		showToast(result.message);
		if (activeTabId === 'users' || activeTabId === 'pending') await loadActiveTabContent(); // Recharger si l'onglet users ou pending est actif
	};

	const handleCancelFriendRequest = async (friendshipId: number) => {
		const result = await cancelFriendRequest(friendshipId);
		showToast(result.message);
		if (activeTabId === 'users' || activeTabId === 'pending') await loadActiveTabContent();
	};

	const handleAcceptFriendRequest = async (friendshipId: number) => {
		const result = await acceptFriendRequest(friendshipId);
		showToast(result.message, 'success');
		if (['users', 'pending', 'friends'].includes(activeTabId)) await loadActiveTabContent();
	};

	const handleDeclineFriendRequest = async (friendshipId: number) => {
		const result = await declineFriendRequest(friendshipId);
		showToast(result.message, 'success');
		if (activeTabId === 'users' || activeTabId === 'pending') await loadActiveTabContent();
	};

	// --- Logique de chargement et de changement d'onglet ---
	async function switchTab(tabId: string) {
		activeTabId = tabId;
		tabNavigation.querySelectorAll('button').forEach(btn => {
			if (btn.dataset.tabId === tabId) {
				btn.className = 'py-2 px-4 text-sm font-medium focus:outline-none transition-colors border-b-2 border-blue-600 text-blue-600';
			} else {
				btn.className = 'py-2 px-4 text-sm font-medium focus:outline-none transition-colors text-gray-500 hover:text-gray-700 hover:border-gray-300';
			}
		});
		await loadActiveTabContent();
	}

	async function loadActiveTabContent() {
		activeTabContentContainer.innerHTML = '<p class="text-center text-gray-500 py-10">Loading...</p>';
		const currentTab = TABS.find(t => t.id === activeTabId);
		if (currentTab) {
			try {
				const contentElement = await currentTab.componentLoader();
				activeTabContentContainer.innerHTML = '';
				activeTabContentContainer.appendChild(contentElement);
			} catch (error) {
				console.error(`Error loading content for tab ${activeTabId}:`, error);
				activeTabContentContainer.innerHTML = `<p class="text-center text-red-500 py-10">Error loading content for ${activeTabId}.</p>`;
			}
		}
	}

	// --- Fonctions de chargement spécifiques pour chaque onglet ---
	async function loadUsersContent(): Promise<HTMLElement> {
		const [usersData, friendsData, sentRequestsData, receivedRequestsData] = await Promise.all([
			fetchUsers(),
			getFriendsList(),
			getSentFriendRequests(),
			getReceivedFriendRequests()
		]);

		const userListProps: UserListProps = {
			users: usersData as ApiUserType[],
			friends: friendsData,
			sentRequests: sentRequestsData,
			receivedRequests: receivedRequestsData,
			currentUserId: currentUser!.id,
			onSendRequest: handleSendFriendRequest,
			onCancelRequest: handleCancelFriendRequest,
			onAcceptRequest: handleAcceptFriendRequest,
			onDeclineRequest: handleDeclineFriendRequest,
		};
		return UserList(userListProps);
	}

	async function loadFriendsContent(): Promise<HTMLElement> {
		const friends = await getFriendsList();
		return FriendsListComponent({
			friends: friends,
			onRemoveFriend: async (friendshipId) => {
				const result = await removeFriend(friendshipId);
				showToast(result.message);
				if (['friends', 'users'].includes(activeTabId)) await loadActiveTabContent();
			},
		});
	}

	async function loadPendingRequestsContent(): Promise<HTMLElement> {
		const [received, sent] = await Promise.all([
			getReceivedFriendRequests(),
			getSentFriendRequests(),
		]);
		return FriendRequestsComponent({
			receivedRequests: received,
			sentRequests: sent,
			onAcceptRequest: handleAcceptFriendRequest, // Réutilisation du handler global
			onDeclineRequest: handleDeclineFriendRequest, // Réutilisation du handler global
			onCancelRequest: handleCancelFriendRequest, // Réutilisation du handler global
		});
	}

	async function loadMatchHistoryContent(): Promise<HTMLElement> {
		return MatchHistoryComponent();
	}

	// Charger le contenu de l'onglet initial
	await loadActiveTabContent();

	return pageContainer;
}
// app/frontend/conf/pages/gameRoomPage.ts
import { GameMode } from "../components/gamePage.js";
import { cleanupSocket } from "../services/initOnlineGame.js";
import { navigateTo } from "../services/router.js";
import socket from '../services/socket.js'
import { showToast } from '../components/toast.js';

export function GameRoomPage(mode: GameMode): HTMLElement {
	const container = document.createElement('div');
	container.className = 'w-full h-screen flex flex-col items-center justify-center bg-gray-900';

	// Game box
	const gameBox = document.createElement('div');
	gameBox.className = 'relative bg-white w-[800px] h-[500px] border-4 border-black overflow-hidden';
	gameBox.id = 'game-box';

	// Left paddle
	const leftPaddle: HTMLDivElement = document.createElement('div');
	leftPaddle.className = 'absolute left-0 top-[200px] w-[10px] h-[100px] bg-black';
	leftPaddle.id = 'left-paddle';

	// Right paddle
	const rightPaddle = document.createElement('div');
	rightPaddle.className = 'absolute right-0 top-[200px] w-[10px] h-[100px] bg-black';
	rightPaddle.id = 'right-paddle';

	// Ball
	const ball = document.createElement('div');
	ball.className = 'absolute w-[15px] h-[15px] bg-red-600 rounded-full';
	ball.id = 'ball';

	ball.style.left = 'calc(50% - 7.5px)';
	ball.style.top = 'calc(50% - 7.5px)';

	// Countdown overlay
	const countdown = document.createElement('div');
	countdown.className = 'absolute inset-0 flex items-center justify-center text-6xl font-bold text-white bg-black bg-opacity-70 z-50';
	countdown.id = 'countdown';
	countdown.textContent = 'Start in 3...';

	// Left username
	const leftUsername = document.createElement('div');
	leftUsername.className = 'absolute left-[20px] top-[20px] px-3 py-1 bg-white border border-black rounded text-black font-semibold text-xl shadow';
	leftUsername.id = 'left-username';

	// Right username
	const rightUsername = document.createElement('div');
	rightUsername.className = 'absolute right-[20px] top-[20px] px-3 py-1 bg-white border border-black rounded text-black font-semibold text-xl shadow text-right';
	rightUsername.id = 'right-username';

	// Score display
	const scoreDisplay = document.createElement('div');
	scoreDisplay.className = 'absolute top-[20px] left-1/2 transform -translate-x-1/2 text-2xl font-bold text-black';
	scoreDisplay.id = 'score-display';
	scoreDisplay.textContent = '0 - 0';

	// Quit button
	const quitButton = document.createElement('button');
	quitButton.className = 'mt-6 px-4 py-2 bg-red-600 text-white font-bold rounded hover:bg-red-700';
	quitButton.textContent = 'Quit';

	// Append all to game box
	gameBox.appendChild(leftPaddle);
	gameBox.appendChild(rightPaddle);
	gameBox.appendChild(ball);
	gameBox.appendChild(countdown);
	gameBox.appendChild(leftUsername);
	gameBox.appendChild(rightUsername);
	gameBox.appendChild(scoreDisplay);

	container.append(gameBox, quitButton);

	if (sessionStorage.getItem('gameMode') === 'local') {
		rightUsername.textContent = sessionStorage.getItem('player1');
		leftUsername.textContent = sessionStorage.getItem('player2');
	} else {
		setBoard(leftUsername, rightUsername);
	}

	// --- Countdown function
	initCountdown(countdown);

	// --- Main game function for socket handling and game logic
	initGame(quitButton);

	return container;
}

function setBoard(leftUsername: HTMLDivElement, rightUsername: HTMLDivElement) {
	const side = sessionStorage.getItem('side');
	const displayName = sessionStorage.getItem('displayName');
	const opponent = sessionStorage.getItem('opponent');
	if (side === 'left') {
		leftUsername.textContent = displayName;
		rightUsername.textContent = opponent;
	} else if (side === 'right') {
		leftUsername.textContent = opponent;
		rightUsername.textContent = displayName;
	}
}

function initGame(container: HTMLButtonElement) {
	const gameMode = sessionStorage.getItem('gameMode');
	console.log("Game mode: ", gameMode);

	if (!socket.connected) {
		socket.connect();
	}

	socket.on('connect', () => {
		console.log('emit startLocal');
		if (gameMode === 'local') {
			socket.emit('startLocalGame');
		}
	});

	// after connexion to the server
	socket.on('gameStarted', () => {
		if (gameMode === 'local') {
			startLocalGame(socket);
		}
	});

	if (gameMode === 'online') {
		startOnlineGame(socket);
	}

	// --- Event: quit button ---
	container.addEventListener('click', () => {
		const matchId = sessionStorage.getItem('matchId');
		socket.emit('quit', socket.id, matchId);
		console.log('Quit game clicked');
		cleanupSocket(socket);
		sessionStorage.clear(); // clean storage --> users have to put there aliases again
		navigateTo('/game');
	});

	socket.on('gameFinished', () => {
		// TODO: une fenetre avec tous les infos sur le match
		alert('You won!');
		cleanupSocket(socket);
		sessionStorage.clear();
		navigateTo('/game');
	});

}

function startOnlineGame(socket: SocketIOClient.Socket) {

	const side = sessionStorage.getItem('side');
	console.log('SIDE:', side);
	let paddleMovement = 0;

	document.addEventListener('keydown', (event) => {
		if (event.key === 'ArrowUp') {
			paddleMovement = -1;
		} else if (event.key === 'ArrowDown') {
			paddleMovement = 1;
		}
		socket.emit('playerMove', {
			side,
			paddleMovement,
		});
	})


	document.addEventListener('keyup', (event) => {
		if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
			paddleMovement = 0;
			socket.emit('playerMove', {
				side,
				paddleMovement,
			});
		}
	});

	// socket.on('stateUpdate', (data: string) => {
	// 	const { leftPaddleUpdated, rightPaddleUpdated, ballUpdated } = JSON.parse(data);
	// 	document.getElementById('left-paddle')!.style.top = `${leftPaddleUpdated}px`;
	// 	document.getElementById('right-paddle')!.style.top = `${rightPaddleUpdated}px`;
	// 	document.getElementById('ball')!.style.left = `${ballUpdated.x}px`;
	// 	document.getElementById('ball')!.style.top = `${ballUpdated.y}px`;
	// });

}

function startLocalGame(socket: SocketIOClient.Socket) {
	let leftPaddleMovement = 0;
	let rightPaddleMovement = 0;

	document.addEventListener('keydown', (event) => {
		if (event.key === 'w' || event.key === 'W') {
			leftPaddleMovement = -1; // deplacer vers le haut
		} else if (event.key === 's' || event.key === 'S') {
			leftPaddleMovement = 1; // deplacer vers le bas
		}

		if (event.key === 'ArrowUp') {
			rightPaddleMovement = -1;
		} else if (event.key === 'ArrowDown') {
			rightPaddleMovement = 1;
		}
		sendPlayerMovement(socket, leftPaddleMovement, rightPaddleMovement);

	})

	document.addEventListener('keyup', (event) => {
		if (event.key === 'w' || event.key === 's' || event.key === 'W' || event.key == 'S') {
			leftPaddleMovement = 0;
		}
		if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
			rightPaddleMovement = 0;
		}

		sendPlayerMovement(socket, leftPaddleMovement, rightPaddleMovement);
	})

	// TODO
	// socket.on('stateUpdate', (data: string) => {
	// 	const { leftPaddleUpdated, rightPaddleUpdated } = JSON.parse(data);
	// 	const leftPaddleElem = document.getElementById('left-paddle');
	// 	const rightPaddleElem = document.getElementById('right-paddle');

	// 	if (leftPaddleElem && rightPaddleElem) {
	// 		leftPaddleElem.style.top = `${leftPaddleUpdated}px`;
	// 		rightPaddleElem.style.top = `${rightPaddleUpdated}px`;
	// 	}
	// });

}

function sendPlayerMovement(socket: SocketIOClient.Socket, leftPaddle: number, rightPaddle: number) {
	socket.emit('playerMove', ({
		leftPaddle,
		rightPaddle,
	}));
}

async function initCountdown(container: HTMLDivElement) {
	const countdownIsDone = sessionStorage.getItem('countdown') === 'true';
	// Countdown logic
	if (!countdownIsDone) {
		let countdownValue = 3;
		const interval = setInterval(() => {
			if (countdownValue > 1) {
				countdownValue--;
				container.textContent = `Start in ${countdownValue}...`;
			} else {
				container.remove(); // remove overlay
				clearInterval(interval);
				sessionStorage.setItem('countdown', 'true');

			}
		}, 1000);
	} else {
		container.remove();
	}

}
// function startRemoteGame(gameBox: HTMLDivElement) {

// }
// app/frontend/conf/pages/profilePage.ts
// /pages/profilePage.ts
import { getUserDataFromStorage, updateUserProfile } from '../services/authService.js';
import { navigateTo } from '../services/router.js';
import { User, UpdateUserPayload, ApiResult } from '../shared/types.js';
import { ProfileForm } from '../components/profileForm.js'; // Importer le composant
import { fetchCsrfToken } from '../services/csrf.js';

export async function ProfilePage(): Promise<HTMLElement> {
	const user: User | null = getUserDataFromStorage();

	const pageContainer = document.createElement('div'); // Conteneur principal de la page
	pageContainer.className = 'min-h-screen bg-gray-100 p-4 md:p-8';

	if (!user) {
		console.warn('Access unauthorized: User not authenticated.');
		navigateTo('/login');

		const deniedContainer = document.createElement('div');
		deniedContainer.className = 'flex items-center justify-center h-full'; // Pour centrer dans pageContainer
		deniedContainer.innerHTML = `
            <div class="bg-white rounded-xl shadow-lg p-8 text-center">
                <h1 class="text-2xl font-bold text-red-600 mb-4">Accès Refusé</h1>
                <p class="text-gray-700 mb-4">Vous devez être connecté pour accéder à votre profil.</p>
                <p class="text-gray-700">Redirection vers la page de connexion...</p>
                <!-- <a href="/login" data-link class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                    Se connecter
                </a> -->
            </div>
        `;
		pageContainer.appendChild(deniedContainer);
		return pageContainer;
	}


	try {
		await fetchCsrfToken();
	} catch (error) {
		console.error("Failed to fetch CSRF token:", error);
		const errorMsg = document.createElement('div');
		errorMsg.className = 'min-h-screen flex items-center justify-center text-xl text-red-500';
		errorMsg.textContent = 'Error initializing page. Please try refreshing.';
		return errorMsg;
	}

	const contentWrapper = document.createElement('div');
	contentWrapper.className = 'max-w-xl mx-auto bg-white rounded-xl shadow-lg p-6 md:p-8';

	const title = document.createElement('h1');
	title.className = 'text-3xl font-bold text-gray-800 mb-6 border-b pb-4';
	title.textContent = 'Mon Profil';
	contentWrapper.appendChild(title);

	// Fonction de rappel pour la mise à jour du profil
	const handleProfileUpdate = async (payload: UpdateUserPayload): Promise<ApiResult> => {
		const result = await updateUserProfile(payload);
		if (result.success) {
			console.log('Profile updated in service, local storage should be updated too.');
		}
		setTimeout(() => { navigateTo('/dashboard'); }, 500);
		return result;
	};

	// Créer et ajouter le composant formulaire
	const profileFormComponent = ProfileForm({
		user: user, // Passer l'utilisateur actuel au composant
		onProfileUpdate: handleProfileUpdate,
	});
	contentWrapper.appendChild(profileFormComponent);

	// Lien de retour
	const backLink = document.createElement('a');
	backLink.href = '/dashboard';
	backLink.setAttribute('data-link', ''); // Pour le routeur
	backLink.className = 'block text-center text-gray-600 hover:text-gray-800 text-sm mt-6'; // Style ajusté
	backLink.textContent = 'Retour au Tableau de Bord';

	// Vérifier si le formulaire existe avant d'essayer de l'insérer
	const formElement = contentWrapper.querySelector('#profile-form-component');
	if (formElement && formElement.parentNode) {
		// Insérer le lien après la dernière div du formulaire (celle avec le bouton)
		const lastDivInForm = formElement.children[formElement.children.length - 1];
		if (lastDivInForm && lastDivInForm.parentNode) {
			(lastDivInForm.parentNode as HTMLElement).insertBefore(backLink, lastDivInForm.nextSibling);
		} else {
			contentWrapper.appendChild(backLink); // Fallback
		}
	} else {
		contentWrapper.appendChild(backLink); // Fallback
	}

	pageContainer.appendChild(contentWrapper);
	return pageContainer;
}
// app/frontend/conf/pages/loginPage.ts
// /pages/loginPage.ts
import { attemptLogin } from '../services/authService.js';
import { navigateTo } from '../services/router.js';
import { LoginForm } from '../components/loginForm.js';
import { LoginRequestBody, ApiResult } from '../shared/types.js';

export function LoginPage(): HTMLElement {
	const container = document.createElement('div');
	container.className = 'bg-gradient-to-r from-blue-500 to-purple-600 flex justify-center items-center min-h-screen p-8';

	const formContainer = document.createElement('div');
	formContainer.className = 'bg-white bg-opacity-90 backdrop-filter backdrop-blur-lg rounded-xl shadow-2xl p-8 max-w-md w-full';

	const title = document.createElement('h2');
	title.className = 'text-3xl font-bold mb-6 text-center text-gray-800';
	title.textContent = 'Login';

	formContainer.appendChild(title);

	// Fonction de rappel pour la soumission du formulaire
	const handleLoginAttempt = async (credentials: LoginRequestBody): Promise<ApiResult> => {
		return attemptLogin(credentials);
	};

	// Fonction de rappel pour le succès de la connexion
	const handleLoginSuccess = (userData: any) => {
		setTimeout(() => { navigateTo('/dashboard'); }, 500);
	};

	// Créer et ajouter le composant formulaire
	const loginFormComponent = LoginForm({
		onLoginAttempt: handleLoginAttempt,
		onLoginSuccess: handleLoginSuccess,
	});
	formContainer.appendChild(loginFormComponent);


	const linksDiv = document.createElement('div');
	linksDiv.className = 'mt-6 text-center';
	linksDiv.innerHTML = `
        <a href="/" data-link class="text-blue-600 hover:text-blue-800 text-sm">
            Back to Home
        </a>
        <span class="mx-2 text-gray-400">|</span>
        <a href="/register" data-link class="text-blue-600 hover:text-blue-800 text-sm">
            Don't have an account? Register
        </a>
    `;
	formContainer.appendChild(linksDiv);

	container.appendChild(formContainer);

	return container;
}
// app/frontend/conf/main.ts
import { HomePage } from './components/homePage.js';
import { LoginPage } from './pages/loginPage.js'
import { RegisterPage } from './components/registerPage.js'
import { UsersPage } from './pages/userPage.js';
import { GamePage } from './components/gamePage.js';
import { GameRoomPage } from './pages/gameRoomPage.js';
import { navigateTo } from './services/router.js'; // à ajouter en haut
import { DashboardPage } from './pages/dashboardPage.js'
import { ProfilePage } from './pages/profilePage.js';
import { getUserDataFromStorage } from './services/authService.js';
import { promptAliasForm } from './components/aliasFormPage.js';
import { GameMode } from './components/gamePage.js'

// Conteneur où le contenu de la page sera injecté
const appContainer = document.getElementById('main');

interface RouteConfig {
	component: () => HTMLElement | Promise<HTMLElement>;
	requiredAuth?: boolean;
}

function renderNotFoundPage(): HTMLElement {
	const div = document.createElement('div');
	div.innerHTML = `
        <h1 class="text-3xl font-bold text-red-500 text-center p-8">404 - Page Non Trouvée</h1>
        <p class="text-center">Oups! Cette page n'existe pas.</p>
        <div class="text-center mt-4">
            <a href="/" data-link class="text-blue-500 hover:underline">Retour à l'accueil</a>
        </div>
    `;
	return div;
}

const routes: { [key: string]: RouteConfig } = {
	'/': { component: HomePage },
	'/users': { component: UsersPage },
	'/login': { component: LoginPage },
	'/register': { component: RegisterPage },
	'/dashboard': { component: DashboardPage, requiredAuth: true },
	'/profile': { component: ProfilePage, requiredAuth: true },
	'/game': { component: GamePage },
	'/local-game': { component: promptAliasForm},
	'/game-room': { component: () => GameRoomPageFromParams() },
};

function GameRoomPageFromParams(): HTMLElement {
	const urlParams = new URLSearchParams(window.location.search);
	const mode = urlParams.get('mode') as GameMode || 'local';
	return GameRoomPage(mode);
}

export async function router() {
	if (!appContainer) {
		console.error("ERREUR: Le conteneur #app est introuvable dans le DOM !");
		return;
	}
	const path = window.location.pathname;
	console.log(`navigateTo: ${path}`);
	const routeCfg = routes[path];
	if (!routeCfg) {
		appContainer.innerHTML = '';
		appContainer.appendChild(renderNotFoundPage());
		return;
	}
	if (routeCfg.requiredAuth) {
		const authData = getUserDataFromStorage();
		if (!authData) {
			console.log('Utilisateur non authentifié, redirection vers la page de connexion.');

			navigateTo('/login');
			return;
		}
	}
	const renderFunction = routeCfg.component;
	appContainer.innerHTML = '';
	try {
		const pageContent = await renderFunction();
		appContainer.appendChild(pageContent);
	} catch (error) {
		console.error(`Erreur lors du rendu de la route ${path}:`, error);
		appContainer.innerHTML = `<p class="text-red-500 text-center p-8">Une erreur est survenue lors du chargement de la page.</p>`;
	}
}

// Se déclenche lorsque le HTML initial est chargé
document.addEventListener('DOMContentLoaded', () => {
	document.body.addEventListener('click', (event) => {
		const target = event.target as HTMLElement;
		const linkElement = target.closest('a[data-link]') as HTMLAnchorElement | null;
		if (linkElement) {
			event.preventDefault();
			const destination = linkElement.getAttribute('href');
			if (destination) {
				navigateTo(destination);
			}
		}
	});
	router();
});

// Se déclenche lorsque l'utilisateur utilise les boutons Précédent/Suivant du navigateur
window.addEventListener('popstate', () => {
	router();
});
// app/frontend/conf/package.json
{
  "name": "frontend",
  "version": "1.0.0",
  "description": "Frontend application for Ping-Pong",
  "type": "module",
  "main": "index.js",
  "scripts": {
    "prepare:dist": "mkdir -p ./dist/css ./dist/js",
    "build:clean": "rm -rf ./dist/*",
    "build:html": "cp index.html ./dist/index.html",
    "build:ts": "tsc",
    "build:css": "./node_modules/.bin/tailwindcss -i ./style/input.css -o ./dist/css/style.css --minify",
    "build": "npm run build:clean && npm run prepare:dist && npm run build:html && npm run build:ts && npm run build:css",
    "watch:ts": "tsc --watch > ./logs/tsc.log 2>&1",
    "watch:css": "./node_modules/.bin/tailwindcss -i ./style/input.css -o ./dist/css/style.css --watch > ./logs/tailwind.log 2>&1",
    "dev": "npm run build && mkdir -p ./logs && concurrently \"npm run watch:ts\" \"npm run watch:css\""
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@tailwindcss/cli": "^4.1.4",
    "@types/node": "^22.15.17",
    "@types/socket.io-client": "^1.4.36",
    "socket.io-client": "^4.8.1",

    "tailwindcss": "^4.1.4",
    "typescript": "^5.8.3"
  },
  "dependencies": {
    "commander": "^13.1.0",
    "concurrently": "^9.1.2",
    "socket.io-client": "^4.8.1"
  }
}
// app/frontend/conf/index.html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>King-Pong</title>
  <link href="css/style.css" rel="stylesheet">
</head>
<body>
  <div id="main"> <!-- contenu de main.ts -->
    <p>Loading application...</p>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/socket.io-client@4.7.2/dist/socket.io.min.js"></script>
  
  <script type="module" src="js/main.js"></script> <!-- routeur principal -->
</body>
</html>

<!-- <script src="js/app.js" defer></script> -->
// app/frontend/conf/tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",          // Cible JavaScript moderne mais compatible
    "module": "ESNext",          // Utilise les modules ES natifs
    "moduleResolution": "node",  // Comment résoudre les modules
    "outDir": "./dist/js",       // Où mettre le JS compilé
    "rootDir": "./",          // Où se trouve le code source TS
    "strict": true,              // Activer toutes les vérifications strictes
    "esModuleInterop": true,     // Meilleure interopérabilité avec les modules CommonJS
    "skipLibCheck": true,        // Accélère la compilation
    "forceConsistentCasingInFileNames": true,
    "lib": ["ES2016", "DOM"]     // Inclure les types pour le DOM du navigateur
  },
  "include": ["**/*.ts"],       // Quels fichiers compiler
  "exclude": ["node_modules", "dist"]    // Quels fichiers ignorer
}
