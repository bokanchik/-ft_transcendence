// app/frontend/Dockerfile
FROM node:22-alpine

WORKDIR /app

COPY package*.json .

RUN npm install

COPY . .

CMD ["npm", "run", "dev"]
// app/frontend/tailwind.config.js
module.exports = {
    content: [
      './src/**/*.{html,js,ts}',
      './dist/**/*.html',
    ],
    theme: {
      extend: {
        keyframes: {
          'fade-in': {
            '0%': { opacity: '0', transform: 'translateY(10px)', boxShadow: 'none' },
            '100%': { opacity: '1', transform: 'translateY(0)', boxShadow: '0px 4px 20px rgba(0, 0, 0, 0.1)' },
          },
        },
        animation: {
          'fade-in': 'fade-in 0.5s ease-out forwards',
        },
      },
    },
    plugins: [],
  }
  // app/frontend/src/utils/config.ts
// app/frontend/conf/services/config.ts

const USER_API_PREFIX = '/api/users';
const GAME_API_PREFIX = '/api/game';

export const config = {
    api: {
        users: {
            // URL_ALL_USERS
            all: `${USER_API_PREFIX}/`,
            // URL_USER
            byId: (userId: number | string) => `${USER_API_PREFIX}/${userId}`,
            // URL_USER_ME
            me: `${USER_API_PREFIX}/me`,
            // URL_USER_MATCH
            matchesByUserId: (userId: number | string) => `${USER_API_PREFIX}/${userId}/matches`,
        },
        auth: {
            // URL_LOGIN
            login: `${USER_API_PREFIX}/auth/login`,
            // URL_REGISTER
            register: `${USER_API_PREFIX}/auth/register`,
            // URL_LOGOUT
            logout: `${USER_API_PREFIX}/auth/logout`,
            // URL_CSRF
            csrf: `${USER_API_PREFIX}/csrf-token`,
        },
        friends: {
            // URL_FRIEND_LIST
            list: `${USER_API_PREFIX}/friends/friends`,
            // URL_FRIEND_REQUEST (pour envoyer une demande)
            sendRequest: `${USER_API_PREFIX}/friends/requests`,
            // URL_FRIEND_RECEIVED
            receivedRequests: `${USER_API_PREFIX}/friends/requests/received`,
            // URL_FRIEND_SENT
            sentRequests: `${USER_API_PREFIX}/friends/requests/sent`,
            // URL_FRIEND_ACCEPT
            acceptRequest: (friendshipId: number) => `${USER_API_PREFIX}/friends/requests/${friendshipId}/accept`,
            // URL_FRIEND_DECLINE
            declineRequest: (friendshipId: number) => `${USER_API_PREFIX}/friends/requests/${friendshipId}/decline`,
            // URL_FRIEND_CANCEL
            cancelRequest: (friendshipId: number) => `${USER_API_PREFIX}/friends/requests/${friendshipId}/cancel`,
            // URL_FRIEND_REMOVE
            remove: (friendshipId: number) => `${USER_API_PREFIX}/friends/${friendshipId}/remove`,
        },
        game: {
            // URL_MATCH (POST pour cr√©er, GET pour r√©cup√©rer)
            match: (matchId?: string) => matchId ? `${GAME_API_PREFIX}/match/${matchId}` : `${GAME_API_PREFIX}/match`,
            // URL_MATCH_USER
            matchHistory: (userId: number | string) => `${GAME_API_PREFIX}/history/${userId}`,
        }
    }
};// app/frontend/src/utils/types.ts
import { z } from 'zod';
import { UserBaseSchema } from '../shared/schemas/usersSchemas.js';

export const ApiSuccessResponseSchema = z.object({
	message: z.string(),
	user: UserBaseSchema, // Ou un autre sch√©ma ??
});
export type ApiSuccessResponse = z.infer<typeof ApiSuccessResponseSchema>;

export const ApiErrorResponseSchema = z.object({
	error: z.string(),
	statusCode: z.number().optional(), // Si on fait les codes
	details: z.any().optional(),
});
export type ApiErrorResponse = z.infer<typeof ApiErrorResponseSchema>;

// typer g√©n√©riquement avec Zod si le type de `data` !!!
// en TypeScript :
export type ApiResult<TSuccessData = ApiSuccessResponse> =
	| { success: true; data: TSuccessData }
	| { success: false; error: string; details?: any; statusCode?: number };
// app/frontend/src/utils/domUtils.ts
// app/frontend/conf/utils/domUtils.ts
import { showToast } from "../components/toast.js";

export function createElement<K extends keyof HTMLElementTagNameMap>(
    tagName: K,
    options?: {
        id?: string;
        className?: string;
        textContent?: string;
        innerHTML?: string;
        name?: string; // <--- ADDED 'name'
        href?: string;
        src?: string;
        alt?: string;
        type?: string;
        value?: string;
        placeholder?: string;
        readonly?: boolean;
        required?: boolean;
        minLength?: number;
        maxLength?: number;
        min?: string;
        max?: string;
        // Add more common attributes as needed
    },
    children?: (HTMLElement | string | null | undefined)[]
): HTMLElementTagNameMap[K] {
    const el = document.createElement(tagName);

    if (options?.id) el.id = options.id;
    if (options?.className) el.className = options.className;
    if (options?.textContent) el.textContent = options.textContent;
    if (options?.innerHTML && !children?.length) el.innerHTML = options.innerHTML;
    if (options?.name) el.setAttribute('name', options.name); // Use setAttribute for name for broader compatibility

    if (options?.href && el instanceof HTMLAnchorElement) el.href = options.href;
    if (options?.src && el instanceof HTMLImageElement) el.src = options.src;
    if (options?.alt && el instanceof HTMLImageElement) el.alt = options.alt;
    
    // Handle 'type' attribute carefully
    if (options?.type) {
        if (el instanceof HTMLInputElement) {
            el.type = options.type;
        } else if (el instanceof HTMLButtonElement) {
            // Ensure type is one of the valid ones for buttons
            const validType = options.type as "submit" | "reset" | "button";
            if (["submit", "reset", "button"].includes(validType)) {
                el.type = validType;
            }
        }
        // 'type' for HTMLSelectElement is generally not set this way.
        // It's 'select-one' or 'select-multiple' based on the 'multiple' attribute.
    }

    if (options?.value && (el instanceof HTMLInputElement || el instanceof HTMLSelectElement || el instanceof HTMLTextAreaElement)) el.value = options.value;
    if (options?.placeholder && (el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement)) el.placeholder = options.placeholder;
    if (options?.readonly && el instanceof HTMLInputElement) el.readOnly = options.readonly;
    if (options?.required && (el instanceof HTMLInputElement || el instanceof HTMLSelectElement || el instanceof HTMLTextAreaElement)) el.required = options.required;
    if (options?.minLength && (el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement)) el.minLength = options.minLength;
    if (options?.maxLength && (el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement)) el.maxLength = options.maxLength;
    if (options?.min && el instanceof HTMLInputElement) el.min = options.min;
    if (options?.max && el instanceof HTMLInputElement) el.max = options.max;

    if (children) {
        children.forEach(child => {
            if (child === null || child === undefined) return;
            if (typeof child === 'string') {
                el.appendChild(document.createTextNode(child));
            } else {
                el.appendChild(child);
            }
        });
    }
    return el;
}


// Reusable Action Button
interface ActionButtonProps {
    text: string;
    baseClass?: string; // e.g., 'bg-blue-500'
    variant?: 'primary' | 'secondary' | 'danger' | 'warning' | 'success' | 'info'; // For predefined styles
    onClick: (event: MouseEvent) => Promise<void> | void;
    icon?: string; // Optional icon HTML or class
    dataAction?: string;
    dataId?: string | number;
    disabled?: boolean;
}

export function createActionButton(props: ActionButtonProps): HTMLButtonElement {
    const button = createElement('button', {
        textContent: props.text,
        type: 'button'
    });

    let colorClasses = 'bg-gray-500 hover:bg-gray-600'; // Default
    if (props.baseClass) {
        colorClasses = props.baseClass;
    } else if (props.variant) {
        switch (props.variant) {
            case 'primary': colorClasses = 'bg-blue-500 hover:bg-blue-600'; break;
            case 'secondary': colorClasses = 'bg-gray-200 hover:bg-gray-300 text-gray-800'; break;
            case 'danger': colorClasses = 'bg-red-500 hover:bg-red-600'; break;
            case 'warning': colorClasses = 'bg-yellow-500 hover:bg-yellow-600 text-black'; break;
            case 'success': colorClasses = 'bg-green-500 hover:bg-green-600'; break;
            case 'info': colorClasses = 'bg-teal-500 hover:bg-teal-600'; break;
        }
    }
    
    button.className = `${colorClasses} text-white text-xs font-semibold py-1 px-2.5 rounded hover:opacity-80 transition-opacity disabled:opacity-50 disabled:cursor-not-allowed`;
    if (props.disabled) {
        button.disabled = true;
    }

    if (props.dataAction) button.dataset.action = props.dataAction;
    if (props.dataId !== undefined) button.dataset.id = props.dataId.toString();


    button.addEventListener('click', async (e) => {
        e.stopPropagation();
        if (button.disabled) return; // Prevent action if already disabled

        button.disabled = true;
        const originalText = button.textContent;
        button.textContent = '...'; // Loading indicator

        try {
            await props.onClick(e);
        } catch (error) {
            const actionText = props.dataAction || originalText || 'action';
            console.error(`Error performing action "${actionText}":`, error);
            showToast(`Failed to ${actionText.toLowerCase()}.`, 'error');
            button.textContent = originalText;
            button.disabled = false;
        }
        // Note: Re-enabling the button and restoring text on success should be handled
        // by the parent component logic (e.g., after a list re-renders or state updates)
        // unless the action is purely local and doesn't trigger a re-render.
        // If not :
        // if (button.disabled) { // If not re-enabled by parent logic
        //     button.textContent = originalText;
        //     button.disabled = false;
        // }
    });
    return button;
}


// Helper for input fields
interface InputFieldOptions {
    type?: string;
    placeholder?: string;
    required?: boolean;
    value?: string;
    minLength?: number;
    maxLength?: number;
    min?: string; // for type=number
    max?: string; // for type=number
    readonly?: boolean;
    inputClass?: string;
    labelClass?: string;
    wrapperClass?: string;
    pattern?: string;
    helpText?: string;
}
export function createInputField(id: string, labelText: string, options: InputFieldOptions = {}): HTMLDivElement {
    const fieldDiv = createElement('div', {
        className: options.wrapperClass || 'mb-4'
    });

    const label = createElement('label', {
        textContent: labelText,
        className: options.labelClass || 'block text-sm font-medium text-gray-700 mb-1'
    });
    label.htmlFor = id;

    const input = createElement('input', {
        type: options.type || 'text',
        id: id,
        name: id, // Good practice to have name attribute
        required: options.required,
        value: options.value || '',
        placeholder: options.placeholder,
        minLength: options.minLength,
        maxLength: options.maxLength,
        min: options.min,
        max: options.max,
        readonly: options.readonly,
        className: options.inputClass || 'w-full p-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500'
    });
    if (options.pattern) input.pattern = options.pattern;


    fieldDiv.appendChild(label);
    fieldDiv.appendChild(input);

    if (options.helpText) {
        const helpTextEl = createElement('p', {
            textContent: options.helpText,
            className: 'text-xs text-gray-500 mt-1'
        });
        fieldDiv.appendChild(helpTextEl);
    }
    
    return fieldDiv;
}

// Helper for select fields (from aliasFormPage)
export function createSelectField(id: string, labelText: string, optionValues: (string | {value: string, text: string})[], options: InputFieldOptions = {}): HTMLDivElement {
    const fieldDiv = createElement('div', {
        className: options.wrapperClass || 'mb-4'
    });

    const label = createElement('label', {
        textContent: labelText,
        className: options.labelClass || 'block text-sm font-medium text-gray-700 mb-1'
    });
    label.htmlFor = id;

    const select = createElement('select', {
        id: id,
        name: id,
        required: options.required,
        className: options.inputClass || 'w-full p-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500'
    });

    optionValues.forEach(opt => {
        const optionEl = document.createElement('option');
        if (typeof opt === 'string') {
            optionEl.value = opt;
            optionEl.textContent = opt;
        } else {
            optionEl.value = opt.value;
            optionEl.textContent = opt.text;
        }
        if (options.value === optionEl.value) {
            optionEl.selected = true;
        }
        select.appendChild(optionEl);
    });

    fieldDiv.appendChild(label);
    fieldDiv.appendChild(select);
     if (options.helpText) {
        const helpTextEl = createElement('p', {
            textContent: options.helpText,
            className: 'text-xs text-gray-500 mt-1'
        });
        fieldDiv.appendChild(helpTextEl);
    }
    return fieldDiv;
}// app/frontend/src/components/headerComponent.ts
// src/components/headerComponent.ts
import { User } from '../shared/schemas/usersSchemas.js';
import { navigateTo } from '../services/router.js'; // Assuming navigateTo handles data-link
import { logout } from '../services/authService.js';
import { showToast } from './toast.js';

interface HeaderProps {
	currentUser: User;
	// onLanguageChange?: () => void;
}

interface NavLink {
	href: string;
	text: string;
}

export function HeaderComponent(props: HeaderProps): HTMLElement {
	const { currentUser } = props;

	const headerContainer = document.createElement('div');
	headerContainer.className = 'flex justify-between items-center p-4 border-b border-gray-200 bg-white';

	// --- Left side: Language Button ---
	const leftSection = document.createElement('div');
	const langButton = document.createElement('button');
	langButton.className = 'bg-blue-500 text-white font-bold py-2 px-4 rounded-lg text-sm hover:bg-blue-600 transition-colors';
	langButton.textContent = 'ENG';
	// langButton.addEventListener('click', () => { /* ... */ });
	leftSection.appendChild(langButton);

	// --- Center: Navigation Links ---
	const centerSection = document.createElement('div');
	centerSection.className = 'flex-grow flex justify-center space-x-4 sm:space-x-6'; // flex-grow to push others, justify-center

	const navLinks: NavLink[] = [
		{ href: '/', text: 'Home' },
		{ href: '/game', text: 'Game' },
		{ href: '/dashboard', text: 'Dashboard' },
	];

	navLinks.forEach(linkInfo => {
		const linkElement = document.createElement('a');
		linkElement.href = linkInfo.href;
		linkElement.textContent = linkInfo.text;
		linkElement.className = 'text-gray-600 hover:text-blue-600 font-medium transition-colors px-2 py-1 text-sm sm:text-base';
		linkElement.setAttribute('data-link', '');
		centerSection.appendChild(linkElement);
	});

	// --- Right side: User Header (Avatar & Menu) ---
	const rightSection = document.createElement('div');
	const userHeader = document.createElement('div');
	userHeader.className = 'flex items-center space-x-4 relative';

	const avatarDisplayWrapper = document.createElement('div');
	avatarDisplayWrapper.className = 'bg-orange-400 p-2 rounded-lg flex items-center space-x-3 cursor-pointer select-none';

	const displayNameHeader = document.createElement('span');
	displayNameHeader.className = 'text-white font-semibold text-sm';
	displayNameHeader.textContent = currentUser.display_name || currentUser.username;

	const avatarHeader = document.createElement('img');
	avatarHeader.className = 'w-10 h-10 rounded-full object-cover border-2 border-white';
	const avatarFallbackName = currentUser.display_name || currentUser.username;
	avatarHeader.src = currentUser.avatar_url || `https://ui-avatars.com/api/?name=${encodeURIComponent(avatarFallbackName)}&background=0D8ABC&color=fff&size=128`;
	avatarHeader.alt = 'User Avatar';

	avatarDisplayWrapper.appendChild(displayNameHeader);
	avatarDisplayWrapper.appendChild(avatarHeader);

	const miniMenu = document.createElement('div');
	miniMenu.className = 'absolute right-0 mt-2 w-40 bg-white rounded-lg shadow-lg border border-gray-200 z-50 hidden flex-col';
	miniMenu.style.top = '110%';

	const settingsButton = document.createElement('a');
	settingsButton.href = '/profile';
	settingsButton.setAttribute('data-link', '');
	settingsButton.className = 'block px-4 py-2 text-gray-700 hover:bg-gray-100 rounded-t-lg';
	settingsButton.textContent = 'Settings';

	const logoutButtonEl = document.createElement('button');
	logoutButtonEl.className = 'block w-full text-left px-4 py-2 text-gray-700 hover:bg-gray-100 rounded-b-lg';
	logoutButtonEl.textContent = 'Logout';
	logoutButtonEl.addEventListener('click', async (e) => {
		e.stopPropagation();
		try {
			await logout();
			showToast('You have been logged out.', 'success');
		} catch (error) {
			showToast('Error logging out.', 'error');
		} finally {
			navigateTo('/login');
		}
	});

	miniMenu.appendChild(settingsButton);
	miniMenu.appendChild(logoutButtonEl);
	userHeader.appendChild(avatarDisplayWrapper);
	userHeader.appendChild(miniMenu);
	rightSection.appendChild(userHeader);


	// Menu open/close logic
	let menuOpen = false;
	const toggleMenu = (show: boolean) => {
		menuOpen = show;
		miniMenu.classList.toggle('hidden', !menuOpen);
	};

	avatarDisplayWrapper.addEventListener('click', (e) => {
		e.stopPropagation();
		toggleMenu(!menuOpen);
	});

	const globalClickListener = (event: MouseEvent) => {
		if (menuOpen && !userHeader.contains(event.target as Node)) {
			toggleMenu(false);
		}
	};
	document.addEventListener('click', globalClickListener);
	// Consider cleanup only if this component could be frequently removed/re-added or if multiple such components exist on one page.

	// Assemble the header sections
	headerContainer.appendChild(leftSection);
	headerContainer.appendChild(centerSection);
	headerContainer.appendChild(rightSection);

	return headerContainer;
}
// app/frontend/src/components/userList.ts
import { Friend, PendingFriendRequest } from '../shared/schemas/friendsSchemas.js';
import { User as ApiUser, UserOnlineStatus } from '../shared/schemas/usersSchemas.js';
import { createActionButton } from '../utils/domUtils.js';

export interface UserListProps {
	users: ApiUser[];
	friends: Friend[];
	sentRequests: PendingFriendRequest[];
	receivedRequests: PendingFriendRequest[];
	currentUserId: number;
	onSendRequest: (targetUserId: number) => Promise<void>;
	onCancelRequest: (friendshipId: number) => Promise<void>;
	onAcceptRequest: (friendshipId: number) => Promise<void>;
	onDeclineRequest: (friendshipId: number) => Promise<void>;
	onRemoveFriend?: (targetUserId: number) => Promise<void>; // Rendu optionnel
}

export function UserList(props: UserListProps): HTMLElement {
	const {
		users,
		friends,
		sentRequests,
		receivedRequests,
		currentUserId,
		onSendRequest,
		onCancelRequest,
		onAcceptRequest,
		onDeclineRequest
	} = props;

	const ul = document.createElement('ul');
	ul.className = 'space-y-4';

	const otherUsers = users.filter(user => user.id !== currentUserId);

	if (otherUsers.length === 0) {
		ul.innerHTML = '<li class="text-center text-gray-500 py-4">Aucun autre utilisateur √† afficher.</li>';
		return ul;
	}

	otherUsers.forEach(user => {
		const li = document.createElement('li');
		li.className = 'p-4 bg-white border border-gray-200 rounded-lg shadow-sm flex flex-col sm:flex-row justify-between items-start sm:items-center space-y-3 sm:space-y-0 hover:shadow-md transition-shadow duration-200';
		li.dataset.userId = user.id.toString();

		const userPrimaryInfoContainer = document.createElement('div');
		userPrimaryInfoContainer.className = 'flex items-center w-full sm:w-auto';

		const displayName = user.display_name || user.username;
		const avatarUrl = user.avatar_url;
		const status: UserOnlineStatus = user.status as UserOnlineStatus;
		const wins = user.wins ?? 0;
		const losses = user.losses ?? 0;

		const avatarSrc = avatarUrl || `https://ui-avatars.com/api/?name=${encodeURIComponent(displayName)}&background=random&color=fff&size=40`;

		let statusIndicatorClass = 'bg-gray-400'; // Offline par d√©faut
		let statusText = 'Offline';

		if (status === UserOnlineStatus.ONLINE) {
			statusIndicatorClass = 'bg-green-500';
			statusText = 'Online';
		} else if (status === UserOnlineStatus.IN_GAME) {
			statusIndicatorClass = 'bg-yellow-500';
			statusText = 'In Game';
		}

		userPrimaryInfoContainer.innerHTML = `
            <img src="${avatarSrc}" alt="${displayName}" class="w-12 h-12 rounded-full mr-4 object-cover">
            <div class="flex-grow">
                <div class="flex items-center mb-1">
                    <span class="inline-block w-3 h-3 ${statusIndicatorClass} rounded-full mr-2" title="${statusText}"></span>
                    <strong class="text-lg text-gray-700">${displayName}</strong>
                    <!-- Le (@username) a √©t√© enlev√© d'ici -->
                </div>
                <div class="text-xs text-gray-500">
                    <span>Wins: ${wins}</span> | <span>Losses: ${losses}</span>
                </div>
            </div>
        `;
		li.appendChild(userPrimaryInfoContainer);

		const actionContainer = document.createElement('div');
		actionContainer.className = 'flex flex-col items-end space-y-1 text-sm self-end sm:self-center pt-2 sm:pt-0 sm:ml-4';


		const friendshipStatus = document.createElement('span');
		friendshipStatus.className = 'text-xs italic text-gray-500 mb-1';

		let actionButton: HTMLButtonElement | null = null;
		let actionButtonsContainer: HTMLElement | null = null;

		const isFriend = friends.some(f => f.friend_id === user.id);
		const sentRequestToThisUser = sentRequests.find(r => r.receiver?.id === user.id);
		const receivedRequestFromThisUser = receivedRequests.find(r => r.requester?.id === user.id);

		if (isFriend) {
			friendshipStatus.textContent = 'Friends';
			friendshipStatus.className += ' text-green-600 font-semibold';
		} else if (sentRequestToThisUser) {
			friendshipStatus.textContent = 'Friend request sent';
			friendshipStatus.className += ' text-yellow-600';
			actionButton = createActionButton({
				text: 'Cancel Request',
				variant: 'warning', // 'bg-yellow-500 text-black',
				onClick: () => onCancelRequest(sentRequestToThisUser.friendship_id)
			});
		} else if (receivedRequestFromThisUser) {
			friendshipStatus.textContent = 'Request received';
			friendshipStatus.className += ' text-indigo-600';

			actionButtonsContainer = document.createElement('div');
			actionButtonsContainer.className = 'flex space-x-1'; // Mettre les boutons c√¥te √† c√¥te
			const acceptBtn = createActionButton({
				text: 'Accept',
				variant: 'success', // 'bg-green-500'
				onClick: () => onAcceptRequest(receivedRequestFromThisUser.friendship_id)
				});
			const declineBtn = createActionButton({
				text: 'Decline',
				variant: 'danger', // 'bg-red-500'
				onClick: () => onDeclineRequest(receivedRequestFromThisUser.friendship_id)
				});
			actionButtonsContainer.appendChild(acceptBtn);
			actionButtonsContainer.appendChild(declineBtn);
		} else {
			friendshipStatus.textContent = 'Not Friends'; // Statut par d√©faut si aucune des conditions
			actionButton = createActionButton({
				text: 'Inviter', // 'bg-blue-500'
				onClick: () => onSendRequest(user.id)
			});
		}

		actionContainer.prepend(friendshipStatus);

		if (actionButtonsContainer) {
			actionContainer.appendChild(actionButtonsContainer);
		} else if (actionButton) {
			actionContainer.appendChild(actionButton);
		}

		li.appendChild(actionContainer);

		ul.appendChild(li);
	});

	return ul;
}

// function createActionButton(text: string, baseClass: string, onClick: () => Promise<void>): HTMLButtonElement {
// 	const button = document.createElement('button');
// 	button.textContent = text;
// 	button.className = `${baseClass} text-white text-xs font-semibold py-1 px-2.5 rounded hover:opacity-80 transition-opacity disabled:opacity-50`;
// 	button.addEventListener('click', async (e) => {
// 		e.stopPropagation();
// 		button.disabled = true;
// 		const originalText = button.textContent;
// 		button.textContent = '...';
// 		try {
// 			await onClick();
// 		} catch (error) {
// 			const actionText = originalText || 'action';
// 			console.error(`Error performing action "${actionText}":`, error);
// 			alert(`Failed to ${actionText.toLowerCase()}.`);
// 			button.textContent = originalText;
// 			button.disabled = false;
// 		}
// 	});
// 	return button;
// }// app/frontend/src/components/friendsList.ts
// /components/friendsList.ts
import { Friend } from '../shared/schemas/friendsSchemas.js';
import { UserOnlineStatus } from '../shared/schemas/usersSchemas.js';
import { navigateTo } from '../services/router.js';
import { showCustomConfirm, showToast } from './toast.js';

interface FriendsListProps {
	friends: Friend[];
	onRemoveFriend: (friendshipId: number) => Promise<void>;
}

export function FriendsListComponent(props: FriendsListProps): HTMLElement {
	const { friends, onRemoveFriend } = props;

	const section = document.createElement('div');
	section.id = 'friends-list-section';
	section.className = 'mt-8 p-6 bg-white border border-gray-200 rounded-lg shadow-lg'; // Changed background for better contrast

	const title = document.createElement('h2');
	title.className = 'text-2xl font-semibold text-gray-800 mb-6';
	title.innerHTML = `Mes Amis (<span id="friends-count">${friends.length}</span>)`;

	const ul = document.createElement('ul');
	ul.id = 'friends-list';
	ul.className = 'space-y-4';

	if (!friends.length) {
		ul.innerHTML = `<li class="text-gray-500 italic p-4 text-center">Vous n'avez pas encore d'amis.</li>`;
	} else {
		friends.forEach(friend => {
			const displayName = friend.friend_display_name;
			const avatarUrl = friend.friend_avatar_url;
			const friendId = friend.friend_id;
			const friendshipId = friend.friendship_id;
			const status = friend.friend_online_status;
			const wins = friend.friend_wins ?? 0;
			const losses = friend.friend_losses ?? 0;

			// const avatarFallbackName = displayName.charAt(0).toUpperCase();
			const avatar = avatarUrl || `https://ui-avatars.com/api/?name=${encodeURIComponent(displayName)}&background=random&color=fff&size=40`;

			let statusIndicatorClass = 'bg-gray-400';
			let statusText = 'Offline';

			if (status === UserOnlineStatus.ONLINE) {
				statusIndicatorClass = 'bg-green-500';
				statusText = 'Online';
			} else if (status === UserOnlineStatus.IN_GAME) {
				statusIndicatorClass = 'bg-yellow-500';
				statusText = 'In Game';
			}

			const li = document.createElement('li');
			li.dataset.friendId = friendId.toString();
			li.dataset.friendshipId = friendshipId.toString();
			li.className = 'p-4 bg-gray-50 border border-gray-200 rounded-lg shadow-sm flex flex-col sm:flex-row justify-between items-start sm:items-center space-y-3 sm:space-y-0';
			li.innerHTML = `
                <div class="flex items-center w-full sm:w-auto">
                    <img src="${avatar}" alt="${displayName}" class="w-12 h-12 rounded-full mr-4 object-cover">
                    <div class="flex-grow">
                        <div class="flex items-center mb-1">
                            <span class="inline-block w-3 h-3 ${statusIndicatorClass} rounded-full mr-2" title="${statusText}"></span>
                            <strong class="text-lg text-gray-700">${displayName}</strong>
                        </div>
                        <div class="text-xs text-gray-500">
                            <span>Wins: ${wins}</span> | <span>Losses: ${losses}</span>
                        </div>
                    </div>
                </div>
                <div class="flex space-x-2 self-end sm:self-center pt-2 sm:pt-0">
                    <button data-action="view-profile" data-user-id="${friendId}" class="text-xs bg-blue-500 hover:bg-blue-600 text-white font-semibold py-1.5 px-3 rounded-md">Profil</button>
                    <button data-action="remove-friend" data-friendship-id="${friendshipId}" class="text-xs bg-red-500 hover:bg-red-600 text-white font-semibold py-1.5 px-3 rounded-md">Supprimer</button>
                </div>
            `;
			ul.appendChild(li);
		});
	}

	section.appendChild(title);
	section.appendChild(ul);

	ul.addEventListener('click', async (event) => {
		const target = event.target as HTMLElement;
		const button = target.closest('button[data-action]') as HTMLButtonElement | null;
		if (!button) return;

		const action = button.dataset.action;
		if (action === 'view-profile') {
			const userIdToView = button.dataset.userId; // Get userId from button
			if (userIdToView) {
				navigateTo(`/profile/${userIdToView}`);
			}
		} else if (action === 'remove-friend') {
			const friendshipIdToRemove = button.dataset.friendshipId; // Get friendshipId from button
			if (friendshipIdToRemove) {
				// Utilisation de la nouvelle bo√Æte de dialogue personnalis√©e
				const confirmed = await showCustomConfirm(
					'√ätes-vous s√ªr de vouloir supprimer cet ami de votre liste ? Cette action est irr√©versible.',
					'Supprimer l\'ami' // Titre optionnel
				);

				if (confirmed) {
					button.disabled = true;
					button.textContent = '...';
					try {
						await onRemoveFriend(parseInt(friendshipIdToRemove, 10));
						// showToast('Ami supprim√© avec succ√®s.', 'success'); // Exemple
					} catch (error: any) {
						console.error('Erreur lors de la suppression de l\'ami:', error);
						showToast(`Erreur: ${error.message || 'Impossible de supprimer l\'ami.'}`, 'error');
						button.disabled = false;
						button.textContent = 'Supprimer';
					}
				}
			}
			// if (friendshipIdToRemove && confirm(`√ätes-vous s√ªr de vouloir supprimer cet ami ?`)) {
			//     button.disabled = true;
			//     button.textContent = '...';
			//     try {
			//         await onRemoveFriend(parseInt(friendshipIdToRemove, 10));
			//         // button.closest('li')?.remove();
			//     } catch (error: any) {
			//         console.error('Erreur lors de la suppression de l\'ami:', error);
			//         alert(`Erreur: ${error.message || 'Impossible de supprimer l\'ami.'}`);
			//         button.disabled = false;
			//         button.textContent = 'Supprimer';
			//     }
			// }
		}
	});

	return section;
}
// app/frontend/src/components/settingsForm.ts
// /components/profileForm.ts
import { User, UpdateUserPayload } from '../shared/schemas/usersSchemas.js'; // S'assurer que ApiResult est import√©
import { ApiResult } from '../utils/types.js'; // S'assurer que ApiResult est import√©

interface ProfileFormProps {
	user: User;
	onProfileUpdate: (payload: UpdateUserPayload) => Promise<ApiResult>;
}

export function SettingsForm(props: ProfileFormProps): HTMLElement {
	const { user, onProfileUpdate } = props;

	const formElement = document.createElement('form');
	formElement.id = 'profile-form-component'; // ID unique
	formElement.innerHTML = `
        <!-- Message d'√©tat -->
        <div id="profile-message" class="mb-4 text-center text-sm min-h-[1.25rem]"></div>

        <!-- Champ Username (souvent non modifiable) -->
        <div class="mb-4">
            <label for="username" class="block text-gray-700 text-sm font-bold mb-2">Nom d'utilisateur</label>
            <input type="text" id="username" name="username" readonly
                   value="${user.username}"
                   class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 bg-gray-200 cursor-not-allowed leading-tight focus:outline-none focus:shadow-outline">
            <p class="text-xs text-gray-500 mt-1">Le nom d'utilisateur ne peut pas √™tre modifi√©.</p>
        </div>

        <!-- Champ Email -->
        <div class="mb-4">
            <label for="email" class="block text-gray-700 text-sm font-bold mb-2">Adresse Email</label>
            <input type="email" id="email" name="email" required
                   value="${user.email || ''}"
                   placeholder="Votre adresse email"
                   class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
        </div>

        <!-- Champ Display Name -->
        <div class="mb-4">
            <label for="display_name" class="block text-gray-700 text-sm font-bold mb-2">Nom Affich√©</label>
            <input type="text" id="display_name" name="display_name" required
                   value="${user.display_name || ''}"
                   placeholder="Comment voulez-vous √™tre appel√© ?"
                   class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
        </div>

        <!-- Champ Avatar URL (Optionnel) -->
        <div class="mb-6">
            <label for="avatar_url" class="block text-gray-700 text-sm font-bold mb-2">URL de l'Avatar (Optionnel)</label>
            <input type="url" id="avatar_url" name="avatar_url"
                   value="${user.avatar_url || ''}"
                   placeholder="https://example.com/avatar.png"
                   class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
             <p class="text-xs text-gray-500 mt-1">Laissez vide si vous n'avez pas d'avatar.</p>
        </div>

        <div class="flex items-center justify-between mt-6 border-t pt-6">
            <button type="submit" id="save-profile-button"
                    class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline w-full sm:w-auto transition duration-300 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed">
                Enregistrer les modifications
            </button>
            <!-- Le lien de retour est mieux g√©r√© par la page parente -->
        </div>
    `;

	const emailInput = formElement.querySelector('#email') as HTMLInputElement;
	const displayNameInput = formElement.querySelector('#display_name') as HTMLInputElement;
	const avatarUrlInput = formElement.querySelector('#avatar_url') as HTMLInputElement;
	const messageDiv = formElement.querySelector('#profile-message') as HTMLDivElement;
	const saveButton = formElement.querySelector('#save-profile-button') as HTMLButtonElement;

	formElement.addEventListener('submit', async (event) => {
		event.preventDefault();
		messageDiv.textContent = 'Sauvegarde en cours...';
		messageDiv.className = 'mb-4 text-center text-sm text-gray-600 min-h-[1.25rem]';
		saveButton.disabled = true;
		saveButton.textContent = 'Sauvegarde...';

		const updatedEmail = emailInput.value.trim();
		const updatedDisplayName = displayNameInput.value.trim();
		const updatedAvatarUrl = avatarUrlInput.value.trim();

		if (!updatedEmail || !updatedDisplayName) {
			messageDiv.textContent = 'Veuillez remplir les champs Email et Nom affich√©.';
			messageDiv.className = 'mb-4 text-center text-sm text-red-600 font-semibold min-h-[1.25rem]';
			saveButton.disabled = false;
			saveButton.textContent = 'Enregistrer les modifications';
			return;
		}

		const payload: UpdateUserPayload = {
			email: updatedEmail,
			display_name: updatedDisplayName,
			avatar_url: updatedAvatarUrl,
		};

		const result = await onProfileUpdate(payload);

		saveButton.disabled = false;
		saveButton.textContent = 'Enregistrer les modifications';

		if (result.success) {
			messageDiv.textContent = 'Profil mis √† jour avec succ√®s !';
			messageDiv.className = 'mb-4 text-center text-sm text-green-600 font-semibold min-h-[1.25rem]';

			// Mettre √† jour les valeurs des champs avec les donn√©es retourn√©es par l'API
			// Cela est important si le backend effectue une sanitisation ou une transformation
			emailInput.value = result.data.user.email;
			displayNameInput.value = result.data.user.display_name;
			avatarUrlInput.value = result.data.user.avatar_url || '';

			setTimeout(() => {
				if (messageDiv.textContent === 'Profil mis √† jour avec succ√®s !') {
					messageDiv.textContent = ''; // Effacer le message de succ√®s
				}
			}, 3000);
		} else {
			messageDiv.textContent = `Erreur: ${result.error || 'Une erreur inconnue est survenue.'}`;
			messageDiv.className = 'mb-4 text-center text-sm text-red-600 font-semibold min-h-[1.25rem]';
		}
	});

	return formElement;
}
// app/frontend/src/components/gamePage.ts
import { navigateTo } from '../services/router.js';
import { handleOnlineGame } from '../services/initOnlineGame.js';
import { HeaderComponent } from '../components/headerComponent.js';
import { User } from '../shared/schemas/usersSchemas.js';
import { getUserDataFromStorage } from '../services/authService.js';
import { showToast } from './toast.js';

export type GameMode = 'local' | 'remote';

export function GamePage(): HTMLElement {
	//ajout arthur -> on check tout de suite si l'utilisateur est connect√©
	const authData = getUserDataFromStorage();

	// Le HeaderComponent attend un currentUser.
	// Si l'utilisateur n'est pas connect√©, redirigez-le ou affichez un √©tat alternatif.
	if (!authData) {
		console.warn("GamePage: User not authenticated, redirecting to login.");
		navigateTo('/login');
		// Retourner un √©l√©ment vide pour √©viter les erreurs de rendu pendant la redirection
		return document.createElement('div');
	}
	const currentUser: User = authData as User;

	// --- Main Container ---
	const pageWrapper = document.createElement('div');
	pageWrapper.className = 'flex flex-col min-h-screen'; // Assure que la page prend toute la hauteur

	// --- Header ---
	const headerElement = HeaderComponent({ currentUser });
	pageWrapper.appendChild(headerElement);

    // --- Game Page Content ---
    const gameContentContainer: HTMLDivElement = document.createElement('div');
	gameContentContainer.className = 'bg-white flex justify-center items-center min-h-screen p-8';    
    
    const formContainer: HTMLDivElement = document.createElement('div');
    formContainer.className = 'bg-white bg-opacity-90 backdrop-filter backdrop-blur-lg rounded-xl shadow-2xl p-8 max-w-md w-full';   

    // --- Title ---
    const title: HTMLHeadElement = document.createElement('h2');
    title.textContent = 'Welcome to the Game';
    title.className = 'text-3xl font-bold mb-6 text-center text-gray-800';
    
    // --- Buttons ---
    const buttonsContainer: HTMLDivElement = document.createElement('div');
    buttonsContainer.id = 'buttons-container';
    buttonsContainer.className = 'flex flex-col items-center';
    
    // const localGameButton: HTMLButtonElement = document.createElement('button');
    // localGameButton.id = 'local-button';
    // localGameButton.className = 'bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline w-full mb-4 transition duration-300 ease-in-out';
    // localGameButton.textContent = 'Local game';
    
    const onlineGameButton: HTMLButtonElement  = document.createElement('button');
    onlineGameButton.id = 'online-button';// fastify.get('/match/:matchId', { schema: matchSchemas.idOnly}, getMatchIdHandler);
   
    onlineGameButton.className = 'bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline w-full mb-4 transition duration-300 ease-in-out';
    onlineGameButton.textContent = 'Online game';
    
    // TODO (not finished at all)
    const customSettingsButton: HTMLButtonElement  = document.createElement('button');
    customSettingsButton.id = 'custom-settings-button';
    customSettingsButton.className = 'bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline w-full transition duration-300 ease-in-out';
    customSettingsButton.textContent = 'Custom Settings';
    
    buttonsContainer.append(onlineGameButton, customSettingsButton); 
    
    // --- Le pied du page ---
    const footer: HTMLDivElement = document.createElement('div');
    footer.className = 'mt-6 text-center';
    
    const homeLink: HTMLAnchorElement = document.createElement('a');
    homeLink.href = '/'; // lien vers la page d'accueil
    homeLink.textContent = 'Back to Home';
    homeLink.setAttribute('data-link', ''); // intercepte par le router dans le main.ts
    homeLink.className = 'text-blue-600 hover:text-blue-800 text-sm';
    
    footer.appendChild(homeLink);
    
    // --- Ajout des √©l√©ments au conteneur principal ---
    formContainer.append(title, buttonsContainer, footer);
    gameContentContainer.appendChild(formContainer);
    pageWrapper.appendChild(gameContentContainer);
    
    // --- Event: Online game button clicked ---
    onlineGameButton.addEventListener('click', async () => { 
        
        try {
            const userRes = await fetch('/api/users/me');
            if (!userRes.ok) {
                showToast('You must be logged in to play online', 'error');
                return;
            }
            const userData = await userRes.json();
            const display_name: string = userData.display_name;
            const userId: string = userData.id;

            sessionStorage.setItem('gameMode', 'remote');

            await handleOnlineGame(display_name, userId, buttonsContainer, onlineGameButton, title);

        } catch (err: unknown) {
            console.log(`Failed to fetch from user`);
            showToast('Something went wrong. Please try again later.', 'error');
            throw err;
        }
    });
        // return container;
        return pageWrapper; // ajout arthur
}

// app/frontend/src/components/friendRequests.ts
// /components/friendRequests.ts
import { PendingFriendRequest } from '../shared/schemas/friendsSchemas.js';

interface FriendRequestsProps {
	receivedRequests: PendingFriendRequest[];
	sentRequests: PendingFriendRequest[];
	onAcceptRequest: (friendshipId: number) => Promise<void>;
	onDeclineRequest: (friendshipId: number) => Promise<void>;
	onCancelRequest: (friendshipId: number) => Promise<void>;
}

export function FriendRequestsComponent(props: FriendRequestsProps): HTMLElement {
	const { receivedRequests, sentRequests, onAcceptRequest, onDeclineRequest, onCancelRequest } = props;

	const section = document.createElement('div');
	section.id = 'friend-requests-section';
	section.className = 'mt-8 p-6 bg-indigo-50 border border-indigo-200 rounded-lg shadow-sm';
	section.innerHTML = `
        <h2 class="text-2xl font-semibold text-indigo-800 mb-4">Demandes d'amis</h2>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
                <h3 class="text-xl font-medium text-indigo-700 mb-3">Re√ßues (<span id="received-requests-count">${receivedRequests.length}</span>)</h3>
                <ul id="received-requests-list" class="space-y-3">
                    ${renderReceivedItems(receivedRequests)}
                </ul>
            </div>
            <div>
                <h3 class="text-xl font-medium text-indigo-700 mb-3">Envoy√©es (<span id="sent-requests-count">${sentRequests.length}</span>)</h3>
                <ul id="sent-requests-list" class="space-y-3">
                    ${renderSentItems(sentRequests)}
                </ul>
            </div>
        </div>
    `;

	// Gestionnaire d'√©v√©nements unifi√© pour les demandes d'amis
	section.addEventListener('click', async (event) => {
		const target = event.target as HTMLElement;
		if (target.tagName !== 'BUTTON' || !target.dataset.action) return;

		const button = target as HTMLButtonElement;
		const listItem = target.closest('li[data-friendship-id]') as HTMLLIElement;
		if (!listItem) return;

		const friendshipId = parseInt(listItem.dataset.friendshipId || '', 10);
		if (isNaN(friendshipId)) return;

		const action = target.dataset.action;
		button.disabled = true;
		button.textContent = '...';

		try {
			if (action === 'accept') {
				await onAcceptRequest(friendshipId);
			} else if (action === 'decline') {
				await onDeclineRequest(friendshipId);
			} else if (action === 'cancel') {
				await onCancelRequest(friendshipId);
			}
		} catch (error: any) {
			console.error(`Erreur lors de l'action '${action}':`, error);
			alert(`Erreur: ${error.message || 'Une erreur est survenue.'}`);
			button.disabled = false; // Restaurer le bouton en cas d'erreur
			button.textContent = action.charAt(0).toUpperCase() + action.slice(1); // Restaurer le texte original
		}
	});

	return section;
}

// Fonctions utilitaires de rendu (pourrait √™tre dans le composant ou s√©par√©es)
function renderReceivedItems(requests: PendingFriendRequest[]): string {
	if (!requests.length) {
		return `<li class="text-gray-500 italic">Aucune demande re√ßue.</li>`;
	}
	return requests.map(req => `
        <li data-friendship-id="${req.friendship_id}" class="p-3 bg-white border border-gray-200 rounded-md shadow-sm flex justify-between items-center">
            <div>
                <strong class="text-indigo-600">${req.requester?.display_name || req.requester?.username}</strong>
                <span class="text-xs text-gray-500 block">(${req.requester?.username})</span>
            </div>
            <div>
                <button data-action="accept" class="text-xs bg-green-500 hover:bg-green-600 text-white font-semibold py-1 px-2 rounded mr-1">Accepter</button>
                <button data-action="decline" class="text-xs bg-red-500 hover:bg-red-600 text-white font-semibold py-1 px-2 rounded">Refuser</button>
            </div>
        </li>
    `).join('');
}

function renderSentItems(requests: PendingFriendRequest[]): string {
	if (!requests.length) {
		return `<li class="text-gray-500 italic">Aucune demande envoy√©e.</li>`;
	}
	return requests.map(req => `
        <li data-friendship-id="${req.friendship_id}" class="p-3 bg-white border border-gray-200 rounded-md shadow-sm flex justify-between items-center">
             <div>
                <strong class="text-indigo-600">${req.receiver?.display_name || req.receiver?.username}</strong>
                 <span class="text-xs text-gray-500 block">(${req.receiver?.username})</span>
            </div>
            <button data-action="cancel" class="text-xs bg-yellow-500 hover:bg-yellow-600 text-black font-semibold py-1 px-2 rounded">Annuler</button>
        </li>
    `).join('');
}
// app/frontend/src/components/gameResults.ts
import { cleanupSocket } from "../services/initOnlineGame.js";
import { navigateTo } from "../services/router.js";
import socket from '../services/socket.js';

export function showGameResult(player1: string, player2: string, score1: number, score2: number, url1: string, url2: string) {
	const modal = document.createElement('div');
	modal.className = 'fixed inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm';

	const content = document.createElement('div');
	content.className = 'bg-white/90 backdrop-blur-md rounded-2xl shadow-2xl p-6 w-[90%] max-w-lg text-center border border-gray-300';

	// Titre
	const title = document.createElement('h2');
	title.className = 'text-3xl font-bold text-gray-800 mb-6';
	title.textContent = 'üèì Match Finished';

	// Container des joueurs
	const playersContainer = document.createElement('div');
	playersContainer.className = 'flex justify-between items-center gap-4 mb-6';

	// Joueur 1
	const player1Container = document.createElement('div');
	player1Container.className = 'flex flex-col items-center flex-1';

	const img1 = document.createElement('img');
    // TODO: fetch a la base de donne d'Arthur
	img1.src = url1;
	img1.className = 'w-20 h-20 object-cover rounded-full mb-2 border-4 border-blue-500 shadow';

	const name1 = document.createElement('p');
	name1.className = 'font-semibold text-lg text-gray-800';
	name1.textContent = player1;

	const scoreText1 = document.createElement('p');
	scoreText1.className = 'text-2xl font-bold text-blue-600';
	scoreText1.textContent = String(score1);

	player1Container.appendChild(img1);
	player1Container.appendChild(name1);
	player1Container.appendChild(scoreText1);

	// "vs" texte
	const vsText = document.createElement('span');
	vsText.className = 'text-3xl font-bold text-gray-700';
	vsText.textContent = 'vs';

	// Joueur 2
	const player2Container = document.createElement('div');
	player2Container.className = 'flex flex-col items-center flex-1';

	const img2 = document.createElement('img');
	img2.src = url2;
	img2.className = 'w-20 h-20 object-cover rounded-full mb-2 border-4 border-red-500 shadow';

	const name2 = document.createElement('p');
	name2.className = 'font-semibold text-lg text-gray-800';
	name2.textContent = player2;

	const scoreText2 = document.createElement('p');
	scoreText2.className = 'text-2xl font-bold text-red-600';
	scoreText2.textContent = String(score2);

	player2Container.appendChild(img2);
	player2Container.appendChild(name2);
	player2Container.appendChild(scoreText2);

	// Bouton retour au lobby
	const closeButton = document.createElement('button');
	closeButton.id = 'close-modal';
	closeButton.className = 'mt-4 px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-xl shadow transition';
	closeButton.textContent = 'Return to Lobby';

	// Assemble tout
	playersContainer.appendChild(player1Container);
	playersContainer.appendChild(vsText);
	playersContainer.appendChild(player2Container);

	content.appendChild(title);
	content.appendChild(playersContainer);
	content.appendChild(closeButton);
	modal.appendChild(content);
	document.body.appendChild(modal);

	// --- Event: Close bouton
	closeButton.addEventListener('click', () => {
		modal.remove();
		cleanupSocket(socket);
		sessionStorage.clear();
		navigateTo('/game');
	});
}
// app/frontend/src/components/matchHistoryComponent.ts
import { fetchUserDetails } from '../services/authService.js';
import { fetchMatchHistoryForUser } from '../services/authService.js';

export interface MatchHistoryComponentProps {
	userId: number; // ID de l'utilisateur dont on affiche l'historique
}

export async function MatchHistoryComponent(props: MatchHistoryComponentProps): Promise<HTMLElement> {
	const { userId: profiledUserId } = props;

	const el = document.createElement('div');
	el.className = 'p-4';
	el.innerHTML = `<h3 class="text-xl font-semibold mb-4 text-gray-800">Historique des Matchs</h3>`;

	const loadingMessage = document.createElement('p');
	loadingMessage.className = 'text-gray-500 italic';
	loadingMessage.textContent = 'Chargement de l\'historique des matchs...';
	el.appendChild(loadingMessage);

	try {
		const matches = await fetchMatchHistoryForUser(profiledUserId);
		loadingMessage.remove();

		if (!matches || matches.length === 0) {
			el.innerHTML += '<p class="text-gray-500">Aucun match trouv√© pour cet utilisateur.</p>';
			return el;
		}

		const opponentsDetailsCache: { [key: number]: { display_name: string } } = {};
		const list = document.createElement('ul');
		list.className = 'space-y-3';

		for (const match of matches) {
			let opponentId: number;
			let profiledUserScore: number;
			let opponentScore: number;
			let opponentDisplayName = 'Adversaire Inconnu';

			if (match.player1_id === profiledUserId) {
				opponentId = match.player2_id;
				profiledUserScore = match.player1_score;
				opponentScore = match.player2_score;
			} else if (match.player2_id === profiledUserId) {
				opponentId = match.player1_id;
				profiledUserScore = match.player2_score;
				opponentScore = match.player1_score;
			} else {
				console.warn("Match ne semble pas impliquer l'utilisateur profil√©:", match);
				continue;
			}
			
			if (!opponentsDetailsCache[opponentId]) {
				try {
					const opponentUser = await fetchUserDetails(opponentId);
					opponentsDetailsCache[opponentId] = { display_name: opponentUser?.display_name || `Joueur ${opponentId}` };
				} catch (e) {
					console.error(`Impossible de r√©cup√©rer les d√©tails pour l'utilisateur ${opponentId}`, e);
					opponentsDetailsCache[opponentId] = { display_name: `Joueur ${opponentId}` };
				}
			}
			opponentDisplayName = opponentsDetailsCache[opponentId].display_name;
			
			const resultText = match.winner_id === profiledUserId ? 'Victoire' : (match.winner_id ? 'D√©faite' : '√âgalit√©/Annul√©');
			const resultColor = match.winner_id === profiledUserId ? 'text-green-600' : (match.winner_id ? 'text-red-600' : 'text-gray-600');

			const item = document.createElement('li');
			item.className = 'p-3 bg-gray-100 border border-gray-200 rounded-lg shadow-sm hover:shadow-md transition-shadow';
			item.innerHTML = `
                <div class="flex justify-between items-center mb-1">
                    <span class="font-medium text-gray-700">Contre : ${opponentDisplayName}</span>
                    <span class="font-semibold ${resultColor}">${resultText}</span>
                </div>
                <div class="text-sm text-gray-600">
                    Score : ${profiledUserScore} - ${opponentScore}
                    <span class="mx-1">|</span>
                    Type : ${match.win_type}
                    <span class="mx-1">|</span>
                    Date : ${new Date(match.created_at).toLocaleDateString()}
                </div>
            `;
			list.appendChild(item);
		}
		el.appendChild(list);

	} catch (error) {
		console.error("Erreur lors du rendu de l'historique des matchs:", error);
		loadingMessage.textContent = `Erreur lors du chargement de l'historique des matchs: ${(error as Error).message}`;
		loadingMessage.classList.remove('text-gray-500', 'italic');
		loadingMessage.classList.add('text-red-500');
	}

	return el;
}// app/frontend/src/components/aliasFormPage.ts
import { navigateTo } from "../services/router.js";
import { initLocalGame } from "../services/initLocalGame.js";
// import { createInputField, createInputField } from "../utils/domUtils.js";

export function promptAliasForm(): HTMLDivElement {

    // --- Main Container ---
    const container: HTMLDivElement = document.createElement('div');
	container.className = 'bg-white flex justify-center items-center min-h-screen p-8';

    const formContainer: HTMLDivElement = document.createElement('div');
    formContainer.className = 'bg-white bg-opacity-90 backdrop-filter backdrop-blur-lg rounded-xl shadow-2xl p-8 max-w-md w-full';

    // --- Title ---
    const title: HTMLHeadingElement = document.createElement('h2');
    title.textContent = 'Select Game Mode';
    title.className = 'text-3xl font-bold mb-6 text-center text-gray-800';

    // --- Input form ---
    const form: HTMLFormElement = document.createElement('form');
    form.className = 'space-y-6';

    const gameModeField = createSelectField('gameMode', 'Game Mode', ['1v1', 'Tournament']);
    const dynamicInputs = document.createElement('div');

    // --- Buttons ---
    const buttonsContainer: HTMLDivElement = document.createElement('div');
    buttonsContainer.id = 'buttons-container';
    buttonsContainer.className = 'flex justify-end space-x-4';

    const cancelButton: HTMLButtonElement = document.createElement('button');
    cancelButton.type = 'button';
    cancelButton.id = 'cancel-button';
    cancelButton.textContent = 'Cancel';
    cancelButton.className = 'bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 px-4 rounded transition duration-200';

    const submitButton: HTMLButtonElement = document.createElement('button');
    submitButton.id = 'submit-button';
    submitButton.textContent = 'Start';
    submitButton.className = 'bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition duration-200';

    buttonsContainer.append(cancelButton, submitButton);
    
    // --- Le pied de page ---
    const footer: HTMLDivElement = document.createElement('div');
    footer.className = 'mt-6 text-center';

    const homeLink: HTMLAnchorElement = document.createElement('a');
    homeLink.href = '/'; // lien vers la page d'accueil
    homeLink.textContent = 'Back to Home';
    homeLink.setAttribute('data-link', ''); // intercepte par le router dans le main.ts
    homeLink.className = 'text-blue-600 hover:text-blue-800 text-sm';

    // --- Ajout des √©l√©ments au conteneur principal ---
    footer.appendChild(homeLink);
    form.append(gameModeField, dynamicInputs, buttonsContainer);
    formContainer.append(title, form, footer);
    container.appendChild(formContainer);

    // --- Event: Cancel button clicked
    cancelButton.addEventListener('click', async () => {
        // need to abort the fetch ?
        navigateTo('/game');
    });
    
    // --- Input depends on gameMode
    const selectElement: HTMLSelectElement = (gameModeField.querySelector('select') as HTMLSelectElement);
    selectElement.addEventListener('change', (e) => {
        const value = (e.target as HTMLSelectElement).value;
        dynamicInputs.innerHTML = ''; // reset a chaque changement

        if (value === '1v1') {
            dynamicInputs.append(
                createInputField('alias1', 'Player1'),
                createInputField('alias2', 'Player2')
            );
        } else if (value === 'Tournament' || value === 'Battle Royale') {
            const countField = createInputField('playerCount', 'How many players?');
            const inputElement = countField.querySelector('input') as HTMLInputElement;
            inputElement.placeholder = 'Enter a number between 3 and 10';
            
            dynamicInputs.append(countField);

            // generate as many inputs as recieved in countField
            const aliasFields = document.createElement('div');
            dynamicInputs.append(aliasFields);

            inputElement.type = 'number';
            inputElement.min = '3';
            inputElement.max = '10';

            inputElement.addEventListener('input', () => {
                aliasFields.innerHTML = ''; // reset a chaque changement
                const count: number = parseInt(inputElement.value);
                if (isNaN(count) || count < 3 || count > 10) return;

                for (let i = 1; i <= count; i++) {
                    const field = createInputField(`alias${i}`, `Player ${i}`);
                    field.classList.add('animate-fade-in');
                    aliasFields.appendChild(field);
                }
            });
        }
    });

    // diffuser l'event 'change'
    selectElement.dispatchEvent(new Event('change'));

    // --- Event: Submit form event triggered
    form.addEventListener('submit', async (event) => {
        event.preventDefault(); // prevents the page from refreshing
        await initLocalGame(form);
    });
    
    return container;
}


// -- Helper function for input
function createInputField(id: string, labelText: string): HTMLDivElement {
    const fieldDiv = document.createElement('div');

    const label = document.createElement('label');
    label.htmlFor = id;
    label.textContent = labelText;
    label.className = 'block text-sm font-medium text-gray-700 mb-1';

    const input = document.createElement('input');
    input.type = 'text';
    input.id = id;
    input.required = true;
    input.className = 'w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500';

    fieldDiv.append(label, input);
    
    return fieldDiv;
}

// --- Helper function for game mode (menu delurant avec 3 options)
function createSelectField(id: string, labelText: string, options: string[]): HTMLDivElement {
    const fieldDiv = document.createElement('div');

    const label = document.createElement('label');
    label.htmlFor = id;
    label.textContent = labelText;
    label.className = 'block text-sm font-medium text-gray-700 mb-1';

    const select = document.createElement('select');
    select.id = id;
    select.required = true;
    select.className = 'w-full p-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500';

    for (const optionValue of options) {
        const option = document.createElement('option');
        option.value = optionValue;
        option.textContent = optionValue;
        select.appendChild(option);
    }

    fieldDiv.append(label, select);
    return fieldDiv;
}
// app/frontend/src/components/countdown.ts
export function initCountdown(container: HTMLDivElement): Promise<void> {
	return new Promise((resolve) => {
		const countdownIsDone = sessionStorage.getItem('countdown') === 'true';

		if (!countdownIsDone) {
			let countdownValue = 3;
			container.textContent = `Start in ${countdownValue}...`;

			const interval = setInterval(() => {
				countdownValue--;

				if (countdownValue > 0) {
					container.textContent = `Start in ${countdownValue}...`;
				} else {
					clearInterval(interval);
					container.remove();
					sessionStorage.setItem('countdown', 'true');
					resolve();
				}
			}, 1000);
		} else {
			container.remove();
			resolve();
		}
	});
}
// app/frontend/src/components/loginForm.ts
// /components/loginForm.ts
import { LoginRequestBody } from '../shared/schemas/usersSchemas.js';
import { ApiResult } from '../utils/types.js';

interface LoginFormProps {
	onLoginAttempt: (credentials: LoginRequestBody) => Promise<ApiResult>;
	onLoginSuccess: (userData: any) => void; // Callback pour informer la page du succ√®s
}

export function LoginForm(props: LoginFormProps): HTMLElement {
	const { onLoginAttempt, onLoginSuccess } = props;

	const formWrapper = document.createElement('div');
	// Pas besoin de classes sp√©cifiques ici si elles sont d√©j√† sur formContainer dans la page

	formWrapper.innerHTML = `
        <form id="login-form-component"> <!-- ID unique pour ce composant -->
            <div class="mb-4">
                <label for="identifier" class="block text-gray-700 text-sm font-bold mb-2">Username or Email</label>
                <input type="text" id="identifier" name="identifier" required placeholder="Enter your username or email"
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
            </div>
            <div class="mb-6">
                <label for="password" class="block text-gray-700 text-sm font-bold mb-2">Password</label>
                <input type="password" id="password" name="password" required
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:shadow-outline">
            </div>
            <div class="flex items-center justify-between">
                <button type="submit" id="login-button"
                        class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline w-full transition duration-300 ease-in-out">
                    Sign In
                </button>
            </div>
        </form>
        <div id="login-message-component" class="mt-4 text-center text-sm"></div>
    `;

	const form = formWrapper.querySelector('#login-form-component') as HTMLFormElement;
	const identifierInput = formWrapper.querySelector('#identifier') as HTMLInputElement;
	const passwordInput = formWrapper.querySelector('#password') as HTMLInputElement;
	const messageDiv = formWrapper.querySelector('#login-message-component') as HTMLDivElement;
	const loginButton = formWrapper.querySelector('#login-button') as HTMLButtonElement;

	form.addEventListener('submit', async (event) => {
		event.preventDefault();
		messageDiv.textContent = 'Attempting login...';
		messageDiv.className = 'mt-4 text-center text-sm text-gray-600';
		loginButton.disabled = true;
		loginButton.textContent = 'Signing In...';

		const identifier = identifierInput.value.trim();
		const password = passwordInput.value;

		if (!identifier || !password) {
			messageDiv.textContent = 'Please enter both username/email and password.';
			messageDiv.className = 'mt-4 text-center text-sm text-red-600';
			loginButton.disabled = false;
			loginButton.textContent = 'Sign In';
			return;
		}

		const result = await onLoginAttempt({ identifier, password });

		loginButton.disabled = false;
		loginButton.textContent = 'Sign In';

		if (result.success) {
			messageDiv.textContent = `Login successful! Welcome ${result.data.user.display_name || result.data.user.username}!`;
			messageDiv.className = 'mt-4 text-center text-sm text-green-600';
			onLoginSuccess(result.data.user); // Appeler le callback de succ√®s
		} else {
			messageDiv.textContent = result.error || 'Login failed. Please try again.';
			messageDiv.className = 'mt-4 text-center text-sm text-red-600';
			passwordInput.value = ''; // Vider le mot de passe en cas d'√©chec
		}
	});

	return formWrapper;
}
// app/frontend/conf/components/loginForm.ts
// import { ApiResult } from '../shared/types.js';
// import { LoginRequestBody, User } from '../shared/schemas/usersSchemas.js';
// import { createElement, createInputField, createActionButton } from '../utils/domUtils.js';

// interface LoginFormProps {
//     onLoginAttempt: (credentials: LoginRequestBody) => Promise<ApiResult>;
//     onLoginSuccess: (userData: User) => void;
// }

// export function LoginForm(props: LoginFormProps): HTMLElement {
//     const { onLoginAttempt, onLoginSuccess } = props;

//     const messageDiv = createElement('div', {
//         id: 'login-message-component',
//         className: 'mt-4 text-center text-sm min-h-[1.25rem]'
//     });

//     const identifierField = createInputField('identifier', 'Username or Email', {
//         required: true,
//         placeholder: 'Enter your username or email'
//     });

//     const passwordField = createInputField('password', 'Password', {
//         type: 'password',
//         required: true,
//         wrapperClass: 'mb-6' // Specific class for password field wrapper
//     });

//     const loginButton = createActionButton({
//         text: 'Sign In',
//         variant: 'success', // Using predefined variant
//         onClick: async () => { /* Will be handled by form submit */ }
//     });
//     loginButton.type = 'submit';
//     loginButton.id = 'login-button';
//     loginButton.classList.add('w-full');


//     const form = createElement('form', { id: 'login-form-component' }, [
//         identifierField,
//         passwordField,
//         createElement('div', { className: 'flex items-center justify-between' }, [
//             loginButton
//         ])
//     ]);

//     const formWrapper = createElement('div', {}, [form, messageDiv]);


//     const getInputValue = (field: HTMLElement): string => (field.querySelector('input') as HTMLInputElement).value;

//     form.addEventListener('submit', async (event) => {
//         event.preventDefault();
//         messageDiv.textContent = 'Attempting login...';
//         messageDiv.className = 'mt-4 text-center text-sm text-gray-600 min-h-[1.25rem]';
//         loginButton.disabled = true;
//         const originalButtonText = loginButton.textContent;
//         loginButton.textContent = 'Signing In...';

//         const identifier = getInputValue(identifierField).trim();
//         const password = getInputValue(passwordField); // No trim for password

//         if (!identifier || !password) {
//             messageDiv.textContent = 'Please enter both username/email and password.';
//             messageDiv.className = 'mt-4 text-center text-sm text-red-600 min-h-[1.25rem]';
//             loginButton.disabled = false;
//             loginButton.textContent = originalButtonText;
//             return;
//         }

//         const result = await onLoginAttempt({ identifier, password });

//         loginButton.disabled = false;
//         loginButton.textContent = originalButtonText;

//         if (result.success) {
//             messageDiv.textContent = `Login successful! Welcome ${result.data.user.display_name || result.data.user.username}!`;
//             messageDiv.className = 'mt-4 text-center text-sm text-green-600 min-h-[1.25rem]';
//             onLoginSuccess(result.data.user);
//         } else {
//             messageDiv.textContent = result.error || 'Login failed. Please try again.';
//             messageDiv.className = 'mt-4 text-center text-sm text-red-600 min-h-[1.25rem]';
//             (passwordField.querySelector('input') as HTMLInputElement).value = '';
//         }
//     });

//     return formWrapper;
// }
// app/frontend/src/components/toast.ts
export function showToast(message: string, type: 'success' | 'error' = 'success') {
    const existingToast = document.querySelector('.custom-toast');
    if (existingToast) {
        existingToast.remove();
    }

    const toast = document.createElement('div');
    toast.textContent = message;

    const successBgClass = 'bg-green-400'; // Ou bg-teal-400, bg-emerald-400
    const errorBgClass = 'bg-red-500';

    toast.className = `custom-toast fixed top-6 left-6 transform z-[1000] px-6 py-3 
                       rounded-lg shadow-lg text-white font-medium transition-all duration-300 ease-in-out
                       ${type === 'success' ? successBgClass : errorBgClass}`;
    
    toast.style.opacity = '0';
    toast.style.transform = 'translateY(-20px)';

    document.body.appendChild(toast);

    setTimeout(() => {
        toast.style.opacity = '0.8';
        toast.style.transform = 'translateY(0)';
    }, 10);

    setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transform = 'translateY(-20px)';
        setTimeout(() => toast.remove(), 300);
    }, 3000);
}

export function showCustomConfirm(message: string, title: string = "Confirmation"): Promise<boolean> {
    return new Promise((resolve) => {
        const existingDialog = document.querySelector('.custom-confirm-overlay');
        if (existingDialog) {
            existingDialog.remove();
        }

        const overlay = document.createElement('div');
        overlay.className = `custom-confirm-overlay fixed inset-0 
                             flex items-center justify-center z-[999] p-4 
                             transition-opacity duration-200 ease-out`;
        overlay.style.backdropFilter = 'blur(2px)'; // flou

        overlay.style.opacity = '0';

        // Dialog Box 
        const dialog = document.createElement('div');
        dialog.className = 'bg-white rounded-lg shadow-xl w-full max-w-sm transform transition-all duration-200 ease-out';
        dialog.style.opacity = '0';
        dialog.style.transform = 'scale(0.95)';

        // Title 
        const titleElement = document.createElement('h3');
        titleElement.className = 'text-lg font-semibold text-gray-800 px-6 py-4 border-b border-gray-200';
        titleElement.textContent = title;

        // Message
        const messageElement = document.createElement('p');
        messageElement.className = 'text-gray-600 px-6 py-5 text-sm';
        messageElement.textContent = message;

        // Buttons Container
        const buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'px-6 py-3 bg-gray-50 rounded-b-lg flex justify-end space-x-3';

        // Confirm Button
        const confirmButton = document.createElement('button');
        confirmButton.textContent = 'Yes';
        confirmButton.className = 'px-4 py-2 rounded-md text-sm font-medium text-white bg-red-600 hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2';
        
        // Cancel Button
        const cancelButton = document.createElement('button');
        cancelButton.textContent = 'No';
        cancelButton.className = 'px-4 py-2 rounded-md text-sm font-medium text-gray-700 bg-gray-200 hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2';

        const closeDialog = (value: boolean) => {
            overlay.style.opacity = '0';
            dialog.style.transform = 'scale(0.95)';
            setTimeout(() => {
                overlay.remove();
                resolve(value);
                window.removeEventListener('keydown', handleEscKey);
            }, 200);
        };
        
        confirmButton.onclick = () => closeDialog(true);
        cancelButton.onclick = () => closeDialog(false);

        const handleEscKey = (event: KeyboardEvent) => {
            if (event.key === 'Escape') {
                closeDialog(false);
            }
        };
        window.addEventListener('keydown', handleEscKey);

        buttonsContainer.appendChild(cancelButton);
        buttonsContainer.appendChild(confirmButton);
        dialog.appendChild(titleElement);
        dialog.appendChild(messageElement);
        dialog.appendChild(buttonsContainer);
        overlay.appendChild(dialog);
        document.body.appendChild(overlay);

        requestAnimationFrame(() => {
            overlay.style.opacity = '1';
            dialog.style.opacity = '1';
            dialog.style.transform = 'scale(1)';
        });
    });
}

export function showWaitingToast(socket: SocketIOClient.Socket, controller: AbortController) {
    const existingToast = document.querySelector('.custom-waiting-toast');
    if (existingToast) {
        existingToast.remove();
    }

    const toast = document.createElement('div') as HTMLElement;
     toast.className = `custom-waiting-toast fixed bottom-6 right-6 z-[1000]
                       bg-white text-gray-800 shadow-lg rounded-full w-48 h-48 p-4 
                       flex flex-col items-center justify-center gap-4
                       transition-all duration-300 ease-in-out border border-gray-300`;

     // Spinner container
    const spinnerContainer = document.createElement('div');
    spinnerContainer.className = 'relative w-16 h-16';

    // Spinner ring (outer border)
    const spinner = document.createElement('div');
    spinner.className = `absolute inset-0 rounded-full border-4 
                         border-green-500 border-t-transparent animate-spin`;

    // Message
    const message = document.createElement('p');
    message.textContent = 'Looking for an opponent...';
    message.className = 'text-center text-sm font-medium';

    // Timer
    const timer = document.createElement('div');
    timer.textContent = '60';
    timer.className = 'absolute inset-0 flex items-center justify-center text-lg font-bold text-green-700';
    
    spinnerContainer.appendChild(spinner);
    spinnerContainer.appendChild(timer);

    // Cancel button
    const cancelBtn = document.createElement('button');
    cancelBtn.textContent = 'Cancel';
    cancelBtn.className = `bg-red-600 hover:bg-red-700 text-white 
                           font-medium py-1 px-4 rounded`;
                           
    toast.appendChild(spinnerContainer);                      
    toast.appendChild(message);
    toast.appendChild(cancelBtn);
    document.body.appendChild(toast);

    // Animation d'apparition
    toast.style.opacity = '0';
    toast.style.transform = 'translateY(20px)';
    setTimeout(() => {
        toast.style.opacity = '1';
        toast.style.transform = 'translateY(0)';
    }, 10);

    // Timer countdown
    let secondsLeft = 60;
    const countdown = setInterval(() => {
        secondsLeft--;
        timer.textContent = `${secondsLeft}`;
        if (secondsLeft <= 0) {
            clearInterval(countdown);
        }
    }, 1000);

    // Cancel logic
    cancelBtn.addEventListener('click', () => {
        clearInterval(countdown);
        controller.abort();
        socket.emit('cancelMatch');
        socket.disconnect();
        removeWaitingToast();
    });
}


export function removeWaitingToast() {
    const toast = document.querySelector('.custom-waiting-toast');
    if (toast instanceof HTMLElement) {
        toast.style.opacity = '0';
        toast.style.transform = 'translateY(20px)';
        setTimeout(() => toast.remove(), 300);
    }
}
// app/frontend/src/components/registerPage.ts
import { attemptRegister } from '../services/authService.js';
import { RegisterRequestBody } from '../shared/schemas/usersSchemas.js'
import { ApiResult } from '../utils/types.js'
import { navigateTo } from '../services/router.js';

export async function RegisterPage(): Promise<HTMLElement> {


	const container = document.createElement('div');
	container.className = 'bg-white flex justify-center items-center min-h-screen p-8';
	
	const formContainer = document.createElement('div');
	formContainer.className = 'bg-white bg-opacity-90 backdrop-filter backdrop-blur-lg rounded-xl shadow-2xl p-8 max-w-md w-full';

	formContainer.innerHTML = `
        <h2 class="text-3xl font-bold mb-6 text-center text-gray-800">Register</h2>
        <form id="register-form">
            <div class="mb-4">
                <label for="username" class="block text-gray-700 text-sm font-bold mb-2">Username</label>
                <input type="text" id="username" name="username" required minlength="3" maxlength="20"
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                <p class="text-xs text-gray-600 mt-1">3 to 20 characters.</p>
            </div>
            <div class="mb-4">
                <label for="email" class="block text-gray-700 text-sm font-bold mb-2">Email</label>
                <input type="email" id="email" name="email" required
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
            </div>
             <div class="mb-4">
                <label for="display_name" class="block text-gray-700 text-sm font-bold mb-2">Display Name</label>
                <input type="text" id="display_name" name="display_name" required minlength="3" maxlength="20"
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                <p class="text-xs text-gray-600 mt-1">3 to 20 characters.</p>
            </div>
            <div class="mb-4">
                <label for="password" class="block text-gray-700 text-sm font-bold mb-2">Password</label>
                <input type="password" id="password" name="password" required minlength="8" maxlength="100"
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
                 <p class="text-xs text-gray-600 mt-1">8 to 100 characters.</p>
            </div>
             <div class="mb-6">
                <label for="confirm_password" class="block text-gray-700 text-sm font-bold mb-2">Confirm Password</label>
                <input type="password" id="confirm_password" name="confirm_password" required minlength="8" maxlength="100"
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 mb-3 leading-tight focus:outline-none focus:shadow-outline">
            </div>
            <div class="mb-6">
                <label for="avatar_url" class="block text-gray-700 text-sm font-bold mb-2">Avatar URL (Optional)</label>
                <input type="url" id="avatar_url" name="avatar_url" placeholder="https://example.com/avatar.jpg"
                       class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline">
            </div>
            <div class="flex items-center justify-between">
                <button type="submit" id="register-button"
                        class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline w-full transition duration-300 ease-in-out">
                    Register
                </button>
            </div>
        </form>
        <div id="register-message" class="mt-4 text-center text-sm"></div>
        <div class="mt-6 text-center">
          <a href="/" data-link class="text-blue-600 hover:text-blue-800 text-sm">
            Back to Home
          </a>
          <span class="mx-2 text-gray-400">|</span>
          <a href="/login" data-link class="text-blue-600 hover:text-blue-800 text-sm">
            Already have an account? Login
          </a>
        </div>
    `;

	container.appendChild(formContainer);

	// --- Logique du formulaire d'inscription ---
	const form = container.querySelector('#register-form') as HTMLFormElement;
	const usernameInput = container.querySelector('#username') as HTMLInputElement;
	const emailInput = container.querySelector('#email') as HTMLInputElement;
	const displayNameInput = container.querySelector('#display_name') as HTMLInputElement;
	const passwordInput = container.querySelector('#password') as HTMLInputElement;
	const confirmPasswordInput = container.querySelector('#confirm_password') as HTMLInputElement;
	const avatarUrlInput = container.querySelector('#avatar_url') as HTMLInputElement;
	const messageDiv = container.querySelector('#register-message') as HTMLDivElement;
	const registerButton = container.querySelector('#register-button') as HTMLButtonElement;

	form.addEventListener('submit', async (event) => {
		event.preventDefault();
		messageDiv.textContent = ''; // Clear previous messages
		messageDiv.className = 'mt-4 text-center text-sm'; // Reset style

		const username = usernameInput.value.trim();
		const email = emailInput.value.trim();
		const displayName = displayNameInput.value.trim();
		const password = passwordInput.value; // No trim on password
		const confirmPassword = confirmPasswordInput.value;
		const avatarUrl = avatarUrlInput.value.trim();

		// --- Validation des champs ---
		if (!username || !email || !displayName || !password || !confirmPassword) {
			messageDiv.textContent = 'Please fill in all required fields.';
			messageDiv.className = 'mt-4 text-center text-sm text-red-600';
			return;
		}
		if (password !== confirmPassword) {
			messageDiv.textContent = 'Passwords do not match.';
			messageDiv.className = 'mt-4 text-center text-sm text-red-600';
			passwordInput.value = ''; // Clear passwords
			confirmPasswordInput.value = '';
			return;
		}
		if (password.length < 8) {
			messageDiv.textContent = 'Password must be at least 8 characters long.';
			messageDiv.className = 'mt-4 text-center text-sm text-red-600';
			return;
		}
		// Simple check for avatar URL format if provided
		if (avatarUrl && !isValidHttpUrl(avatarUrl)) {
			messageDiv.textContent = 'Avatar URL must be a valid HTTP/HTTPS URL.';
			messageDiv.className = 'mt-4 text-center text-sm text-red-600';
			return;
		}

		// --- Appel √† l'API ---
		messageDiv.textContent = 'Attempting registration...';
		messageDiv.className = 'mt-4 text-center text-sm text-gray-600';
		registerButton.disabled = true;
		registerButton.textContent = 'Registering...';

		const credentials: RegisterRequestBody = {
			username,
			email,
			password,
			display_name: displayName,
		};
		// Only add avatar_url if it's not empty
		if (avatarUrl) {
			credentials.avatar_url = avatarUrl;
		}

		const registrationResult: ApiResult = await attemptRegister(credentials);

		registerButton.disabled = false; // Re-enable button
		registerButton.textContent = 'Register';

		if (registrationResult.success) {
			messageDiv.textContent = `Registration successful for ${username}! Redirecting to login...`;
			messageDiv.className = 'mt-4 text-center text-sm text-green-600';
			form.reset(); // Clear the form fields
			setTimeout(() => { navigateTo('/login'); }, 500);

		} else {
			messageDiv.textContent = 'Registration failed. Please check the details and try again.'; // Message g√©n√©rique post-alert
			messageDiv.className = 'mt-4 text-center text-sm text-red-600';
			passwordInput.value = ''; // Clear password fields on failure
			confirmPasswordInput.value = '';
		}
	});

	return container;
}

// Helper function for basic URL validation
function isValidHttpUrl(string: string): boolean {
	let url;
	try {
		url = new URL(string);
	} catch (_) {
		return false;
	}
	return url.protocol === "http:" || url.protocol === "https:";
}

// app/frontend/conf/pages/registerPage.ts
// import { attemptRegister } from '../services/authService.js';
// import { RegisterRequestBody, ApiResult } from '../shared/types.js';
// import { navigateTo } from '../services/router.js';
// import { createElement, createInputField, createActionButton } from '../utils/domUtils.js';
// import { isValidHttpUrl, isValidEmailFormat } from '../services/apiUtils.js'; // Import validation

// export async function RegisterPage(): Promise<HTMLElement> {
// 	const messageDiv = createElement('div', {
// 		id: 'register-message',
// 		className: 'mt-4 text-center text-sm min-h-[1.25rem]'
// 	});

// 	const usernameField = createInputField('username', 'Username', {
// 		required: true, minLength: 3, maxLength: 20, helpText: '3 to 20 characters.'
// 	});
// 	const emailField = createInputField('email', 'Email', {
// 		type: 'email', required: true
// 	});
// 	const displayNameField = createInputField('display_name', 'Display Name', {
// 		required: true, minLength: 3, maxLength: 20, helpText: '3 to 20 characters.'
// 	});
// 	const passwordField = createInputField('password', 'Password', {
// 		type: 'password', required: true, minLength: 8, maxLength: 100, helpText: '8 to 100 characters.'
// 	});
// 	const confirmPasswordField = createInputField('confirm_password', 'Confirm Password', {
// 		type: 'password', required: true, minLength: 8, maxLength: 100, wrapperClass: 'mb-6'
// 	});
// 	const avatarUrlField = createInputField('avatar_url', 'Avatar URL (Optional)', {
// 		type: 'url', placeholder: 'https://example.com/avatar.jpg', wrapperClass: 'mb-6'
// 	});

// 	const registerButton = createActionButton({
// 		text: 'Register',
// 		baseClass: 'bg-yellow-500 hover:bg-yellow-600', // Specific color
// 		onClick: async () => { /* form submit */ }
// 	});
// 	registerButton.type = 'submit';
// 	registerButton.id = 'register-button';
// 	registerButton.classList.add('w-full');

// 	const form = createElement('form', { id: 'register-form' }, [
// 		usernameField,
// 		emailField,
// 		displayNameField,
// 		passwordField,
// 		confirmPasswordField,
// 		avatarUrlField,
// 		createElement('div', { className: 'flex items-center justify-between' }, [registerButton])
// 	]);

// 	const linksDiv = createElement('div', {
// 		className: 'mt-6 text-center',
// 		innerHTML: `
//             <a href="/" data-link class="text-blue-600 hover:text-blue-800 text-sm">Back to Home</a>
//             <span class="mx-2 text-gray-400">|</span>
//             <a href="/login" data-link class="text-blue-600 hover:text-blue-800 text-sm">Already have an account? Login</a>
//         `
// 	});

// 	const formContainer = createElement('div', {
// 		className: 'bg-white bg-opacity-90 backdrop-filter backdrop-blur-lg rounded-xl shadow-2xl p-8 max-w-md w-full'
// 	}, [
// 		createElement('h2', { textContent: 'Register', className: 'text-3xl font-bold mb-6 text-center text-gray-800' }),
// 		form,
// 		messageDiv,
// 		linksDiv
// 	]);

// 	const pageContainer = createElement('div', {
// 		className: 'bg-gradient-to-r from-blue-500 to-purple-600 flex justify-center items-center min-h-screen p-8'
// 	}, [formContainer]);

// 	const getVal = (field: HTMLElement) => (field.querySelector('input') as HTMLInputElement).value;

// 	form.addEventListener('submit', async (event) => {
// 		event.preventDefault();
// 		messageDiv.textContent = '';
// 		messageDiv.className = 'mt-4 text-center text-sm min-h-[1.25rem]';
// 		const originalButtonText = registerButton.textContent;

// 		const username = getVal(usernameField).trim();
// 		const email = getVal(emailField).trim();
// 		const displayName = getVal(displayNameField).trim();
// 		const password = getVal(passwordField); // No trim
// 		const confirmPassword = getVal(confirmPasswordField);
// 		const avatarUrl = getVal(avatarUrlField).trim();

// 		const displayError = (msg: string) => {
// 			messageDiv.textContent = msg;
// 			messageDiv.className = 'mt-4 text-center text-sm text-red-600 min-h-[1.25rem]';
// 		};

// 		if (!username || !email || !displayName || !password || !confirmPassword) {
// 			return displayError('Please fill in all required fields.');
// 		}
// 		if (!isValidEmailFormat(email)) {
// 			return displayError('Invalid email format.');
// 		}
// 		if (password !== confirmPassword) {
// 			(passwordField.querySelector('input') as HTMLInputElement).value = '';
// 			(confirmPasswordField.querySelector('input') as HTMLInputElement).value = '';
// 			return displayError('Passwords do not match.');
// 		}
// 		if (password.length < 8) {
// 			return displayError('Password must be at least 8 characters long.');
// 		}
// 		if (avatarUrl && !isValidHttpUrl(avatarUrl)) {
// 			return displayError('Avatar URL must be a valid HTTP/HTTPS URL.');
// 		}

// 		messageDiv.textContent = 'Attempting registration...';
// 		messageDiv.className = 'mt-4 text-center text-sm text-gray-600 min-h-[1.25rem]';
// 		registerButton.disabled = true;
// 		registerButton.textContent = 'Registering...';

// 		const credentials: RegisterRequestBody = { username, email, password, display_name: displayName };
// 		if (avatarUrl) credentials.avatar_url = avatarUrl;

// 		const registrationResult: ApiResult = await attemptRegister(credentials);

// 		registerButton.disabled = false;
// 		registerButton.textContent = originalButtonText;

// 		if (registrationResult.success) {
// 			messageDiv.textContent = `Registration successful for ${username}! Redirecting to login...`;
// 			messageDiv.className = 'mt-4 text-center text-sm text-green-600 min-h-[1.25rem]';
// 			form.reset();
// 			setTimeout(() => { navigateTo('/login'); }, 1500); // Increased timeout slightly
// 		} else {
// 			displayError(registrationResult.error || 'Registration failed. Please try again.');
// 			(passwordField.querySelector('input') as HTMLInputElement).value = '';
// 			(confirmPasswordField.querySelector('input') as HTMLInputElement).value = '';
// 		}
// 	});
// 	return pageContainer;
// }
// app/frontend/src/style/input.css
@import 'tailwindcss';

@layer utilities {
    .animate-pulse-custom {
      animation: pulseCustom 2s infinite;
    }
  
    @keyframes pulseCustom {
      0%, 100% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(1.1);
        opacity: 0.7;
      }
    }
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}
.animate-spin {
    animation: spin 1s linear infinite;
}

.jungle-coconut {
	background: radial-gradient(circle at 30% 30%, #6e4a2f 15%, #4a2f18 80%);
	box-shadow: inset 0 0 2px #2a1d12, 0 0 5px rgba(0, 0, 0, 0.4);
}// app/frontend/src/services/csrf.ts
export let csrfToken: string | null = null;

export function setCsrfToken(token: string) {
	csrfToken = token;
	localStorage.setItem('csrfToken', token);
}

export function getCsrfTokenOrThrow(): string {
	if (!csrfToken) {
		csrfToken = localStorage.getItem('csrfToken');
	}
	if (!csrfToken) throw new Error('CSRF token missing. Please refresh the page.');
	return csrfToken;
}

export async function fetchWithCsrf(url: string, options: RequestInit = {}): Promise<Response> {
	const token = getCsrfTokenOrThrow();
	const headers = new Headers(options.headers || {});
	headers.set('x-csrf-token', token);
	return fetch(url, {
		...options,
		headers,
		credentials: 'include',
	});
}

export async function fetchCsrfToken() {
	try {
		const response = await fetch('/api/users/csrf-token', { credentials: 'include' });
		if (!response.ok) throw new Error('Failed to fetch CSRF token');
		const data = await response.json();
		csrfToken = data.csrfToken;
		console.log('CSRF Token fetched and stored:', csrfToken);
	} catch (error) {
		console.error('Error fetching CSRF token:', error);
	}
}
// app/frontend/src/services/error.ts
import { z } from 'zod';

export const ServerErrorPayloadSchema = z.object({
  error: z.string(),
  statusCode: z.number(),
  details: z.any().optional(),
});

export type ServerErrorPayload = z.infer<typeof ServerErrorPayloadSchema>;

export class ClientApiError extends Error {
  public httpStatus: number;
  public serverStatusCode?: number;
  public errorResponse?: ServerErrorPayload;

  constructor(
    message: string,
    httpStatus: number,
    serverStatusCode?: number,
    errorResponse?: ServerErrorPayload
  ) {
    super(message);
    this.name = 'ClientApiError';
    this.httpStatus = httpStatus;
    this.serverStatusCode = serverStatusCode;
    this.errorResponse = errorResponse;

    Object.setPrototypeOf(this, ClientApiError.prototype);
  }
}

/**
 * G√®re une r√©ponse API, la parse avec un sch√©ma Zod et l√®ve une erreur en cas d'√©chec.
 * @template T - Le sch√©ma Zod √† utiliser pour le parsing.
 * @param {Response} response - L'objet r√©ponse de fetch.
 * @param {T} schema - Le sch√©ma Zod pour valider et parser les donn√©es.
 * @returns {Promise<z.infer<T>>} Les donn√©es pars√©es et valid√©es.
 * @throws {ClientApiError} Si la r√©ponse n'est pas OK ou si le parsing √©choue.
 */
export const handleApiResponse = async <T extends z.ZodTypeAny>(
  response: Response,
  schema: T
): Promise<z.infer<T>> => {
  if (!response.ok) {
    let errorPayload: ServerErrorPayload | undefined;
    let errorMessage = `Erreur HTTP ${response.status}: ${response.statusText}`;

    const contentType = response.headers.get('content-type');
    if (response.body && contentType?.includes('application/json')) {
      try {
        const json = await response.json();
        const parsedError = ServerErrorPayloadSchema.safeParse(json);
        if (parsedError.success) {
          errorPayload = parsedError.data;
          errorMessage = errorPayload.error;
        } else {
          errorMessage = `Erreur HTTP ${response.status}: La r√©ponse d'erreur JSON est mal form√©e.`;
        }
      } catch (e) {
      }
    }
    throw new ClientApiError(errorMessage, response.status, errorPayload?.statusCode, errorPayload);
  }


  if (response.status === 204) {
    return undefined as z.infer<T>;
  }

  const json = await response.json();
  const result = schema.safeParse(json); // Parsing de la r√©ponse de SUCC√àS

  if (!result.success) {
    console.error("Erreur de validation Zod (r√©ponse succ√®s invalide):", result.error.issues);
    
    const validationErrorPayload: ServerErrorPayload = {
      error: "Les donn√©es re√ßues du serveur sont invalides.",
      statusCode: response.status,
      details: result.error.issues
    };

    throw new ClientApiError(
      validationErrorPayload.error,
      response.status,
      response.status,
      validationErrorPayload
    );
  }

  return result.data;
};// app/frontend/src/services/initOnlineGame.ts
import { UUID } from "crypto";
import { navigateTo } from "./router.js";
import socket from "./socket.js";
import { removeWaitingToast, showToast, showWaitingToast } from "../components/toast.js";
import { initCountdown } from "../components/countdown.js";

// --- Main Fonction for online game: 
export async function handleOnlineGame(display_name: string, userId: string, container: HTMLElement, button: HTMLButtonElement, title: HTMLHeadElement): Promise<void> {
    button.disabled = true; // pour eviter les multiples click (data race)
    try {
        await initOnlineGame(display_name, userId, container, title);
    } catch (err: unknown) {
        console.log(err);
        showToast('Error while creating a waiting room. Please, try again later', 'error');
        navigateTo('/game');
    } finally {
        button.disabled = false;
    }
}

// --- Fonction pour initialiser le client socket et le mettre dans le waiting room ---
export async function initOnlineGame(display_name: string, userId: string, buttonsContainer: HTMLElement, title: HTMLHeadElement) {
    const controller: AbortController = new AbortController();

    if (!socket.connected) {
        socket.connect();
    }
    
    socket.on('connect', () => {
        console.log('Connected to the server');
        socket.emit('authenticate', { display_name, userId });
    });
    
    socket.on('inQueue', () => {
        showWaitingToast(socket, controller);
    });

    // --- Socket listener on matchFound event --> if opponenet is found
    socket.on('matchFound', async ({ matchId, displayName, side, opponent }: { matchId: UUID; displayName: string, side: 'left' | 'right'; opponent: string}) => {

        sessionStorage.setItem('matchId', matchId);
        sessionStorage.setItem('displayName', displayName);
        sessionStorage.setItem('side', side);
        sessionStorage.setItem('opponent', opponent);

        removeWaitingToast();

        const countdownContainer = document.createElement('div');
        countdownContainer.className = `
            fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50
            text-lime-200 text-6xl font-extrabold tracking-widest jungle-font
        `;        
        document.body.appendChild(countdownContainer);

        await initCountdown(countdownContainer);

        navigateTo(`/game-room?matchId=${matchId}`);

    });
    
    // --- Socket listeners on errors from the server side
    socket.on('disconnect', (reason: string, details?: any) => { 
        console.log(`Disconnected from the server: reason ${reason}`);
        if (details){
            console.log(`details: ${details.message}, ${details.description}, ${details.context}`);
        }
    });
    
    socket.on('error', (err: Error) => {
        console.error('Socket error:', err);
    });

    socket.on('connect_error', (err: Error) => {
        console.error(`Connection to the server is failed: ${err.message}`);
        showToast('Failed to connect to server. Please try later.', 'error');
        cleanupSocket(socket);
      });

    // --- TODO: emit on server side ---
    socket.on('matchTimeout', () => {
        showToast('No opponent found. Please try later.', 'error');
        cleanupSocket(socket);
        removeWaitingToast();
        navigateTo('/game');
    });
}

// // --- Fonction pour cr√©er une salle d'attente ---
// export async function createOnlineMatch(token: string, opponentId: string, display_name: string, signal: AbortSignal): Promise<string | null> {
//     try {
//         const requestBody = {
//             player1: display_name,
//             player2: opponentId,
//             isLocal: false,
//         }

//         console.log("Request Body:", requestBody);
//         const response = await fetch('/api/game/match', {
//             method: 'POST',
//             headers: {
//                 'Authorization': `Bearer ${token}`,
//                 'Content-Type': 'application/json',
//             },
//             body: JSON.stringify({
//                 player1: display_name,
//                 player2: opponentId,
//                 isLocal: false,
//             }),
//             signal: signal,
//           //  cache: 'default',
//         });
        
//         if (!response.ok) { // la reponse echouee (true if (res > 200 && res < 299))
//             throw new Error(`Failed to create online match: ${await response.text}`);
//         };
      
//         const data = await response.json();  
//         const matchId = data.matchId;

//         return matchId;
//     } catch (err: unknown) {
//         if (err instanceof DOMException && err.name === 'AbortError'){
//             console.log('Fetch aborted by user');
//         } else {
//             alert('Error creating online match');
//             console.log(err);
//         }
//         return null;
//     }
// }


// --- Helper to cleanup Socket connexion ---
export function cleanupSocket(socket: SocketIOClient.Socket) {
    socket.removeAllListeners();
    socket.disconnect();
}// app/frontend/src/services/socket.ts
import { Socket } from "socket.io-client"

const socket: typeof Socket = io('http://localhost:3001', {
    transports: ['websocket'],
    autoConnect: false,
});

export default socket;
// app/frontend/src/services/initLocalGame.ts
import { navigateTo } from "./router.js";

export async function initLocalGame(form: HTMLFormElement) {
    const gameMode = form.querySelector<HTMLSelectElement>('#gameMode');
    if (!gameMode) { // optional check ?
        alert('Please select a game mode.');
        return;
    }
    switch (gameMode.value) {
        case '1v1':
            const isValidAlias = (alias: string) => /^[a-zA-Z0-9_-]+$/.test(alias);
            const alias1 = form.querySelector<HTMLInputElement>('#alias1')?.value.trim();
            const alias2 = form.querySelector<HTMLInputElement>('#alias2')?.value.trim();
            
            if (!alias1 || !alias2 ) {
                alert('Please enter aliases for both players.');
                return;
            }
            // sanitaze check (maybe not necessery on client side ?)
            if (!isValidAlias(alias1) || !isValidAlias(alias2)) {
                alert('Aliases can only contain letters, numbers, dashes, and underscores.');
                return;
            }
            if (alias1 === alias2) {
                alert('Aliases should be unique');
                return;
            }
            
            await createLocalMatch(alias1, alias2);
            break;
        case 'Tournament':
        default:
            alert('Unknown game mode selected');
    }
}

// --- Helper function to call an API
async function createLocalMatch(alias1: string, alias2: string) {
    try {
        const response = await fetch('/api/game/match/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                player1: alias1,
                player2: alias2,
                isLocal: true,
            }),
        });
        
        if (!response.ok) {
            throw new Error(`Failed to create local match: ${await response.text}`);
        }
        
        const data = await response.json();
        const matchId = data.matchId;

        if (!matchId) {
            throw new Error('Missing match ID from server.')
        }
        // ! sessionStorage store all data locally 
        // + not erased after page refresh (but after closing the tab)
        sessionStorage.setItem('player1', data.player1);
        sessionStorage.setItem('player2', data.player2);
        sessionStorage.setItem('gameMode', 'local');
        sessionStorage.setItem('localMatchId', matchId);

        navigateTo(`/game-room?matchId=${matchId}`);

    } catch (err: unknown) {
        alert('Error creating local match');
        console.log(err);
    }
}
// app/frontend/src/services/router.ts
import { router } from '../main.js';

export function navigateTo(url: string) {
	window.history.pushState({}, '', url);	// Met √† jour l'URL dans la barre d'adresse sans recharger
	router();
}// app/frontend/src/services/friendService.ts
import { fetchWithCsrf } from './csrf.js';
import {
	Friend,
	PendingFriendRequest,
	PendingRequestsResponseSchema,
	FriendsListResponseSchema,
	MessageResponseSchema,
} from '../shared/schemas/friendsSchemas.js';
// import { handleApiResponse } from './apiUtils.js';
import { config } from '../utils/config.js';
import { handleApiResponse } from './error.js';

/**
 * Retrieves the friend requests received by the logged-in user.
 * @returns A list of pending friend requests.
 */
export async function getReceivedFriendRequests(): Promise<PendingFriendRequest[]> {
	const url = config.api.friends.receivedRequests;
	const response = await fetch(url, {
		method: 'GET',
		headers: { 'Content-Type': 'application/json' },
		credentials: 'include',
	});
	return handleApiResponse(response, PendingRequestsResponseSchema);
	// return handleApiResponse(response);
}

/**
 * Retrieves the list of friends of the logged-in user.
 * @returns A list of friends.
 */
export async function getFriendsList(): Promise<Friend[]> {
	const url = config.api.friends.list;
	const response = await fetch(url, {
		method: 'GET',
		headers: { 'Content-Type': 'application/json' },
		credentials: 'include',
	});
	return handleApiResponse(response, FriendsListResponseSchema);
}

/**
 * Retrieves the friend requests sent by the logged-in user.
 * @returns A list of sent friend requests.
 */
export async function getSentFriendRequests(): Promise<PendingFriendRequest[]> {
	const url = config.api.friends.sentRequests;
	const response = await fetch(url, {
		method: 'GET',
		headers: { 'Content-Type': 'application/json' },
		credentials: 'include',
	});
	return handleApiResponse(response, PendingRequestsResponseSchema);
}

/**
 * Accepts a friend request.
 * @param friendshipId The ID of the friendship (obtained from a received request).
 * @returns A message indicating the result of the operation.
 */
export async function acceptFriendRequest(friendshipId: number): Promise<{ message: string }> {
	const url = config.api.friends.acceptRequest(friendshipId);
	const response = await fetchWithCsrf(url, {
		method: 'POST',
	});
	return handleApiResponse(response, MessageResponseSchema);
}

/**
 * Declines a received friend request.
 * @param friendshipId The ID of the friendship.
 * @returns A message indicating the result of the operation.
 */
export async function declineFriendRequest(friendshipId: number): Promise<{ message: string }> {
	const url = config.api.friends.declineRequest(friendshipId);
	const response = await fetchWithCsrf(url, {
		method: 'POST',
	});
	return handleApiResponse(response, MessageResponseSchema);
}

/**
 * Cancels a sent friend request.
 * @param friendshipId The ID of the friendship.
 * @returns A message indicating the result of the operation.
 */
export async function cancelFriendRequest(friendshipId: number): Promise<{ message: string }> {
	const url = config.api.friends.cancelRequest(friendshipId);
	const response = await fetchWithCsrf(url, {
		method: 'POST',
	});
	return handleApiResponse(response, MessageResponseSchema);
}

/**
 * Sends a friend request to another user.
 * @param friendId The ID of the friend to be added.
 * @returns A message indicating the result of the operation.
 */
export async function sendFriendRequest(friendId: number): Promise<{ message: string }> {
	const url = config.api.friends.sendRequest;
	const response = await fetchWithCsrf(url, {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({ friendId }),
	});
	return handleApiResponse(response, MessageResponseSchema);
}

/**
 * Removes a friend by friendshipId.
 * @param friendshipId The ID of the friendship to remove.
 * @returns A message indicating the result of the operation.
 */
export async function removeFriend(friendshipId: number): Promise<{ message: string }> {
	const url = config.api.friends.remove(friendshipId);
	const response = await fetchWithCsrf(url, {
		method: 'POST',
	});
	return handleApiResponse(response, MessageResponseSchema);
}
// app/frontend/src/services/authService.ts
import { fetchWithCsrf } from './csrf.js';
import { ApiResult } from '../utils/types.js';
import {
	User,
	UserBaseSchema,
	LoginRequestBody,
	RegisterRequestBody,
	UpdateUserPayload,
	GetUsersListRouteSchema,
	GetMeRouteSchema,
	LoginRouteSchema,
	RegisterRouteSchema,
	UpdateUserRouteSchema,
	LogoutRouteSchema
} from '../shared/schemas/usersSchemas.js';
import { Match, GetMatchByUserIdRouteSchema } from '../shared/schemas/matchesSchemas.js';
import { handleApiResponse, ClientApiError } from './error.js';
import { config } from '../utils/config.js';

// Cl√©s pour le localStorage
const USER_DATA_KEY = 'userDataKey';
const USER_DATA_EXPIRATION_KEY = 'userDataExpiration';

/**
 * R√©cup√®re les donn√©es utilisateur depuis le localStorage, en v√©rifiant leur expiration.
 * @returns {User | null} L'utilisateur si disponible et non expir√©, sinon null.
 */
export function getUserDataFromStorage(): User | null {
	const expiration = localStorage.getItem(USER_DATA_EXPIRATION_KEY);
	if (expiration && new Date().getTime() > parseInt(expiration, 10)) {
		localStorage.removeItem(USER_DATA_KEY);
		localStorage.removeItem(USER_DATA_EXPIRATION_KEY);
		return null;
	}

	const data = localStorage.getItem(USER_DATA_KEY);
	if (!data) return null;

	try {
		const parsedData = UserBaseSchema.parse(JSON.parse(data));
		return parsedData;
	} catch (e) {
		console.error("Error parsing user data from localStorage:", e);
		localStorage.removeItem(USER_DATA_KEY);
		return null;
	}
}

/**
 * R√©cup√®re la liste de tous les utilisateurs.
 * @returns {Promise<User[]>} Un tableau d'utilisateurs.
 */
export async function fetchUsers(): Promise<User[]> {
	try {
		const response = await fetch(config.api.users.all);
		const data = await handleApiResponse(response, GetUsersListRouteSchema.response[200]);
		return data;
	} catch (error) {
		console.error("Failed to fetch users:", error);
		return [];
	}
}

/**
 * R√©cup√®re les d√©tails d'un utilisateur par son ID.
 * @param {number} userId - L'ID de l'utilisateur.
 * @returns {Promise<User>} L'objet utilisateur.
 */
export async function fetchUserDetails(userId: number): Promise<User> {
	const response = await fetch(config.api.users.byId(userId), {
		credentials: 'include',
	});
	return handleApiResponse(response, GetMeRouteSchema.response[200]);
}

/**
 * R√©cup√®re l'historique des matchs pour un utilisateur.
 * @param {number} userId - L'ID de l'utilisateur.
 * @returns {Promise<Match[]>} Un tableau de matchs.
 */
export async function fetchMatchHistoryForUser(userId: number): Promise<Match[]> {
	const response = await fetch(config.api.game.matchHistory(userId), {
		credentials: 'include',
	});
	return await handleApiResponse(response, GetMatchByUserIdRouteSchema.response[200]);
}

/**
 * V√©rifie le statut d'authentification en appelant une route prot√©g√©e.
 * @returns {Promise<User | null>} L'utilisateur si authentifi√©, sinon null.
 */
export async function checkAuthStatus(): Promise<User | null> {
	try {
		const response = await fetch(config.api.users.me, { credentials: 'include' });
		const user = await handleApiResponse(response, GetMeRouteSchema.response[200]);
		const ttl = 60 * 60 * 1000; // 1 heure en ms
		localStorage.setItem(USER_DATA_KEY, JSON.stringify(user));
		localStorage.setItem(USER_DATA_EXPIRATION_KEY, (new Date().getTime() + ttl).toString());

		return user;
	} catch (error) {
		if (!(error instanceof ClientApiError && error.httpStatus === 401)) {
			console.error("Error verifying authentication status:", error);
		}
		localStorage.removeItem(USER_DATA_KEY);
		localStorage.removeItem(USER_DATA_EXPIRATION_KEY);
		return null;
	}
}

/**
 * Tente de connecter un utilisateur.
 * @param {LoginRequestBody} credentials - Les identifiants de connexion.
 * @returns {Promise<ApiResult>} Un objet indiquant le succ√®s ou l'√©chec.
 */
export async function attemptLogin(credentials: LoginRequestBody): Promise<ApiResult> {
	try {
		const response = await fetch(config.api.auth.login, {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify(credentials),
			credentials: 'include',
		});

		const data = await handleApiResponse(response, LoginRouteSchema.response[200]);
		localStorage.setItem(USER_DATA_KEY, JSON.stringify(data.user));
		// setCsrfToken(data.csrfToken);

		return { success: true, data: { message: data.message, user: data.user } };

	} catch (error) {
		const errorMessage = error instanceof Error ? error.message : "Unknown error during login";
		return { success: false, error: errorMessage };
	}
}

/**
 * D√©connecte l'utilisateur.
 */
export async function logout(): Promise<void> {
	localStorage.removeItem(USER_DATA_KEY);
	localStorage.removeItem(USER_DATA_EXPIRATION_KEY);
	console.log("User data removed from localStorage.");

	try {
		const response = await fetchWithCsrf(config.api.auth.logout, { method: 'POST' });
		await handleApiResponse(response, LogoutRouteSchema.response[200]);
		console.log("Server-side logout successful.");
	} catch (error) {
		console.error("Error attempting server logout:", error);
	}
}

/**
 * Tente d'inscrire un nouvel utilisateur.
 * @param {RegisterRequestBody} credentials - Les informations d'inscription.
 * @returns {Promise<ApiResult>} Un objet indiquant le succ√®s ou l'√©chec.
 */
export async function attemptRegister(credentials: RegisterRequestBody): Promise<ApiResult> {
	try {
		const payload = { ...credentials };
		if (!payload.avatar_url) {
			delete payload.avatar_url;
		}

		const response = await fetch(config.api.auth.register, {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify(payload),
		});

		const data = await handleApiResponse(response, RegisterRouteSchema.response[201]);
		return { success: true, data: { message: data.message, user: {} as User } };

	} catch (error) {
		const errorMessage = error instanceof Error ? error.message : "Unknown error during registration";
		return { success: false, error: errorMessage };
	}
}

/**
 * Met √† jour le profil de l'utilisateur connect√©.
 * @param {UpdateUserPayload} payload - Les donn√©es √† mettre √† jour.
 * @returns {Promise<ApiResult>} Un objet indiquant le succ√®s ou l'√©chec.
 */
export async function updateUserProfile(payload: UpdateUserPayload): Promise<ApiResult> {
	const cleanPayload: Partial<UpdateUserPayload> = { ...payload };
	if (cleanPayload.avatar_url === '') {
		cleanPayload.avatar_url = null; // Envoyer null pour effacer l'avatar
	}

	try {
		const response = await fetchWithCsrf(config.api.users.me, {
			method: 'PATCH',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify(cleanPayload),
		});

		const data = await handleApiResponse(response, UpdateUserRouteSchema.response[200]);

		localStorage.setItem(USER_DATA_KEY, JSON.stringify(data.user));
		console.log("User data updated in localStorage.");

		return { success: true, data };

	} catch (error) {
		const errorMessage = error instanceof Error ? error.message : "Unknown error during profile update";
		return { success: false, error: errorMessage };
	}
}
// app/frontend/src/pages/userPage.ts
import { fetchUsers } from '../services/authService.js';
import { UserList } from '../components/userList.js';

export async function UsersPage(): Promise<HTMLElement> {
	const container = document.createElement('div');
	container.className = 'container mx-auto p-8';

	const title = document.createElement('h1');
	title.className = 'text-3xl font-bold mb-6 text-center text-blue-700';
	title.textContent = 'üèì King-Pong User List üèì';

	const userListElement = document.createElement('div');
	userListElement.id = 'user-list';
	userListElement.className = 'mt-6 bg-white p-6 rounded-lg shadow-md';
	userListElement.innerHTML = '<p class="text-center text-gray-500">Loading users...</p>';

	container.appendChild(title);
	container.appendChild(userListElement);

	try {
		const users = await fetchUsers();
		userListElement.innerHTML = '';

		// Fournir des valeurs par d√©faut pour les props requises
		const userListProps = {
			users,
			friends: [],
			sentRequests: [],
			receivedRequests: [],
			currentUserId: -1, // ou null/undefined si tu adaptes UserList
			onSendRequest: async () => { },
			onCancelRequest: async () => { },
			onAcceptRequest: async () => { },
			onDeclineRequest: async () => { },
		};
		userListElement.appendChild(UserList(userListProps));
	} catch (error) {
		console.error("Failed to load users for UsersPage:", error);
		userListElement.innerHTML = '<p class="text-center text-red-500">Error loading users.</p>';
	}

	return container;
}
// app/frontend/src/pages/dashboardPage.ts
import { navigateTo } from '../services/router.js';
import { getUserDataFromStorage } from '../services/authService.js';
import { fetchCsrfToken } from '../services/csrf.js';
import { User } from '../shared/schemas/usersSchemas.js';
import {
	getReceivedFriendRequests,
	getSentFriendRequests,
	acceptFriendRequest,
	declineFriendRequest,
	cancelFriendRequest,
	getFriendsList,
	sendFriendRequest,
	removeFriend,
} from '../services/friendService.js';
import { fetchUsers } from '../services/authService.js';
import { FriendsListComponent } from '../components/friendsList.js';
import { FriendRequestsComponent } from '../components/friendRequests.js';
import { UserList, UserListProps } from '../components/userList.js';
import { HeaderComponent } from '../components/headerComponent.js';
import { showToast } from '../components/toast.js';
import { MatchHistoryComponent } from '../components/matchHistoryComponent.js';

export async function DashboardPage(): Promise<HTMLElement> {
	const currentUser: User | null = getUserDataFromStorage();

	if (!currentUser) {
		navigateTo('/login');
		const redirectMsg = document.createElement('div');
		redirectMsg.className = 'min-h-screen flex items-center justify-center text-xl';
		redirectMsg.textContent = 'Redirecting to login...';
		return redirectMsg;
	}

	try {
		await fetchCsrfToken();
	} catch (error) {
		console.error("Failed to fetch CSRF token:", error);
		const errorMsg = document.createElement('div');
		errorMsg.className = 'min-h-screen flex items-center justify-center text-xl text-red-500';
		errorMsg.textContent = 'Error initializing page. Please try refreshing.';
		return errorMsg;
	}

	// --- Conteneur principal de la page ---
	const pageContainer = document.createElement('div');
	pageContainer.className = 'min-h-screen bg-gray-200 p-4 sm:p-8 flex flex-col items-center';

	// --- Le "Dashboard" lui-m√™me ---
	const dashboardWrapper = document.createElement('div');
	dashboardWrapper.className = 'bg-white rounded-2xl shadow-2xl w-full max-w-6xl flex flex-col overflow-hidden';

	// --- Section du haut (Langue, User Header) ---
	const headerElement = HeaderComponent({ currentUser: currentUser! });
	// Note: The global click listener for menu close is in HeaderComponent.

	// --- Section principale (Sidebar + Contenu √† onglets) ---
	const mainSection = document.createElement('div');
	mainSection.className = 'flex flex-1 min-h-[calc(100vh-150px)]'; // Hauteur minimale pour le contenu

	// --- Sidebar ---
	const sidebar = document.createElement('div');
	sidebar.className = 'w-1/4 p-6 bg-gray-50 border-r border-gray-200 space-y-3 overflow-y-auto';

	function createSidebarItem(label: string, value: string | number | Date | undefined | null): HTMLElement {
		const item = document.createElement('div');
		item.className = 'p-2.5 bg-white border border-gray-200 rounded-lg shadow-sm';
		const labelEl = document.createElement('span');
		labelEl.className = 'text-xs text-gray-500 block mb-0.5';
		labelEl.textContent = label;
		const valueEl = document.createElement('p');
		valueEl.className = 'text-sm text-gray-800 font-medium truncate';
		if (value instanceof Date) {
			valueEl.textContent = value.toLocaleDateString();
		} else {
			valueEl.textContent = value?.toString() || 'N/A';
		}
		item.appendChild(labelEl);
		item.appendChild(valueEl);
		return item;
	}

	sidebar.appendChild(createSidebarItem('Username', currentUser.username));
	sidebar.appendChild(createSidebarItem('Display Name', currentUser.display_name));
	sidebar.appendChild(createSidebarItem('Email', currentUser.email));
	sidebar.appendChild(createSidebarItem('Creation Date', new Date(currentUser.created_at)));
	sidebar.appendChild(createSidebarItem('Wins', currentUser.wins ?? 'N/A'));
	sidebar.appendChild(createSidebarItem('Losses', currentUser.losses ?? 'N/A'));

	// --- Contenu √† onglets ---
	const tabContentWrapper = document.createElement('div');
	tabContentWrapper.className = 'w-3/4 p-6 flex flex-col overflow-y-auto';

	const tabNavigation = document.createElement('div');
	tabNavigation.className = 'flex space-x-1 border-b border-gray-200 mb-6';

	const TABS = [
		{ id: 'users', label: 'All Users', componentLoader: loadUsersContent },
		{ id: 'friends', label: 'Friends', componentLoader: loadFriendsContent },
		{ id: 'pending', label: 'Pending', componentLoader: loadPendingRequestsContent },
		{ id: 'history', label: 'History Match', componentLoader: loadMatchHistoryContent },
	];
	let activeTabId = TABS[0].id;

	const activeTabContentContainer = document.createElement('div');
	activeTabContentContainer.id = 'active-tab-content';
	activeTabContentContainer.className = 'flex-1';

	TABS.forEach(tabInfo => {
		const tabButton = document.createElement('button');
		tabButton.dataset.tabId = tabInfo.id;
		tabButton.textContent = tabInfo.label;
		tabButton.className = `py-2 px-4 text-sm font-medium focus:outline-none transition-colors`;
		if (tabInfo.id === activeTabId) {
			tabButton.classList.add('border-b-2', 'border-blue-600', 'text-blue-600');
		} else {
			tabButton.classList.add('text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
		}
		tabButton.addEventListener('click', () => switchTab(tabInfo.id));
		tabNavigation.appendChild(tabButton);
	});

	tabContentWrapper.appendChild(tabNavigation);
	tabContentWrapper.appendChild(activeTabContentContainer);

	mainSection.appendChild(sidebar);
	mainSection.appendChild(tabContentWrapper);

	dashboardWrapper.appendChild(headerElement);
	dashboardWrapper.appendChild(mainSection);
	pageContainer.appendChild(dashboardWrapper);

	// --- Fonctions de rappel pour les actions d'amiti√© (utilis√©es par UserList) ---
	const handleSendFriendRequest = async (targetUserId: number) => {
		const result = await sendFriendRequest(targetUserId);
		showToast(result.message);
		if (activeTabId === 'users' || activeTabId === 'pending') await loadActiveTabContent(); // Recharger si l'onglet users ou pending est actif
	};

	const handleCancelFriendRequest = async (friendshipId: number) => {
		const result = await cancelFriendRequest(friendshipId);
		showToast(result.message);
		if (activeTabId === 'users' || activeTabId === 'pending') await loadActiveTabContent();
	};

	const handleAcceptFriendRequest = async (friendshipId: number) => {
		const result = await acceptFriendRequest(friendshipId);
		showToast(result.message, 'success');
		if (['users', 'pending', 'friends'].includes(activeTabId)) await loadActiveTabContent();
	};

	const handleDeclineFriendRequest = async (friendshipId: number) => {
		const result = await declineFriendRequest(friendshipId);
		showToast(result.message, 'success');
		if (activeTabId === 'users' || activeTabId === 'pending') await loadActiveTabContent();
	};

	// --- Logique de chargement et de changement d'onglet ---
	async function switchTab(tabId: string) {
		activeTabId = tabId;
		tabNavigation.querySelectorAll('button').forEach(btn => {
			if (btn.dataset.tabId === tabId) {
				btn.className = 'py-2 px-4 text-sm font-medium focus:outline-none transition-colors border-b-2 border-blue-600 text-blue-600';
			} else {
				btn.className = 'py-2 px-4 text-sm font-medium focus:outline-none transition-colors text-gray-500 hover:text-gray-700 hover:border-gray-300';
			}
		});
		await loadActiveTabContent();
	}

	async function loadActiveTabContent() {
		activeTabContentContainer.innerHTML = '<p class="text-center text-gray-500 py-10">Loading...</p>';
		const currentTab = TABS.find(t => t.id === activeTabId);
		if (currentTab) {
			try {
				const contentElement = await currentTab.componentLoader();
				activeTabContentContainer.innerHTML = '';
				activeTabContentContainer.appendChild(contentElement);
			} catch (error) {
				console.error(`Error loading content for tab ${activeTabId}:`, error);
				activeTabContentContainer.innerHTML = `<p class="text-center text-red-500 py-10">Error loading content for ${activeTabId}.</p>`;
			}
		}
	}

	// --- Fonctions de chargement sp√©cifiques pour chaque onglet ---
	async function loadUsersContent(): Promise<HTMLElement> {
		const [usersData, friendsData, sentRequestsData, receivedRequestsData] = await Promise.all([
			fetchUsers(),
			getFriendsList(),
			getSentFriendRequests(),
			getReceivedFriendRequests()
		]);

		const userListProps: UserListProps = {
			users: usersData as User[],
			friends: friendsData,
			sentRequests: sentRequestsData,
			receivedRequests: receivedRequestsData,
			currentUserId: currentUser!.id,
			onSendRequest: handleSendFriendRequest,
			onCancelRequest: handleCancelFriendRequest,
			onAcceptRequest: handleAcceptFriendRequest,
			onDeclineRequest: handleDeclineFriendRequest,
		};
		return UserList(userListProps);
	}

	async function loadFriendsContent(): Promise<HTMLElement> {
		const friends = await getFriendsList();
		return FriendsListComponent({
			friends: friends,
			onRemoveFriend: async (friendshipId) => {
				const result = await removeFriend(friendshipId);
				showToast(result.message);
				if (['friends', 'users'].includes(activeTabId)) await loadActiveTabContent();
			},
		});
	}

	async function loadPendingRequestsContent(): Promise<HTMLElement> {
		const [received, sent] = await Promise.all([
			getReceivedFriendRequests(),
			getSentFriendRequests(),
		]);
		return FriendRequestsComponent({
			receivedRequests: received,
			sentRequests: sent,
			onAcceptRequest: handleAcceptFriendRequest, // R√©utilisation du handler global
			onDeclineRequest: handleDeclineFriendRequest, // R√©utilisation du handler global
			onCancelRequest: handleCancelFriendRequest, // R√©utilisation du handler global
		});
	}

	async function loadMatchHistoryContent(): Promise<HTMLElement> {
		if (currentUser) {
			return await MatchHistoryComponent({ userId: currentUser.id });
		} else {
			const errorMsg = document.createElement('div');
			errorMsg.className = 'min-h-screen flex items-center justify-center text-xl text-red-500';
			errorMsg.textContent = 'User not found. Please log in.';
			return errorMsg;
		}
	}

	// Charger le contenu de l'onglet initial
	await loadActiveTabContent();

	return pageContainer;
}
// app/frontend/src/pages/gameRoomPage.ts
import { GameMode } from "../components/gamePage.js";
import { cleanupSocket } from "../services/initOnlineGame.js";
import { navigateTo } from "../services/router.js";
import socket from '../services/socket.js';
import { showGameResult } from "../components/gameResults.js";
import { showCustomConfirm } from "../components/toast.js";
//@ts-ignore
import { GameState } from '../shared/gameTypes.js';
// import { showToast } from '../components/toast.js';
const PADDLE_HEIGHT = 120;
const PADDLE_WIDTH = 20;
const BG_COLOUR = "rgb(0, 0, 0) ";
const BALL_COLOUR = "rgb(255, 255, 255) ";
const PADDLE_COLOUR = "rgb(255, 255, 255) ";

const gameState: GameState = {
	leftPaddle: {
		x: 20,
		y: 200,
		vy: 0, // need to remove
	},
	rightPaddle: {
		x: 770,
		y: 200,
		vy: 0,
	},
	ball: {
		x: 400,
		y: 250,
		radius: 15,
		vx: 0,
		vy: 0,
	},
} 

// boolean qui sert pour arreter dessiner le jeu
let isGameOver = false;

export function GameRoomPage(mode: GameMode): HTMLElement {
	
	// Conteneur principal
	const container = document.createElement('div');
	container.className = `
		w-full h-screen flex flex-col items-center justify-center 
		bg-gradient-to-b from-green-900 via-green-700 to-green-600 
		jungle-font text-white
	`;

	// Wrapper horizontal pour les usernames et canvas
	const gameRow = document.createElement('div');
	gameRow.className = 'flex items-center';

	// Nom du joueur gauche (√† gauche du canvas)
	const leftUsername = document.createElement('div');
	leftUsername.className = `
		mr-4 px-3 py-1 bg-lime-200 text-green-900 
		border border-green-800 rounded font-bold text-xl 
		shadow jungle-font text-center inline-block
	`;
	leftUsername.id = 'left-username';

	// Canvas de jeu
	const canvas = document.createElement('canvas');
	canvas.id = 'pong-canvas';
	canvas.width = 800;
	canvas.height = 500;
	canvas.className = 'border-8 border-green-700 rounded-lg bg-neutral-900';

	// Nom du joueur droit (√† droite du canvas)
	const rightUsername = document.createElement('div');
	rightUsername.className = `
		ml-4 px-3 py-1 bg-lime-200 text-green-900 
		border border-green-800 rounded font-bold text-xl 
		shadow jungle-font text-center inline-block
	`;
	rightUsername.id = 'right-username';

	// Score display
	const scoreDisplay = document.createElement('div');
	scoreDisplay.className = `
		absolute top-8 left-1/2 transform -translate-x-1/2
		text-3xl font-extrabold text-yellow-300 jungle-font drop-shadow
	`;
	scoreDisplay.id = 'score-display';
	scoreDisplay.textContent = '0 - 0';

	// Composition de la ligne
	gameRow.append(leftUsername, canvas, rightUsername, scoreDisplay);
	container.appendChild(gameRow);

	// Quit button
	const quitButton = document.createElement('button');
	quitButton.className = `
		mt-6 px-5 py-2 bg-red-700 text-white font-bold rounded-lg 
		hover:bg-red-800 shadow-lg transition duration-300 jungle-font
	`;
	quitButton.textContent = 'Quit';

	// Ajouter le bouton dans le container principal
	container.appendChild(quitButton);
	
	const gameMode = sessionStorage.getItem('gameMode');
	if (gameMode === 'local') {
		rightUsername.textContent = sessionStorage.getItem('player1');
		leftUsername.textContent = sessionStorage.getItem('player2');
	} else {
		setBoard(leftUsername, rightUsername);
	}

	// Initialiser le canvas
	const ctx = canvas.getContext('2d');
	if (!ctx) throw new Error('Canvas context not supported');
	ctx.fillStyle = BG_COLOUR;
	ctx.fillRect(0, 0, canvas.width, canvas.height);

	// --- Event: quit button ---
	quitButton.addEventListener('click', quitButtonHandler);
	
	drawGame(gameState, ctx);

	clientSocketHandler(scoreDisplay, gameMode, ctx);

	return container;
}


function drawGame(state: GameState, ctx: CanvasRenderingContext2D) {
	
	// Efface tout le canvas
	ctx.fillStyle = BG_COLOUR;
	ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
	 
	// DRAW BALL
	const ball = state.ball;
	 
	ctx.fillStyle = BALL_COLOUR;
	ctx.beginPath();
	ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
	ctx.fill();
	ctx.closePath();
	
	ctx.fillStyle = PADDLE_COLOUR;
	
	// DRAW LEFT PADDLE
	const leftPaddle = state.leftPaddle;
	
	ctx.fillRect(leftPaddle.x, leftPaddle.y, PADDLE_WIDTH, PADDLE_HEIGHT);
	
	// DRAW RIGHT PADDLE
	const rightPaddle = state.rightPaddle;
	
	ctx.fillRect(rightPaddle.x, rightPaddle.y, PADDLE_WIDTH, PADDLE_HEIGHT);
	
	
}

async function quitButtonHandler() {
	const confirmed = await showCustomConfirm("Are you sure you want to quit this game?");
	
	if (confirmed) {
		// const matchId = sessionStorage.getItem('matchId');
		// const opponentId = sessionStorage.getItem('opponent');
		isGameOver = true;
		socket.emit('quitGame');
		cleanupSocket(socket);
		sessionStorage.clear(); // clean storage --> users have to put there aliases again
		navigateTo('/local-game');
		isGameOver = false;
	}
}

// Function to set usernames if they're playing in remote
function setBoard(leftUsername: HTMLDivElement, rightUsername: HTMLDivElement) {
	const side = sessionStorage.getItem('side');
	const displayName = sessionStorage.getItem('displayName');
	const opponent = sessionStorage.getItem('opponent');
	
	if (side === 'left') {
		leftUsername.textContent = displayName;
		rightUsername.textContent = opponent;
	} else if (side === 'right') {
		leftUsername.textContent = opponent;
		rightUsername.textContent = displayName;
	}
}


function clientSocketHandler(scoreDisplay: HTMLDivElement, gameMode: string | null, ctx: CanvasRenderingContext2D) {
	
	if (!socket.connected) {
		socket.connect();
	}
	
	socket.emit('start');
	
	document.addEventListener('keydown', keydown);
	document.addEventListener('keyup', keyup);

	socket.on('gameState', (state: GameState) => {
		handleGameState(state, ctx);
	});

	socket.on('scoreUpdated', ({ score1, score2 }: {score1: number, score2: number})  => {
		if (scoreDisplay) {
			scoreDisplay.textContent = `${score1} - ${score2}`;
		}
	});

	socket.on('gameOver', () => {
		isGameOver = true;
		// showToast ? You want to play again ? 
		cleanupSocket(socket);
		sessionStorage.clear();
		navigateTo('/local-game');
		isGameOver = false;
	});
	
}

function keydown(e: KeyboardEvent) {
//	console.log(e);
	socket.emit('keydown', e.keyCode);
}

function keyup(e: KeyboardEvent) {
	socket.emit('keyup', e.keyCode);
}


function handleGameState(state: GameState, ctx: CanvasRenderingContext2D) {
	if (isGameOver) return;
	requestAnimationFrame(() => drawGame(state, ctx));
}


async function getDisplayName(userId: number) : Promise<string> {
	const userRes = await fetch(`api/users/${userId}`);
	if (!userRes.ok) throw new Error('Failed to fetch user info');
	const userData = await userRes.json();
	const displayName = userData.display_name;
	
	return displayName;
}

async function getUserAvatar(userId: number) : Promise<string> {
	const userRes = await fetch(`/api/users/${userId}`);
	if (!userRes.ok) throw new Error('Failed to fetch user info');
	const userData = await userRes.json();
	const url: string = userData.avatar_url;
	
	return url;
}

// function startOnlineGame(socket: SocketIOClient.Socket) {
	
// 	const side = sessionStorage.getItem('side');
// 	let paddleMovement = 0;

// 	document.addEventListener('keydown', (event) => {
	// 		if (event.key === 'ArrowUp') {
		// 			paddleMovement = -1;
		// 		} else if (event.key === 'ArrowDown') {
			// 			paddleMovement = 1;
			// 		}
			// 		socket.emit('playerMove', {
				// 			side,
				// 			paddleMovement,
				// 		});
				// 	})
				
				// 	document.addEventListener('keyup', (event) => {
					// 		if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
						// 			paddleMovement = 0;
						// 			socket.emit('playerMove', {
							// 				side,
							// 				paddleMovement,
							// 			});
							// 		}
							// 	});
							
							// socket.on('stateUpdate', (data: string) => {
	// 	const { leftPaddleUpdated, rightPaddleUpdated, ballUpdated } = JSON.parse(data);
	// 	document.getElementById('left-paddle')!.style.top = `${leftPaddleUpdated}px`;
	// 	document.getElementById('right-paddle')!.style.top = `${rightPaddleUpdated}px`;
	// 	document.getElementById('ball')!.style.left = `${ballUpdated.x}px`;
	// 	document.getElementById('ball')!.style.top = `${ballUpdated.y}px`;
	// });
	
	//}
	

// socket.on('gameFinished', async (matchId: string) => {
	// 	try {
		// 		const matchRes = await fetch(`/api/game/match/${matchId}`);
		// 		if (!matchRes.ok) throw new Error('Failed to fetch match info');
		// 		const matchData = await matchRes.json();
		// 		const data = matchData.data;
		// 		const player1: number = data.player1_id; // userid
		// 		const player2: number = data.player2_id;
		// 		const score1: number = data.player1_score;
		// 		const score2: number = data.player2_score;
		
		// 		const url1: string = await getUserAvatar(player1);
		// 		const url2: string = await getUserAvatar(player2);
		// 		const name1: string = await getDisplayName(player1);
// 		const name2: string = await getDisplayName(player2);

// 		setTimeout(() => {
	// 			showGameResult(name1, name2, score1, score2, url1, url2);
	// 		}, 2000);
	
	// 	} catch (err: unknown) {
		// 		console.log(`Failed to fetch data from db: ${err}`);
		// 	}
		// });
// app/frontend/src/pages/profilePage.ts
// profilePage.ts
import { navigateTo } from '../services/router.js';
import { getUserDataFromStorage, fetchUserDetails } from '../services/authService.js';
import { fetchCsrfToken } from '../services/csrf.js';
import { User } from '../shared/schemas/usersSchemas.js';
import { HeaderComponent } from '../components/headerComponent.js';
import { showToast } from '../components/toast.js';
import { MatchHistoryComponent } from '../components/matchHistoryComponent.js';

export async function ProfilePage(params: { userId?: string }): Promise<HTMLElement> {
	const loggedInUser: User | null = getUserDataFromStorage();

	if (!loggedInUser) {
		navigateTo('/login');
		const redirectMsg = document.createElement('div');
		redirectMsg.className = 'min-h-screen flex items-center justify-center text-xl';
		redirectMsg.textContent = 'Redirection vers la page de connexion...';
		return redirectMsg;
	}

	const userIdToViewStr = params.userId;
	const userIdToView = userIdToViewStr ? parseInt(userIdToViewStr, 10) : loggedInUser.id;

	if (isNaN(userIdToView)) {
		const errorMsg = document.createElement('div');
		errorMsg.className = 'min-h-screen flex items-center justify-center text-xl text-red-500';
		errorMsg.textContent = 'ID utilisateur invalide.';
		return errorMsg;
	}

	try {
		await fetchCsrfToken();
	} catch (error) {
		console.error("√âchec de la r√©cup√©ration du jeton CSRF:", error);
		showToast("Erreur d'initialisation de la s√©curit√©. Veuillez rafra√Æchir.", 'error');
		const errorMsg = document.createElement('div');
		errorMsg.className = 'min-h-screen flex items-center justify-center text-xl text-red-500';
		errorMsg.textContent = 'Erreur de s√©curit√©. Veuillez rafra√Æchir la page.';
		return errorMsg;
	}

	const pageContainer = document.createElement('div');
	pageContainer.className = 'min-h-screen bg-gray-200 p-4 sm:p-8 flex flex-col items-center';

	const profileWrapper = document.createElement('div');
	profileWrapper.className = 'bg-white rounded-2xl shadow-2xl w-full max-w-6xl flex flex-col overflow-hidden';

	const headerElement = HeaderComponent({ currentUser: loggedInUser });
	profileWrapper.appendChild(headerElement);

	const mainSection = document.createElement('div');
	mainSection.className = 'flex flex-1 min-h-[calc(100vh-150px)]';
	profileWrapper.appendChild(mainSection);
	pageContainer.appendChild(profileWrapper);

	const contentArea = document.createElement('div');
	contentArea.className = 'flex flex-1';
	mainSection.appendChild(contentArea);

	const loadingProfileMsg = document.createElement('p');
	loadingProfileMsg.className = 'text-center text-gray-500 py-20 flex-1 text-lg';
	loadingProfileMsg.textContent = 'Chargement du profil...';
	contentArea.appendChild(loadingProfileMsg);

	try {
		const profiledUser = await fetchUserDetails(userIdToView);

		if (!profiledUser) {
			loadingProfileMsg.textContent = `Profil utilisateur avec ID ${userIdToView} non trouv√©.`;
			loadingProfileMsg.classList.remove('text-gray-500');
			loadingProfileMsg.classList.add('text-red-500');
			return pageContainer;
		}

		loadingProfileMsg.remove();

		// --- Sidebar (infos de l'utilisateur `profiledUser`) ---
		const sidebar = document.createElement('aside');
		sidebar.className = 'w-1/4 p-6 bg-gray-50 border-r border-gray-200 space-y-4 overflow-y-auto flex flex-col';

		function createSidebarItem(label: string, value: string | number | Date | undefined | null, isSensitive: boolean = false): HTMLElement | null {
			if (isSensitive && loggedInUser!.id !== profiledUser.id) {
				return null;
			}

			const item = document.createElement('div');
			item.className = 'p-3 bg-white border border-gray-200 rounded-lg shadow-sm';
			const labelEl = document.createElement('span');
			labelEl.className = 'text-xs text-gray-500 block mb-0.5 uppercase tracking-wider';
			labelEl.textContent = label;
			const valueEl = document.createElement('p');
			valueEl.className = 'text-sm text-gray-800 font-medium truncate';
			if (value instanceof Date) {
				valueEl.textContent = value.toLocaleDateString();
			} else {
				valueEl.textContent = value?.toString() || 'N/A';
			}
			item.appendChild(labelEl);
			item.appendChild(valueEl);
			return item;
		}

		// Affichage de l'avatar dans la sidebar
		const avatarContainer = document.createElement('div');
		avatarContainer.className = 'flex flex-col items-center mb-4';
		const avatarImg = document.createElement('img');
		avatarImg.src = profiledUser.avatar_url || `https://ui-avatars.com/api/?name=${encodeURIComponent(profiledUser.display_name)}&background=random&color=fff&size=128`;
		avatarImg.alt = `Avatar de ${profiledUser.display_name}`;
		avatarImg.className = 'w-24 h-24 sm:w-32 sm:h-32 rounded-full object-cover border-4 border-gray-200 shadow-md mb-2';
		avatarContainer.appendChild(avatarImg);

		const displayNameEl = document.createElement('h2');
		displayNameEl.className = 'text-xl font-semibold text-gray-800 text-center';
		displayNameEl.textContent = profiledUser.display_name;
		avatarContainer.appendChild(displayNameEl);

		sidebar.appendChild(avatarContainer);

		const infoItems = [
			createSidebarItem('Email', profiledUser.email, true), // isSensitive = true
			createSidebarItem('Date de cr√©ation', new Date(profiledUser.created_at)),
			createSidebarItem('Victoires', profiledUser.wins ?? 0),
			createSidebarItem('D√©faites', profiledUser.losses ?? 0),
			createSidebarItem('Statut', profiledUser.status),
		];
		infoItems.forEach(item => item && sidebar.appendChild(item));

		// --- Contenu principal (Match History uniquement) ---
		const contentWrapper = document.createElement('main');
		contentWrapper.className = 'w-3/4 p-6 flex flex-col overflow-y-auto';

		const matchHistoryElement = await MatchHistoryComponent({ userId: profiledUser.id });
		contentWrapper.appendChild(matchHistoryElement);

		contentArea.appendChild(sidebar);
		contentArea.appendChild(contentWrapper);

	} catch (error) {
		console.error("Erreur lors de la construction de la page de profil:", error);
		loadingProfileMsg.textContent = `Erreur lors du chargement du profil : ${(error as Error).message}. Veuillez r√©essayer.`;
		loadingProfileMsg.classList.remove('text-gray-500');
		loadingProfileMsg.classList.add('text-red-500');
	}

	return pageContainer;
}
// app/frontend/src/pages/settingsPage.ts
// /pages/profilePage.ts
import { getUserDataFromStorage, updateUserProfile } from '../services/authService.js';
import { navigateTo } from '../services/router.js';
import { User, UpdateUserPayload } from '../shared/schemas/usersSchemas.js';
import { ApiResult } from '../utils/types.js';
import { SettingsForm } from '../components/settingsForm.js'; // Importer le composant
import { fetchCsrfToken } from '../services/csrf.js';

export async function SettingsPage(): Promise<HTMLElement> {
	const user: User | null = getUserDataFromStorage();

	const pageContainer = document.createElement('div'); // Conteneur principal de la page
	pageContainer.className = 'min-h-screen bg-gray-100 p-4 md:p-8';

	if (!user) {
		console.warn('Access unauthorized: User not authenticated.');
		navigateTo('/login');

		const deniedContainer = document.createElement('div');
		deniedContainer.className = 'flex items-center justify-center h-full'; // Pour centrer dans pageContainer
		deniedContainer.innerHTML = `
            <div class="bg-white rounded-xl shadow-lg p-8 text-center">
                <h1 class="text-2xl font-bold text-red-600 mb-4">Acc√®s Refus√©</h1>
                <p class="text-gray-700 mb-4">Vous devez √™tre connect√© pour acc√©der √† votre profil.</p>
                <p class="text-gray-700">Redirection vers la page de connexion...</p>
                <!-- <a href="/login" data-link class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                    Se connecter
                </a> -->
            </div>
        `;
		pageContainer.appendChild(deniedContainer);
		return pageContainer;
	}


	try {
		await fetchCsrfToken();
	} catch (error) {
		console.error("Failed to fetch CSRF token:", error);
		const errorMsg = document.createElement('div');
		errorMsg.className = 'min-h-screen flex items-center justify-center text-xl text-red-500';
		errorMsg.textContent = 'Error initializing page. Please try refreshing.';
		return errorMsg;
	}

	const contentWrapper = document.createElement('div');
	contentWrapper.className = 'max-w-xl mx-auto bg-white rounded-xl shadow-lg p-6 md:p-8';

	const title = document.createElement('h1');
	title.className = 'text-3xl font-bold text-gray-800 mb-6 border-b pb-4';
	title.textContent = 'Mon Profil';
	contentWrapper.appendChild(title);

	// Fonction de rappel pour la mise √† jour du profil
	const handleProfileUpdate = async (payload: UpdateUserPayload): Promise<ApiResult> => {
		const result = await updateUserProfile(payload);
		if (result.success) {
			console.log('Profile updated in service, local storage should be updated too.');
		}
		setTimeout(() => { navigateTo('/dashboard'); }, 500);
		return result;
	};

	// Cr√©er et ajouter le composant formulaire
	const profileFormComponent = SettingsForm({
		user: user, // Passer l'utilisateur actuel au composant
		onProfileUpdate: handleProfileUpdate,
	});
	contentWrapper.appendChild(profileFormComponent);

	// Lien de retour
	const backLink = document.createElement('a');
	backLink.href = '/dashboard';
	backLink.setAttribute('data-link', ''); // Pour le routeur
	backLink.className = 'block text-center text-gray-600 hover:text-gray-800 text-sm mt-6'; // Style ajust√©
	backLink.textContent = 'Retour au Tableau de Bord';

	// V√©rifier si le formulaire existe avant d'essayer de l'ins√©rer
	const formElement = contentWrapper.querySelector('#profile-form-component');
	if (formElement && formElement.parentNode) {
		// Ins√©rer le lien apr√®s la derni√®re div du formulaire (celle avec le bouton)
		const lastDivInForm = formElement.children[formElement.children.length - 1];
		if (lastDivInForm && lastDivInForm.parentNode) {
			(lastDivInForm.parentNode as HTMLElement).insertBefore(backLink, lastDivInForm.nextSibling);
		} else {
			contentWrapper.appendChild(backLink); // Fallback
		}
	} else {
		contentWrapper.appendChild(backLink); // Fallback
	}

	pageContainer.appendChild(contentWrapper);
	return pageContainer;
}
// app/frontend/src/pages/homePage.ts
export function HomePage(): HTMLElement {

	const container = document.createElement('div');
	// --- LE FOND JUNGLE ---
	container.className = 'relative bg-cover bg-center min-h-screen text-white flex flex-col items-center justify-between p-4 sm:p-8';
  container.style.backgroundImage = "url('https://images.unsplash.com/photo-1470058869958-2a77ade41c02?w=500&auto=format&fit=crop&q=60&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxzZWFyY2h8MXx8anVuZ2xlfGVufDB8fDB8fHww')";
	// container.style.backgroundImage = "url('https://images.unsplash.com/photo-1516528387618-afa90b13e000?w=500&auto=format&fit=crop&q=60&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxzZWFyY2h8M3x8anVuZ2xlfGVufDB8fDB8fHww')";
	
  // --- SUPERPOSITION SOMBRE ---
	const overlay = document.createElement('div');
	overlay.className = 'absolute inset-0 bg-black/40';

	// --- EN-T√äTE (Login/Register) ---
	const header = document.createElement('header');
	header.className = 'relative z-10 w-full flex justify-between items-center';
	
	const logo = document.createElement('h1');
	logo.className = 'text-2xl sm:text-3xl font-bold tracking-wider text-shadow';
	logo.innerHTML = `üèì <span class="hidden sm:inline">King-Pong</span>`;
	
	const authLinks = document.createElement('div');
	authLinks.className = 'flex items-center space-x-2 sm:space-x-4';
	authLinks.innerHTML = `
		<a href="/login" data-link class="text-sm sm:text-base font-semibold px-4 py-2 rounded-full hover:bg-white hover:bg-opacity-20 transition-colors duration-300">
			Login
		</a>
		<a href="/register" data-link class="text-sm sm:text-base bg-green-600 hover:bg-green-500 text-white font-bold px-4 py-2 rounded-full shadow-lg transition-transform duration-300 transform hover:scale-105">
			Register
		</a>
	`;
	header.appendChild(logo);
	header.appendChild(authLinks);

	// --- SECTION PRINCIPALE (Titre et bouton PLAY) ---
	const mainContent = document.createElement('main');
	mainContent.className = 'relative z-10 flex flex-col items-center text-center';

	const title = document.createElement('h2');
	title.className = 'text-4xl sm:text-6xl md:text-7xl font-extrabold mb-4 text-shadow-lg';
	title.textContent = 'The Ultimate Jungle Pong';

	const subtitle = document.createElement('p');
	subtitle.className = 'text-lg sm:text-xl text-gray-200 mb-12 max-w-2xl text-shadow';
	subtitle.textContent = 'Dominate the table. Become the King.';
	
	const playButton = document.createElement('a');
	playButton.href = '/local-game';
	playButton.setAttribute('data-link', '');
	playButton.className = `
		bg-red-600 hover:bg-red-500 text-white font-black 
		text-2xl sm:text-4xl py-4 sm:py-6 px-10 sm:px-16 rounded-full shadow-2xl 
		uppercase tracking-widest 
		transition-all duration-300 ease-in-out 
		transform hover:scale-110 hover:shadow-red-500/50
	`;
	playButton.textContent = 'PLAY';

	mainContent.appendChild(title);
	mainContent.appendChild(subtitle);
	mainContent.appendChild(playButton);

	// --- PIED DE PAGE (Lien API discret) ---
	const footer = document.createElement('footer');
	footer.className = 'relative z-10 w-full text-center';
	
	const apiLink = document.createElement('a');
	apiLink.href = '/game';
	apiLink.setAttribute('data-link', '');
	apiLink.className = 'text-xs text-gray-400 hover:text-white hover:underline transition-colors duration-300';
	apiLink.textContent = 'Check Game API';
	
	footer.appendChild(apiLink);

	// --- Assemblage de la page ---
	container.appendChild(overlay);
	container.appendChild(header);
	container.appendChild(mainContent);
	container.appendChild(footer);

	// --- Ajout des styles ---
	const style = document.createElement('style');
	style.textContent = `
		.text-shadow { text-shadow: 0 2px 4px rgba(0,0,0,0.5); }
		.text-shadow-lg { text-shadow: 0 4px 8px rgba(0,0,0,0.5); }
	`;
	container.appendChild(style);

	return container;
}


	
// app/frontend/src/pages/loginPage.ts
// /pages/loginPage.ts
import { attemptLogin } from '../services/authService.js';
import { navigateTo } from '../services/router.js';
import { LoginForm } from '../components/loginForm.js';
import { LoginRequestBody } from '../shared/schemas/usersSchemas.js';
import { ApiResult } from '../utils/types.js';

export function LoginPage(): HTMLElement {
	const container = document.createElement('div');
	container.className = 'bg-white flex justify-center items-center min-h-screen p-8';
	
	const formContainer = document.createElement('div');
	formContainer.className = 'bg-white bg-opacity-90 backdrop-filter backdrop-blur-lg rounded-xl shadow-2xl p-8 max-w-md w-full';

	const title = document.createElement('h2');
	title.className = 'text-3xl font-bold mb-6 text-center text-gray-800';
	title.textContent = 'Login';

	formContainer.appendChild(title);

	// Fonction de rappel pour la soumission du formulaire
	const handleLoginAttempt = async (credentials: LoginRequestBody): Promise<ApiResult> => {
		return attemptLogin(credentials);
	};

	// Fonction de rappel pour le succ√®s de la connexion
	const handleLoginSuccess = (userData: any) => {
		setTimeout(() => { navigateTo('/dashboard'); }, 500);
	};

	// Cr√©er et ajouter le composant formulaire
	const loginFormComponent = LoginForm({
		onLoginAttempt: handleLoginAttempt,
		onLoginSuccess: handleLoginSuccess,
	});
	formContainer.appendChild(loginFormComponent);


	const linksDiv = document.createElement('div');
	linksDiv.className = 'mt-6 text-center';
	linksDiv.innerHTML = `
        <a href="/" data-link class="text-blue-600 hover:text-blue-800 text-sm">
            Back to Home
        </a>
        <span class="mx-2 text-gray-400">|</span>
        <a href="/register" data-link class="text-blue-600 hover:text-blue-800 text-sm">
            Don't have an account? Register
        </a>
    `;
	formContainer.appendChild(linksDiv);

	container.appendChild(formContainer);

	return container;
}
// app/frontend/src/images.d.ts
declare module '*.jpg' {
  const value: string;
  export default value;
}// app/frontend/src/main.ts
import { HomePage } from './pages/homePage.js';
import { LoginPage } from './pages/loginPage.js'
import { RegisterPage } from './components/registerPage.js'
// import { UsersPage } from './pages/userPage.js';
import { GamePage } from './components/gamePage.js';
import { GameRoomPage } from './pages/gameRoomPage.js';
import { navigateTo } from './services/router.js';
import { DashboardPage } from './pages/dashboardPage.js'
import { SettingsPage } from './pages/settingsPage.js';
import { ProfilePage } from './pages/profilePage.js';
import { getUserDataFromStorage } from './services/authService.js';
import { promptAliasForm } from './components/aliasFormPage.js';
import { GameMode } from './components/gamePage.js'
// import './style/input.css';

// Conteneur o√π le contenu de la page sera inject√©
const appContainer = document.getElementById('main');

interface RouteConfig {
    component: (params?: { [key: string]: string }) => HTMLElement | Promise<HTMLElement>;
    requiredAuth?: boolean;
}

function renderNotFoundPage(): HTMLElement {
	const div = document.createElement('div');
	div.innerHTML = `
        <h1 class="text-3xl font-bold text-red-500 text-center p-8">404 - Page Non Trouv√©e</h1>
        <p class="text-center">Oups! Cette page n'existe pas.</p>
        <div class="text-center mt-4">
            <a href="/" data-link class="text-blue-500 hover:underline">Retour √† l'accueil</a>
        </div>
    `;
	return div;
}

const routes: { [key: string]: RouteConfig } = {
    '/': { component: HomePage },
    // '/users': { component: UsersPage },
    '/login': { component: LoginPage },
    '/register': { component: RegisterPage },
    '/dashboard': { component: DashboardPage, requiredAuth: true },
    '/profile': { component: SettingsPage, requiredAuth: true },
    '/profile/:id': {
        component: (params) => ProfilePage(params ?? {}),
        requiredAuth: true
    },
    '/game': { component: GamePage },
    '/local-game': { component: promptAliasForm },
    '/game-room': { component: () => GameRoomPageFromParams() },
};

function GameRoomPageFromParams(): HTMLElement {
	const urlParams = new URLSearchParams(window.location.search);
	const mode = urlParams.get('mode') as GameMode || 'local';
	return GameRoomPage(mode);
}

export async function router() {
    if (!appContainer) {
        console.error("ERREUR: Le conteneur #app est introuvable dans le DOM !");
        return;
    }
    const path = window.location.pathname;
    console.log(`navigateTo: ${path}`);

    let routeCfg = routes[path];
    let params: { [key: string]: string } = {};

    // Gestion des routes dynamiques (ex: /profile/:id)
    if (!routeCfg) {
        // Cherche une route dynamique qui matche
        for (const routePattern in routes) {
            if (routePattern.includes('/:')) {
                const base = routePattern.split('/:')[0];
                if (path.startsWith(base + '/')) {
                    const paramName = routePattern.split('/:')[1];
                    const paramValue = path.slice(base.length + 1);
                    routeCfg = routes[routePattern];
                    params[paramName] = paramValue;
                    break;
                }
            }
        }
    }

    if (!routeCfg) {
        appContainer.innerHTML = '';
        appContainer.appendChild(renderNotFoundPage());
        return;
    }
    if (routeCfg.requiredAuth) {
        const authData = getUserDataFromStorage();
        if (!authData) {
            console.log('Utilisateur non authentifi√©, redirection vers la page de connexion.');
            navigateTo('/login');
            return;
        }
    }
    const renderFunction = routeCfg.component;
    appContainer.innerHTML = '';
    try {
        // Passe les params √† la page si besoin
        params.userId = params.id;
        const pageContent = await renderFunction(params);
        appContainer.appendChild(pageContent);
    } catch (error) {
        console.error(`Erreur lors du rendu de la route ${path}:`, error);
        appContainer.innerHTML = `<p class="text-red-500 text-center p-8">Une erreur est survenue lors du chargement de la page.</p>`;
    }
}

// Se d√©clenche lorsque le HTML initial est charg√©
document.addEventListener('DOMContentLoaded', () => {
	document.body.addEventListener('click', (event) => {
		const target = event.target as HTMLElement;
		const linkElement = target.closest('a[data-link]') as HTMLAnchorElement | null;
		if (linkElement) {
			event.preventDefault();
			const destination = linkElement.getAttribute('href');
			if (destination) {
				navigateTo(destination);
			}
		}
	});
	router();
});

// Se d√©clenche lorsque l'utilisateur utilise les boutons Pr√©c√©dent/Suivant du navigateur
window.addEventListener('popstate', () => {
	router();
});
// app/frontend/src/shared/schemas/friendsSchemas.ts
import { z } from 'zod';
import { UserBaseSchema, UserOnlineStatusSchema } from './usersSchemas.js';

export enum FriendshipStatus {
	PENDING = 'pending',
	ACCEPTED = 'accepted',
	DECLINED = 'declined', // Pertinent ?
	BLOCKED = 'blocked',
}
export const FriendshipStatusSchema = z.nativeEnum(FriendshipStatus);

// --- Base Schemas ---
export const FriendshipBaseSchema = z.object({
	id: z.number().int(),
	user1_id: z.number().int(),
	user2_id: z.number().int(),
	initiator_id: z.number().int(),
	status: FriendshipStatusSchema,
	created_at: z.string(), // Ou z.string().date()
});
export type Friendship = z.infer<typeof FriendshipBaseSchema>;

export const AdminFullFriendshipSchema = FriendshipBaseSchema.extend({
	user1_username: z.string(),
	user2_username: z.string(),
	initiator_username: z.string(),
});
export type AdminFullFriendship = z.infer<typeof AdminFullFriendshipSchema>;

export const FriendSchema = z.object({
	friendship_id: z.number().int(),
	friendship_status: FriendshipStatusSchema,
	friend_id: z.number().int(),
	friend_username: z.string(),
	friend_display_name: z.string(),
	// friend_avatar_url: z.string().url().nullable().optional(), // re-tester : UserBaseSchema.shape.avatar_url
	friend_avatar_url: UserBaseSchema.shape.avatar_url.optional(),
	friend_wins: z.number().int().default(0),
	friend_losses: z.number().int().default(0),
	friend_online_status: UserOnlineStatusSchema,
});
export type Friend = z.infer<typeof FriendSchema>;

// --- Schemas for API requests (Body, Params, Responses) ---
export const SendFriendRequestBodySchema = z.object({
	friendId: z.number().int().min(1, "Friend ID must be a positive integer."),
});
export type SendFriendRequestBody = z.infer<typeof SendFriendRequestBodySchema>;

export const FriendshipIdParamsSchema = z.object({
	friendshipId: z.string().regex(/^\d+$/, "Friendship ID must be a positive integer."),
});
export type FriendshipIdParams = z.infer<typeof FriendshipIdParamsSchema>;

export const FriendRequestUserSchema = UserBaseSchema.pick({
	id: true,
	username: true,
	// email: true, // email ici ?
	display_name: true,
	avatar_url: true,
});
export type FriendRequestUserData = z.infer<typeof FriendRequestUserSchema>;

export const PendingFriendRequestSchema = z.object({
	friendship_id: z.number().int(),
	requester: FriendRequestUserSchema.optional(),
	receiver: FriendRequestUserSchema.optional(),
	created_at: z.string(),
});
export type PendingFriendRequest = z.infer<typeof PendingFriendRequestSchema>;

//--- Routes Schemas ---
export const SendFriendRequestRouteSchema = {
	body: SendFriendRequestBodySchema,
	response: {
		201: z.object({
			message: z.string(),
			friendship: FriendshipBaseSchema
		})
	}
};

export const MessageResponseSchema = z.object({ message: z.string() });
export const FriendshipActionRouteSchema = {
	params: FriendshipIdParamsSchema,
	response: {
		200: MessageResponseSchema
	}
};

export const FriendsListResponseSchema = z.array(FriendSchema);
export const GetFriendsListRouteSchema = {
	response: {
		200: FriendsListResponseSchema
	}
};

export const PendingRequestsResponseSchema = z.array(PendingFriendRequestSchema);
export const GetPendingRequestsRouteSchema = {
	response: {
		200: PendingRequestsResponseSchema
	}
};

// app/frontend/src/shared/schemas/usersSchemas.ts
import { z } from 'zod';

export enum UserOnlineStatus {
	ONLINE = 'online',
	OFFLINE = 'offline',
	IN_GAME = 'in-game',
}
export const UserOnlineStatusSchema = z.nativeEnum(UserOnlineStatus);

// --- Base Schemas ---
export const UserBaseSchema = z.object({
    id: z.number().int(),
    username: z.string().min(3).max(20),
    email: z.string().email(),
    display_name: z.string().min(3).max(20),
    avatar_url: z.string().url().nullable(),
    wins: z.number().int().default(0),
    losses: z.number().int().default(0),
    status: UserOnlineStatusSchema.default(UserOnlineStatus.OFFLINE),
    created_at: z.string(), // Ou z.date()
    updated_at: z.string(), // Ou z.date()
});
export type User = z.infer<typeof UserBaseSchema>;

export const UserWithPasswordHashSchema = UserBaseSchema.extend({
    password_hash: z.string(),
});
export type UserWithPasswordHash = z.infer<typeof UserWithPasswordHashSchema>;

// --- Schemas for API requests (Body, Params, Responses) ---

// REGISTER
export const RegisterBodySchema = z.object({
    username: UserBaseSchema.shape.username,
    email: UserBaseSchema.shape.email,
    password: z.string().min(8).max(100),
    display_name: UserBaseSchema.shape.display_name,
    avatar_url: UserBaseSchema.shape.avatar_url.optional(),
});
export type RegisterRequestBody = z.infer<typeof RegisterBodySchema>;

export const RegisterRouteSchema = {
    body: RegisterBodySchema,
    response: {
        201: z.object({ message: z.string() })
    }
};

// LOGIN
export const LoginBodySchema = z.object({
    identifier: z.string().min(1),
    password: z.string().min(1),
});
export type LoginRequestBody = z.infer<typeof LoginBodySchema>;

export const LoginRouteSchema = {
    body: LoginBodySchema,
    response: {
        200: z.object({
            message: z.string(),
            user: UserBaseSchema,
            // csrfToken: z.string().optional(),
        })
    }
};

export const LogoutRouteSchema = {
    response: {
        200: z.object({
            message: z.string()
        })
    }
};

// GET ALL USERS
export const GetUsersListRouteSchema = {
    response: {
        200: z.array(UserBaseSchema)
    }
};

// GET /me
export const GetMeRouteSchema = {
    response: {
        200: UserBaseSchema
    }
};

// UPDATE USER
export const UpdateUserBodySchema = z.object({
    email: UserBaseSchema.shape.email.optional(),
    display_name: UserBaseSchema.shape.display_name.optional(),
    avatar_url: UserBaseSchema.shape.avatar_url.optional(),
}).refine(data => Object.keys(data).length > 0, {
    message: "At least one change."
});
export type UpdateUserPayload = z.infer<typeof UpdateUserBodySchema>;

export const UpdateUserRouteSchema = {
    body: UpdateUserBodySchema,
    response: {
        200: z.object({
            message: z.string(),
            user: UserBaseSchema
        })
    }
};

export const UpdatedDbResultSchema = z.object({
	changes: z.number().int().optional(),
});
export type UpdatedUserResult = z.infer<typeof UpdatedDbResultSchema>;

// GET USER BY ID
export const UserIdParamsSchema = z.object({
    userId: z.string().regex(/^\d+$/, "User ID must be a positive integer."),
});
export type UserIdParams = z.infer<typeof UserIdParamsSchema>;

export const GetUserByIdRouteSchema = {
    params: UserIdParamsSchema,
    response: {
        200: UserBaseSchema,
        404: z.object({ error: z.string() })
    }
};

// --- Sch√©mas pour la couche Service/Mod√®le (si diff√©rent de l'API) ---
export const CreateUserPayloadSchema = z.object({
    username: UserBaseSchema.shape.username,
    email: UserBaseSchema.shape.email,
    password_hash: z.string(),
    display_name: UserBaseSchema.shape.display_name,
    avatar_url: UserBaseSchema.shape.avatar_url.optional(),
});
export type CreateUserPayload = z.infer<typeof CreateUserPayloadSchema>;

export const JWTPayloadSchema = z.object({
    id: z.number().int(),
    username: z.string(),
    iat: z.number().optional(), // JWT ajoute ces champs automatiquement
    exp: z.number().optional(),
});
export type JWTPayload = z.infer<typeof JWTPayloadSchema>;

// app/frontend/src/shared/schemas/matchesSchemas.ts
// Game match schemas
import { z } from 'zod';

export enum MatchStatus {
    PENDING = 'pending',
    IN_PROGRESS = 'in_progress',
    FINISHED = 'finished'
}

export const MatchStatusSchema = z.nativeEnum(MatchStatus);

// --- Base Schemas ---
export const MatchBaseSchema = z.object({
    id: z.number().int(),
    matchId: z.string(), // ou i min
    player1_id: z.number().int(),
    player2_id: z.number().int(),
    player1_socket: z.string(),
    player2_socket: z.string(),
    player1_score: z.number().int().min(0).max(10),
    player2_score: z.number().int().min(0).max(10),
    winner_id: z.number().int(),
    win_type: z.string(),
    created_at: z.string(), // Ou z.date()
    // game_type: z.string(), // ajout arthur au cas ou
    // tournament_id: z.number().int().nullable(), // ajout arthur au cas ou
    // isLocal: z.boolean().default(false), // ajout arthur au cas ou
    status: MatchStatusSchema.default(MatchStatus.PENDING)

});

export type Match = z.infer<typeof MatchBaseSchema>;

// --- Schemas for API requests (Body, Params, Responses) ---

//-- Match creation for localGame
export const createLocalMatchBody = z.object({
    player1: z.string().min(1),
    player2: z.string().min(1),
    isLocal: z.boolean(),
}).strict();

export type createLocalMatchRequestBody = z.infer<typeof createLocalMatchBody>;

export const createLocalMatchRouteSchema = {
    body: createLocalMatchBody,
    response: {
        201: z.object({ message: z.string() })
    }
};

// GET MATCH by MATCH_ID (unique URL)
export const MatchIdParamsSchema = z.object({
    matchId: z.string().uuid()
})

export type MatchIdParams = z.infer<typeof MatchIdParamsSchema>;

export const GetMatchIdRouteSchema = {
    params: MatchIdParamsSchema,
    response: {
        200: MatchBaseSchema,
        404: z.object({ error: z.string() })
    }
};

// GET MATCH HISTORY by USER_ID
export const MatchUserIdParamsSchema = z.object({
    userId: z.string().regex(/^\d+$/, "User ID must be a positive integer."),
    // userId: z.number().int(), // check avec arthur ? pourquoi il utilise regex -> parce que fastify t'envoie une string
});

export type MatchUserIdParams = z.infer<typeof MatchUserIdParamsSchema>;

export const GetMatchByUserIdRouteSchema = {
    params: MatchUserIdParamsSchema,
    response: {
        200: z.array(MatchBaseSchema),
        400: z.object({ error: z.string() }),
        500: z.object({ error: z.string() })
    }
}// app/frontend/postcss.config.cjs
module.exports = {
  plugins: {
    '@tailwindcss/postcss': {},
    autoprefixer: {},
  },
}
// app/frontend/vite.config.ts
import { defineConfig } from 'vite'

export default defineConfig({

})// app/frontend/.dockerignore
# Node modules (can be installed with npm install)
node_modules/
# ignore git history
.git
# ignore cache directory
.DS_Store// app/frontend/package.json
{
  "name": "frontend",
  "version": "1.0.0",
  "description": "Frontend application for Ping-Pong",
  "type": "module",
  "main": "index.js",
  "scripts": {
   "prepare:dist": "mkdir -p ./dist/css ./dist/js",
    "build:clean": "rm -rf ./dist/*",
    "build:html": "cp index.html ./dist/index.html",
    "build:ts": "tsc",
    "build:css": "./node_modules/.bin/tailwindcss -i ./src/style/input.css -o ./dist/css/style.css --minify",
    "build": "npm run build:clean && npm run prepare:dist && npm run build:html && npm run build:ts && npm run build:css",
    "watch:ts": "tsc --watch > ./logs/tsc.log 2>&1",
    "watch:css": "./node_modules/.bin/tailwindcss -i ./style/input.css -o ./dist/css/style.css --watch > ./logs/tailwind.log 2>&1",
    "dev": "npm run build && mkdir -p ./logs && concurrently \"npm run watch:ts\" \"npm run watch:css\""
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@tailwindcss/cli": "^4.1.4",
    "@tailwindcss/postcss": "^4.1.8",
    "@tailwindcss/vite": "^4.1.8",
    "@types/node": "^22.15.17",
    "@types/socket.io-client": "^1.4.36",
    "autoprefixer": "^10.4.21",
    "concurrently": "^9.1.2",
    "http-server": "^14.1.1",
    "postcss": "^8.5.4",
    "tailwindcss": "^4.1.8"
  },
  "dependencies": {
    "@fastify/cookie": "^11.0.2",
    "@fastify/csrf-protection": "^7.1.0",
    "@types/bcrypt": "^5.0.2",
    "bcrypt": "^6.0.0",
    "commander": "^13.1.0",
    "dotenv": "^16.5.0",
    "fastify-type-provider-zod": "^4.0.2",
    "socket.io-client": "^4.8.1",
    "typescript": "^5.8.3",
    "vite": "^6.3.5",
    "zod": "^3.24.4"
  }
}
// app/frontend/index.html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>King-Pong</title>
  <link href="css/style.css" rel="stylesheet">
</head>
<body>
  <div id="main"> <!-- contenu de main.ts -->
    <p>Loading application...</p>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/socket.io-client@4.7.2/dist/socket.io.min.js"></script>
<script type="importmap">
{
  "imports": {
    "zod": "https://cdn.jsdelivr.net/npm/zod@3.24.4/lib/index.mjs"
  }
}
</script>
  <script type="module" src="/js/main.js"></script> <!-- routeur principal -->
</body>
</html>

<!-- <script src="js/app.js" defer></script> -->
// app/frontend/tsconfig.json
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "lib": ["ESNext", "DOM"],
    "outDir": "./dist/js"
  },
  "include": ["src/**/*.ts", "src/**/*.d.ts"],
  "exclude": ["node_modules"]
}
// app/services/users/utils/dbConfig.ts
// app/services/users/utils/dbConfig.ts
import sqlite3, { Database as SQLite3Database } from 'sqlite3';
import { open, Database } from 'sqlite';
import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

let db: Database | undefined;

export function getDb(): Database {
	if (!db) throw new Error('DB not initialized');
	return db;
}

export async function initializeDb(): Promise<Database> {
	if (db) return db;

	const dbDir = path.join(__dirname, '..', 'db');
	const dbPath = path.join(dbDir, 'database.sqlite');

	if (!fs.existsSync(dbDir)) {
		fs.mkdirSync(dbDir, { recursive: true });
	}

	if (fs.existsSync(dbPath)) {
		fs.unlinkSync(dbPath);
		console.log('Old database.sqlite removed.');
	}

	try {
		db = await open({
			filename: dbPath,
			driver: sqlite3.Database
		});
		console.log('Database connected!');

		let initSQLPath = path.join(__dirname, '..', 'db', 'init.sql');
		if (!fs.existsSync(initSQLPath)) {
			initSQLPath = path.join(__dirname, '..', '..', 'db', 'init.sql');
		}
		if (fs.existsSync(initSQLPath)) {
			const sql = fs.readFileSync(initSQLPath, 'utf-8');
			await db.exec(sql);
			console.log('Database initialized from init.sql.');
		} else {
			console.warn('init.sql not found. Database not initialized.');
		}
		if (!db) throw new Error("DB failed to initialize after setup.");
		return db;
	} catch (err: any) {
		console.error('Error while connecting to the database:', err.message);
		throw new Error(err.message || 'Database initialization failed');
	}
}
// app/services/users/utils/pswdUtils.ts
// app/services/users/utils/pswdUtils.ts
import bcrypt from 'bcrypt';

const saltRounds: number = 10;

export async function hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, saltRounds);
}

export async function comparePassword(password: string, hash: string): Promise<boolean> {
  return bcrypt.compare(password, hash);
}
// app/services/users/utils/appError.ts
// app/services/users/utils/appError.ts
import { FastifyInstance, FastifyRequest, FastifyReply, FastifyError } from 'fastify';

export class AppError extends Error {
	public statusCode: number;
	constructor(message: string, statusCode: number) {
		super(message);
		this.statusCode = statusCode;
		Object.setPrototypeOf(this, AppError.prototype);
	}
}

export class ValidationError extends AppError {
	constructor(message: string) {
		super(message, 400);
		Object.setPrototypeOf(this, ValidationError.prototype);
	}
}

export class UnauthorizedError extends AppError {
	constructor(message: string) {
		super(message, 401);
		Object.setPrototypeOf(this, UnauthorizedError.prototype);
	}
}
export class ForbiddenError extends AppError {
	constructor(message: string) {
		super(message, 403);
		Object.setPrototypeOf(this, ForbiddenError.prototype);
	}
}

export class NotFoundError extends AppError {
	constructor(message: string) {
		super(message, 404);
		Object.setPrototypeOf(this, NotFoundError.prototype);
	}
}

export class ConflictError extends AppError {
	constructor(message: string) {
		super(message, 409);
		Object.setPrototypeOf(this, ConflictError.prototype);
	}
}

export const ERROR_MESSAGES: Record<string, string> = {
	INVALID_FRIENDSHIP_ID: 'Invalid friendship ID format.',
	USER_NOT_FOUND: 'User not found.',
	FRIEND_REQUEST_NOT_FOUND: 'Friend request not found.',
	FORBIDDEN: 'You are not authorized to perform this action.',
	INVALID_CREDENTIALS: 'Invalid username/email or password.',
	EMAIL_ALREADY_EXISTS: 'Email already exists.',
	USERNAME_ALREADY_EXISTS: 'Username already exists.',
	INVALID_REFRESH_TOKEN: 'Invalid or expired refresh token.',
	REFRESH_TOKEN_MISSING: 'Refresh token missing.',
	SELF_FRIEND_REQUEST: 'You cannot send a friend request to yourself.',
	FRIENDSHIP_ALREADY_EXISTS: 'A friendship or request already exists.',
	DATABASE_ERROR: 'A database error occurred.',
};

// export function setupErrorHandler(fastify: FastifyInstance): void {
// 	fastify.setErrorHandler(function(error: FastifyError | AppError | Error, request: FastifyRequest, reply: FastifyReply) {
// 		request.log.error(error);

// 		let statusCode: number = 500;
// 		let message: string = ERROR_MESSAGES.DATABASE_ERROR;

// 		if (error instanceof AppError) {
//             statusCode = error.statusCode;
//             message = error.message;
//         } else if ((error as FastifyError).statusCode) {
//             statusCode = (error as FastifyError).statusCode!;
//             message = error.message;
//         }
//         const payload = {
// 			error: message,
// 			statusCode: statusCode,
// 		};
//         console.log('--- ERROR HANDLER IS SENDING THIS PAYLOAD ---');
//         console.log(payload);
//         console.log('--- END OF PAYLOAD ---');

// 		reply.code(statusCode).send(payload);
// 	});
// 	fastify.log.info('Error handler registered');
// }
export function setupErrorHandler(fastify: FastifyInstance): void {
	fastify.setErrorHandler(function(error: FastifyError | AppError | Error, request: FastifyRequest, reply: FastifyReply) {
		request.log.error(error);

        // On ignore l'erreur r√©elle pour le test et on forge un payload
        const testPayload = {
            error: "Ceci est un test",
            statusCode: 400
        };

        console.log('--- FORCING THIS TEST PAYLOAD ---', testPayload);
		
        // On envoie le code 400 avec ce payload de test
		reply.code(400).send(testPayload);
	});
	// ...
}// app/services/users/Dockerfile
FROM node:22-alpine

WORKDIR /app

COPY package*.json ./

RUN npm install

COPY . .

#RUN npm run build

#EXPOSE 4000

CMD ["npm", "run", "dev"]
// app/services/users/services/userService.ts
// app/services/users/services/userService.ts
import * as userModel from '../models/userModel.js';
import * as passwordUtils from '../utils/pswdUtils.js';
import { ERROR_MESSAGES, ConflictError, ValidationError, NotFoundError } from '../utils/appError.js';
import { User, LoginRequestBody, RegisterRequestBody, UpdateUserPayload, CreateUserPayload, UserOnlineStatus } from '../shared/schemas/usersSchemas.js';

/**
 * Generates a default avatar URL using ui-avatars.com.
 * @param {string} name - The name to use for generating the avatar.
 * @returns {string} The generated avatar URL.
 */
function generateDefaultAvatarUrl(name: string): string {
	const encodedName = encodeURIComponent(name);
	return `https://ui-avatars.com/api/?name=${encodedName}&background=random&color=fff&size=128`;
}

/**
 * Logs in a user by verifying their credentials.
 * @param {string} params.identifier - The username or email of the user.
 * @param {string} params.password - The user's password.
 * @throws {ValidationError} If the credentials are invalid.
 * @returns {Promise<User>} The user object without the password hash.
 */
export async function loginUser({ identifier, password }: LoginRequestBody): Promise<User> {
	console.log(`Attempting to log user with identifier: ${identifier}`);
	let userEntity;
	const isEmail = identifier.includes('@');
	if (isEmail) {
		userEntity = await userModel.getUserByEmailFromDb(identifier);
	} else {
		userEntity = await userModel.getUserByUsernameFromDb(identifier);
	}

	if (!userEntity || !(await passwordUtils.comparePassword(password, userEntity.password_hash))) {
		throw new ValidationError('Invalid username/email or password.');
	}

	const { password_hash, ...userPassLess } = userEntity;
	return userPassLess;
}

/**
 * Creates a new user account.
 * @param {RegisterRequestBody} userData - The user data for account creation.
 * @throws {ConflictError} If the username or email already exists.
 * @returns {Promise<void>}
 */
export async function createUserAccount(userData: RegisterRequestBody): Promise<void> {
	console.log('Creating a new user account');
	const { username, email, password, display_name, avatar_url } = userData;

	if (await userModel.isUsernameInDb(username)) {
		throw new ConflictError(ERROR_MESSAGES.USERNAME_ALREADY_EXISTS);
	}
	if (await userModel.isDisplayNameInDb(display_name)) {
		throw new ConflictError(ERROR_MESSAGES.DISPLAY_NAME_ALREADY_EXISTS);
	}
	if (await userModel.isEmailInDb(email)) {
		throw new ConflictError(ERROR_MESSAGES.EMAIL_ALREADY_EXISTS);
	}

	const hashedPassword = await passwordUtils.hashPassword(password);
	const payload: CreateUserPayload = {
		username,
		email,
		password_hash: hashedPassword,
		display_name,
		avatar_url: avatar_url && avatar_url.trim() !== "" ? avatar_url : generateDefaultAvatarUrl(display_name),
	};
	await userModel.createUser(payload);
}

/**
 * Retrieves all users from the database.
 * @returns {Promise<Array>} A list of all users.
 */
export async function getAllUsers(): Promise<User[]> {
	console.log('Fetching all users from the database');
	return userModel.getAllUsersFromDb();
}

/**
 * Retrieves a user by their ID.
 * @param {number} userId - The ID of the user to retrieve.
 * @throws {NotFoundError} If the user does not exist.
 * @returns {Promise<Object>} The user object.
 */
export async function getUserById(userId: number): Promise<User> {
	console.log('Fetching user by ID from the database');
	const user = await userModel.getUserByIdFromDb(userId);
	if (!user) {
		throw new NotFoundError('User not found');
	}
	return user;
}

/**
 * Updates the profile of a user.
 * @param {number} userId - The ID of the user to update.
 * @param {Object} updates - The updates to apply to the user's profile.
 * @throws {NotFoundError} If the user does not exist.
 * @throws {ValidationError} If the updates are invalid.
 * @throws {ConflictError} If the updated email or display name is already taken.
 * @returns {Promise<Object>} The updated user object without the password hash.
 */
export async function updateUserProfile(userId: number, updates: UpdateUserPayload): Promise<User> {
	console.log(`Attempting to update profile for user ID: ${userId}`);

	const currentUser = await userModel.getUserByIdFromDb(userId);
	if (!currentUser) {
		throw new NotFoundError(`User with ID ${userId} not found`);
	}

	const processedUpdates: UpdateUserPayload = {};
	if (updates.display_name !== undefined) {
		processedUpdates.display_name = updates.display_name.trim();
	}
	if (updates.email !== undefined) {
		processedUpdates.email = updates.email;
	}
	if (updates.avatar_url !== null) {
		// if (updates.avatar_url !== undefined) {
		processedUpdates.avatar_url = updates.avatar_url;
	}

	const changesToApply: UpdateUserPayload = {};
	for (const key in processedUpdates) {
		const typedKey = key as keyof UpdateUserPayload;
		const value = processedUpdates[typedKey];
		if (value !== null && value !== currentUser[typedKey]) {
			changesToApply[typedKey] = value;
		}
	}
	if (Object.keys(changesToApply).length === 0) {
		console.log(`No effective changes detected for user ${userId}. Profile remains unchanged.`);
		return currentUser;
	}

	if (changesToApply.display_name && await userModel.isDisplayNameInDb(changesToApply.display_name, userId)) {
		throw new ConflictError(`Display name '${changesToApply.display_name}' is already taken.`);
	}
	if (changesToApply.email && await userModel.isEmailInDb(changesToApply.email, userId)) {
		throw new ConflictError(`Email '${changesToApply.email}' is already taken.`);
	}

	try {
		const result = await userModel.updateUserInDb(userId, changesToApply);
		if (!result.changes || result.changes === 0) {
			const finalUserCheck = await userModel.getUserByIdFromDb(userId);
			if (!finalUserCheck) throw new NotFoundError(`User ${userId} disappeared after update attempt or no changes made.`);
			return finalUserCheck;
		}
	} catch (dbError: any) {
		console.error(`Database error during profile update for user ${userId}:`, dbError);
		throw new Error(`Failed to update profile for user ${userId} due to a database issue.`);
	}

	const updatedUser = await userModel.getUserByIdFromDb(userId);
	if (!updatedUser) {
		throw new Error(`Failed to retrieve user ${userId} immediately after successful update.`);
	}
	return updatedUser;
}

/**
 * Updates the status of a user.
 * @param {number} userId - The ID of the user whose status to update.
 * @param {UserOnlineStatus} status - The new online status of the user.
 * @returns {Promise<void>}
 */
export async function updateUserStatus(userId: number, status: UserOnlineStatus): Promise<void> {
	await userModel.updateStatusInDb(userId, status);
}

/**
 * Retrieves a user by their email.
 * @param {string} email - The email of the user to retrieve.
 * @throws {NotFoundError} If the user does not exist.
 * @returns {Promise<Object>} The user object.
 */
export async function getUserByEmail(email: string): Promise<User> {
	console.log('Fetching user by email from the database');
	const userWithHash = await userModel.getUserByEmailFromDb(email);
	if (!userWithHash) {
		throw new NotFoundError('User not found');
	}
	const { password_hash, ...user } = userWithHash;
	return user as User;
}

/**
 * Retrieves a user by their username.
 * @param {string} username - The username of the user to retrieve.
 * @throws {NotFoundError} If the user does not exist.
 * @returns {Promise<Object>} The user object.
 */
export async function getUserByUsername(username: string): Promise<User> {
	console.log('Fetching user by username from the database');
	const userWithHash = await userModel.getUserByUsernameFromDb(username);
	if (!userWithHash) {
		throw new NotFoundError('User not found');
	}
	const { password_hash, ...user } = userWithHash;
	return user as User;
}
// app/services/users/services/friendService.ts
// services/friendService.js
import * as friendModel from '../models/friendModel.js';
import * as userModel from '../models/userModel.js';
import { ConflictError, NotFoundError, ValidationError, ForbiddenError } from '../utils/appError.js';
import { Friend, PendingFriendRequest, Friendship, FriendshipStatus } from '../shared/schemas/friendsSchemas.js';

/**
 * Creates a friend request.
 * @param {number} requesterId - ID of the user sending the request.
 * @param {string} receiverUsername - Username of the user receiving the request.
 * @throws {ValidationError} If required parameters are missing or invalid.
 * @throws {NotFoundError} If the receiver does not exist.
 * @throws {ConflictError} If a friendship or request already exists.
 * @returns {Promise<Friendship>} The created friendship request.
 */
export async function sendFriendRequest(requesterId: number, receiverId: number): Promise<Friendship> {
	if (requesterId === undefined || receiverId === undefined) {
		throw new ValidationError('Requester ID and receiver username are required.');
	}

	const receiver = await userModel.getUserByIdFromDb(receiverId);
	if (!receiver) {
		throw new NotFoundError(`User with username '${receiverId}' not found.`);
	}

	if (requesterId === receiverId) {
		throw new ValidationError("You cannot send a friend request to yourself.");
	}

	const [id1, id2] = requesterId < receiverId ? [requesterId, receiverId] : [receiverId, requesterId];
	const existingFriendship = await friendModel.getFriendshipByUsersInDb(id1, id2);

	if (existingFriendship) {
		if (existingFriendship.status === 'accepted') {
			throw new ConflictError('You are already friends with this user.');
		} else if (existingFriendship.status === 'pending') {
			if (existingFriendship.initiator_id === requesterId) {
				throw new ConflictError('A friend request to this user is already pending from you.');
			} else {
				throw new ConflictError('This user has already sent you a friend request. Please respond to it.');
			}
		} else if (existingFriendship.status === 'declined' || existingFriendship.status === 'blocked') {
			throw new ConflictError(`A previous interaction (${existingFriendship.status}) exists with this user.`);
		}
	}
	return friendModel.createFriendshipRequestInDb(id1, id2, requesterId);
}

/**
 * Accepts a friend request.
 * @param {number} friendshipId - ID of the friendship request.
 * @param {number} currentUserId - ID of the user accepting the request.
 * @throws {NotFoundError} If the friendship request does not exist.
 * @throws {ConflictError} If the request is not pending.
 * @throws {ForbiddenError} If the user is not authorized to accept the request.
 * @returns {Promise<{ message: string }>} A success message.
 */
export async function acceptFriendRequest(friendshipId: number, currentUserId: number): Promise<{ message: string }> {
	const friendship = await friendModel.getFriendshipByIdInDb(friendshipId);

	if (!friendship) {
		throw new NotFoundError('Friend request not found.');
	}
	if (friendship.status !== FriendshipStatus.PENDING) {
		throw new ConflictError(`This friend request is already '${friendship.status}'.`);
	}
	if (friendship.initiator_id === currentUserId) {
		throw new ForbiddenError("You cannot accept a friend request you initiated.");
	}
	if (friendship.user1_id !== currentUserId && friendship.user2_id !== currentUserId) {
		throw new ForbiddenError("You are not part of this friendship request.");
	}

	const result = await friendModel.updateFriendshipStatusInDb(friendshipId, FriendshipStatus.ACCEPTED);
	if (result.changes === 0) {
		throw new Error('Failed to accept friend request, database reported no changes.');
	}
	return { message: 'Friend request accepted.' };
}

/**
 * Declines or cancels a friend request, or removes an existing friendship.
 * @param {number} friendshipId - ID of the friendship.
 * @param {number} currentUserId - ID of the user performing the action.
 * @throws {NotFoundError} If the friendship does not exist.
 * @throws {ForbiddenError} If the user is not part of the friendship.
 * @returns {Promise<Object>} A success message.
 */
export async function declineOrCancelFriendRequest(friendshipId: number, currentUserId: number): Promise<{ message: string }> {
	const friendship = await friendModel.getFriendshipByIdInDb(friendshipId);

	if (!friendship) {
		throw new NotFoundError('Friendship or request not found.');
	}
	if (friendship.user1_id !== currentUserId && friendship.user2_id !== currentUserId) {
		throw new ForbiddenError("You are not part of this friendship.");
	}

	let actionMessage = '';
	if (friendship.status === 'pending') {
		if (friendship.initiator_id === currentUserId) {
			actionMessage = 'Friend request cancelled.';
		} else {
			actionMessage = 'Friend request declined.';
		}
		await friendModel.deleteFriendshipInDb(friendshipId);
	} else if (friendship.status === 'accepted') {
		await friendModel.deleteFriendshipInDb(friendshipId);
		actionMessage = 'Friend removed successfully.';
	} else {
		await friendModel.deleteFriendshipInDb(friendshipId);
		actionMessage = `Friendship with status '${friendship.status}' removed.`;
	}
	return { message: actionMessage };
}

/**
 * Retrieves the list of accepted friends for a user.
 * @param {number} userId - ID of the user.
 * @throws {NotFoundError} If the user does not exist.
 * @returns {Promise<Friend[]>} List of friends.
 */
export async function getFriends(userId: number): Promise<Friend[]> {
	const user = await userModel.getUserByIdFromDb(userId);
	if (!user) {
		throw new NotFoundError('User not found.');
	}
	return friendModel.getAcceptedFriendsForUserInDb(userId);
}

/**
 * Retrieves pending friend requests received by a user.
 * @param {number} userId - ID of the user.
 * @throws {NotFoundError} If the user does not exist.
 * @returns {Promise<PendingFriendRequest[]>} List of received friend requests.
 */
export async function getReceivedFriendRequests(userId: number): Promise<PendingFriendRequest[]> {
	const user = await userModel.getUserByIdFromDb(userId);
	if (!user) {
		throw new NotFoundError('User not found.');
	}
	return friendModel.getPendingReceivedFriendRequestsInDb(userId);
}

/**
 * Retrieves pending friend requests sent by a user.
 * @param {number} userId - ID of the user.
 * @throws {NotFoundError} If the user does not exist.
 * @returns {Promise<PendingFriendRequest[]>} List of sent friend requests.
 */
export async function getSentFriendRequests(userId: number): Promise<PendingFriendRequest[]> {
	const user = await userModel.getUserByIdFromDb(userId);
	if (!user) {
		throw new NotFoundError('User not found.');
	}
	return friendModel.getPendingSentFriendRequestsInDb(userId);
}

export async function removeFriendship(friendshipId: number, currentUserId: number): Promise<{ message: string }> {

	const friendship = await friendModel.getFriendshipByIdInDb(friendshipId);
	console.log('[removeFriendship] Called with friendshipId:', friendshipId, 'currentUserId:', currentUserId);
	console.log('[removeFriendship] DB result for friendship:', friendship);

	if (!friendship) {
		throw new NotFoundError('Friendship not found.');
	}
	if (friendship.user1_id !== currentUserId && friendship.user2_id !== currentUserId) {
		throw new ForbiddenError("You are not part of this friendship.");
	}
	if (friendship.status !== 'accepted') {
		throw new ConflictError('You can only remove an accepted friend.');
	}

	const result = await friendModel.deleteFriendshipInDb(friendshipId);
	if (result.changes === 0) {
		throw new Error('Failed to remove friend, database reported no changes.');
	}
	return { message: 'Friend removed successfully.' };
}

/**
 * Retrieves all friendships (admin only).
 * @returns {Promise<Friendship[]>} List of all friendships.
 */
export async function getAllFriendships(): Promise<Friendship[]> {
	return friendModel.getAllFriendshipsInDb();
}

/**
 * Blocks a user.
 * @param {number} blockerId - ID of the user blocking.
 * @param {number} blockedUserId - ID of the user to block.
 * @throws {ValidationError} If the blocker tries to block themselves.
 * @throws {NotFoundError} If the user to block does not exist.
 * @returns {Promise<{ message: string }>} A success message.
 */
export async function blockUser(
	blockerId: number,
	blockedUserId: number
): Promise<{ message: string }> {
	if (blockerId === blockedUserId) {
		throw new ValidationError("You cannot block yourself.");
	}
	const userToBlock = await userModel.getUserByIdFromDb(blockedUserId);
	if (!userToBlock) {
		throw new NotFoundError("User to block not found.");
	}

	const [id1, id2] = blockerId < blockedUserId ? [blockerId, blockedUserId] : [blockedUserId, blockerId];
	let friendship = await friendModel.getFriendshipByUsersInDb(id1, id2);

	if (friendship) {
		await friendModel.updateFriendshipStatusInDb(friendship.id, FriendshipStatus.BLOCKED);
	} else {
		friendship = await friendModel.createFriendshipRequestInDb(id1, id2, blockerId);
		await friendModel.updateFriendshipStatusInDb(friendship.id, FriendshipStatus.BLOCKED);
	}
	return { message: `User ${userToBlock.username} has been blocked.` };
}

/**
 * Unblocks a user.
 * @param {number} unblockerId - ID of the user unblocking.
 * @param {number} unblockedUserId - ID of the user to unblock.
 * @throws {NotFoundError} If no active block exists.
 * @returns {Promise<{ message: string }>} A success message.
 */
export async function unblockUser(
	unblockerId: number,
	unblockedUserId: number
): Promise<{ message: string }> {
	const [id1, id2] = unblockerId < unblockedUserId ? [unblockerId, unblockedUserId] : [unblockedUserId, unblockerId];
	const friendship = await friendModel.getFriendshipByUsersInDb(id1, id2);

	if (!friendship || friendship.status !== 'blocked') {
		throw new NotFoundError("No active block found for this user or you cannot unblock.");
	}
	await friendModel.deleteFriendshipInDb(friendship.id);
	return { message: "User has been unblocked. They can send/receive friend requests again." };
}
// app/services/users/models/friendModel.ts
// app/services/users/models/friendModel.ts
import { getDb } from '../utils/dbConfig.js';
import { Friendship, Friend, FriendshipStatus, PendingFriendRequest, AdminFullFriendship } from '../shared/schemas/friendsSchemas.js';

/**
 * Creates a new friendship request in the database.
 * @param {number} user1Id - ID of the first user.
 * @param {number} user2Id - ID of the second user.
 * @param {number} initiatorId - ID of the user initiating the request.
 * @returns {Promise<Friendship>} The created friendship object with its ID.
 */
export async function createFriendshipRequestInDb(user1Id: number, user2Id: number, initiatorId: number): Promise<Friendship> {
	const db = getDb();
	const [id1, id2] = user1Id < user2Id ? [user1Id, user2Id] : [user2Id, user1Id];
	const newFriendship = await db.get<Friendship>(
		`INSERT INTO friendships (user1_id, user2_id, initiator_id, status)
         VALUES (?, ?, ?, ?)
         RETURNING *`,
		[id1, id2, initiatorId, FriendshipStatus.PENDING]
	);


	if (!newFriendship) {
		throw new Error("Failed to create friendship or retrieve the created row using RETURNING.");
	}
	return newFriendship;
}

/**
 * Retrieves a specific friendship by the IDs of the two users.
 * @param {number} user1Id - ID of the first user.
 * @param {number} user2Id - ID of the second user.
 * @returns {Promise<Friendship | undefined>} The friendship object or undefined if not found.
 */
export async function getFriendshipByUsersInDb(user1Id: number, user2Id: number): Promise<Friendship | undefined> {
	const db = getDb();
	const [id1, id2] = user1Id < user2Id ? [user1Id, user2Id] : [user2Id, user1Id];
	return db.get<Friendship>(
		`SELECT * FROM friendships WHERE user1_id = ? AND user2_id = ?`,
		[id1, id2]
	);
}

/**
 * Retrieves a friendship by its ID.
 * @param {number} friendshipId - ID of the friendship.
 * @returns {Promise<Friendship | undefined>} The friendship object or undefined if not found.
 */
export async function getFriendshipByIdInDb(friendshipId: number): Promise<Friendship | undefined> {
	const db = getDb();
	return db.get<Friendship>(`SELECT * FROM friendships WHERE id = ?`, [friendshipId]);
}

interface UpdateResult {
	changes?: number;
}
/**
 * Updates the status of a friendship.
 * @param {number} friendshipId - ID of the friendship to update.
 * @param {string} status - New status ('accepted', 'declined', 'blocked').
 * @returns {Promise<UpdateResult>} The result of the database operation.
 */
export async function updateFriendshipStatusInDb(friendshipId: number, status: FriendshipStatus): Promise<UpdateResult> {
	const db = getDb();
	const result = await db.run(
		`UPDATE friendships SET status = ? WHERE id = ?`,
		[status, friendshipId]
	);
	return { changes: result.changes };
}

/**
 * Deletes a friendship from the database.
 * @param {number} friendshipId - ID of the friendship to delete.
 * @returns {Promise<UpdateResult>} The result of the database operation.
 */
export async function deleteFriendshipInDb(friendshipId: number): Promise<UpdateResult> {
	const db = getDb();
	const result = await db.run(`DELETE FROM friendships WHERE id = ?`, [friendshipId]);
	return { changes: result.changes };
}

/**
 * Retrieves all accepted friendships for a specific user.
 * Includes details about the friend (display_name, wins, losses, status, avatar_url).
 * @param {number} userId - ID of the user.
 * @returns {Promise<Friend[]>} List of friends with their details.
 */
export async function getAcceptedFriendsForUserInDb(userId: number): Promise<Friend[]> {
	const db = getDb();
	// Le query est long, on assume qu'il retourne les champs correspondants √† DetailedFriend
	const query = `
        SELECT
            f.id as friendship_id,
            f.status as friendship_status,
            CASE WHEN f.user1_id = ? THEN u2.id ELSE u1.id END as friend_id,
            CASE WHEN f.user1_id = ? THEN u2.display_name ELSE u1.display_name END as friend_display_name,
            CASE WHEN f.user1_id = ? THEN u2.username ELSE u1.username END as friend_username,
            CASE WHEN f.user1_id = ? THEN u2.wins ELSE u1.wins END as friend_wins,
            CASE WHEN f.user1_id = ? THEN u2.losses ELSE u1.losses END as friend_losses,
            CASE WHEN f.user1_id = ? THEN u2.status ELSE u1.status END as friend_online_status,
            CASE WHEN f.user1_id = ? THEN u2.avatar_url ELSE u1.avatar_url END as friend_avatar_url
        FROM friendships f
        JOIN users u1 ON f.user1_id = u1.id
        JOIN users u2 ON f.user2_id = u2.id
        WHERE (f.user1_id = ? OR f.user2_id = ?) AND f.status = 'accepted'
    `;
	return db.all<Friend[]>(query, userId, userId, userId, userId, userId, userId, userId, userId, userId);
}

/**
 * Retrieves all pending friend requests received by a user.
 * Includes details about the requester.
 * @param {number} userId - ID of the user who received the requests.
 * @returns {Promise<PendingFriendRequest[]>} List of received requests with requester details.
 */
export async function getPendingReceivedFriendRequestsInDb(userId: number): Promise<PendingFriendRequest[]> {
	const db = getDb();
	const query = `
        SELECT
            f.id as friendship_id, f.created_at,
            u_initiator.id, u_initiator.username, u_initiator.email,
            u_initiator.display_name, u_initiator.avatar_url
        FROM friendships f
        JOIN users u_initiator ON f.initiator_id = u_initiator.id
        WHERE (f.user1_id = ? OR f.user2_id = ?) AND f.status = 'pending' AND f.initiator_id != ?
        ORDER BY f.created_at DESC;
    `;
	const rows = await db.all<any[]>(query, userId, userId, userId); // any[] pour l'instant
	return rows.map(row => ({
		friendship_id: row.friendship_id,
		created_at: row.created_at,
		requester: {
			id: row.id, 
			username: row.username,
			display_name: row.display_name,
			avatar_url: row.avatar_url,
		},
	}));
}

/**
 * Retrieves all pending friend requests sent by a user.
 * Includes details about the receiver.
 * @param {number} userId - ID of the user who sent the requests.
 * @returns {Promise<PendingFriendRequest[]>} List of sent requests with receiver details.
 */
export async function getPendingSentFriendRequestsInDb(userId: number): Promise<PendingFriendRequest[]> {
	const db = getDb();
	const query = `
        SELECT
            f.id as friendship_id, f.created_at,
            CASE WHEN f.user1_id = f.initiator_id THEN u2.id ELSE u1.id END as id,
            CASE WHEN f.user1_id = f.initiator_id THEN u2.username ELSE u1.username END as username,
            CASE WHEN f.user1_id = f.initiator_id THEN u2.email ELSE u1.email END as email,
            CASE WHEN f.user1_id = f.initiator_id THEN u2.display_name ELSE u1.display_name END as display_name,
            CASE WHEN f.user1_id = f.initiator_id THEN u2.avatar_url ELSE u1.avatar_url END as avatar_url
        FROM friendships f
        JOIN users u1 ON f.user1_id = u1.id
        JOIN users u2 ON f.user2_id = u2.id
        WHERE f.initiator_id = ? AND f.status = 'pending'
        ORDER BY f.created_at DESC;
    `;
	const rows = await db.all<any[]>(query, userId); // any[] pour l'instant
	return rows.map(row => ({
		friendship_id: row.friendship_id,
		created_at: row.created_at,
		receiver: {
			id: row.id,
			username: row.username,
			display_name: row.display_name,
			avatar_url: row.avatar_url,
		},
	}));
}

/**
 * Retrieves all friendships, regardless of their status.
 * @returns {Promise<AdminFullFriendship[]>} List of all friendships.
 */
export async function getAllFriendshipsInDb(): Promise<AdminFullFriendship[]> {
	const db = getDb();
	return db.all<AdminFullFriendship[]>(`
        SELECT
            f.*, u1.username as user1_username, u2.username as user2_username, ui.username as initiator_username
        FROM friendships f
        JOIN users u1 ON f.user1_id = u1.id
        JOIN users u2 ON f.user2_id = u2.id
        JOIN users ui ON f.initiator_id = ui.id
    `);
}

/**
 * Retrieves a paginated list of friends for a specific user.
 * @param {number} userId - ID of the user.
 * @param {number} limit - Maximum number of friends to retrieve.
 * @param {number} offset - Number of records to skip.
 * @returns {Promise<Friendship[]>} List of friends with their details.
 */
export async function getFriends(userId: number, limit: number = 10, offset: number = 0): Promise<Friendship[]> {
	const db = getDb();
	const query = `
        SELECT * FROM friendships
        WHERE (user1_id = ? OR user2_id = ?) AND status = 'accepted'
        LIMIT ? OFFSET ?
    `;
	return db.all<Friendship[]>(query, userId, userId, limit, offset);
}
// app/services/users/models/userModel.ts
// app/services/users/models/userModel.ts
import { getDb } from '../utils/dbConfig.js';
import { ERROR_MESSAGES } from '../utils/appError.js';
import { User, UserWithPasswordHash, CreateUserPayload, UpdatedUserResult, UpdateUserPayload, UserOnlineStatus } from '../shared/schemas/usersSchemas.js'; // Importez vos types

/**
 * Retrieves all users from the database.
 * @returns {Promise<User[]>} A list of all users.
 */
export async function getAllUsersFromDb(): Promise<User[]> {
	const db = getDb();
	return db.all<User[]>('SELECT id, username, email, display_name, avatar_url, wins, losses, status, created_at, updated_at FROM users');
}

/**
 * Retrieves a user by their display name.
 * @param {string} displayName - The display name of the user.
 * @returns {Promise<UserWithPasswordHash | undefined>} The user object or undefined if not found.
 */
export async function getUserByDisplayNameFromDb(displayName: string): Promise<UserWithPasswordHash | undefined> {
	const db = getDb();
	return db.get<UserWithPasswordHash>('SELECT * FROM users WHERE display_name = ?', [displayName]);
}

/**
 * Retrieves a user by their username.
 * @param {string} username - The username of the user.
 * @returns {Promise<UserWithPasswordHash | undefined>} The user object or undefined if not found.
 */
export async function getUserByUsernameFromDb(username: string): Promise<UserWithPasswordHash | undefined> {
	const db = getDb();
	return db.get<UserWithPasswordHash>('SELECT * FROM users WHERE username = ?', [username]);
}

/**
 * Retrieves a user by their email.
 * @param {string} email - The email of the user.
 * @returns {Promise<UserWithPasswordHash | undefined>} The user object or undefined if not found.
 */
export async function getUserByEmailFromDb(email: string): Promise<UserWithPasswordHash | undefined> {
	const db = getDb();
	return db.get<UserWithPasswordHash>('SELECT * FROM users WHERE email = ?', [email]);
}

/**
 * Retrieves a user by their ID.
 * @param {number} userId - The ID of the user.
 * @returns {Promise<User | undefined>} The user object or undefined if not found.
 */
export async function getUserByIdFromDb(userId: number): Promise<User | undefined> {
	const db = getDb();
	return db.get<User>('SELECT id, username, email, display_name, avatar_url, wins, losses, status, created_at, updated_at FROM users WHERE id = ?', [userId]);
}

/**
 * Creates a new user in the database.
 * @param {CreateUserPayload} user - The user data to insert.
 * @returns {Promise<void>} 
 */
export async function createUser(
	{ username, email, password_hash, display_name, avatar_url = null }: CreateUserPayload
): Promise<void> {
	const db = getDb();
	const result = await db.run(
		`INSERT INTO users (username, email, password_hash, display_name, avatar_url) VALUES (?, ?, ?, ?, ?)`,
		[username, email, password_hash, display_name, avatar_url]
	);
	if (result.lastID === undefined) {
		throw new Error("Failed to create user, no lastID returned.");
	}
}

/**
 * Updates a user's details in the database.
 * @param {number} userId - The ID of the user to update.
 * @param {UpdateUserPayload} updates - The fields to update and their new values.
 * @returns {Promise<UpdatedUserResult>} The result of the database operation.
 * @throws {Error} If an error occurs during the update.
 */
export async function updateUserInDb(userId: number, updates: UpdateUserPayload): Promise<UpdatedUserResult> {
	const db = getDb();
	const fields = Object.keys(updates).filter(k => typeof k === 'string') as Array<keyof UpdateUserPayload>; // Cl√©s typ√©es
	if (fields.length === 0) {
		return { changes: 0 };
	}
	const setClause = fields.map((field) => `${String(field)} = ?`).join(', ');
	const values: (string | number)[] = fields.map((field) => updates[field] as string | number);

	const sql = `UPDATE users SET ${setClause}, updated_at = CURRENT_TIMESTAMP WHERE id = ?`;
	values.push(userId);

	try {
		const result = await db.run(sql, values);
		return { changes: result.changes };
	} catch (error: any) {
		console.error('Error updating user:', error);
		throw new Error(ERROR_MESSAGES.DATABASE_ERROR);
	}
}

export async function updateStatusInDb(userId: number, status: UserOnlineStatus): Promise<void> {
	const db = getDb();
	const sql = `UPDATE users SET status = ?, updated_at = CURRENT_TIMESTAMP WHERE id = ?`;
	const result = await db.run(sql, [status, userId]);
	if (result.changes === 0) {
		throw new Error(`User ${userId} not found or status unchanged.`);
	}
}

export async function deleteUserFromDb(userId: number): Promise<void> {
	const db = getDb();
	const result = await db.run('DELETE FROM users WHERE id = ?', [userId]);
	if (result.changes === 0) {
		throw new Error(ERROR_MESSAGES.USER_NOT_FOUND);
	}
}

export async function isUsernameInDb(username: string, id?: number): Promise<boolean> {
	const db = getDb();
	let query = 'SELECT EXISTS(SELECT 1 FROM users WHERE username = ?';
	const params: (string | number)[] = [username];
	if (id !== undefined) {
		query += ' AND id != ?';
		params.push(id);
	}
	query += ') AS "exists"';
	const row = await db.get<{ exists: number }>(query, params);
	return row?.exists === 1;
}

export async function isEmailInDb(email: string, id?: number): Promise<boolean> {
	const db = getDb();
	let query = 'SELECT EXISTS(SELECT 1 FROM users WHERE email = ?';
	const params: (string | number)[] = [email];
	if (id !== undefined) {
		query += ' AND id != ?';
		params.push(id);
	}
	query += ') AS "exists"';
	const row = await db.get<{ exists: number }>(query, params);
	return row?.exists === 1;
}

export async function isDisplayNameInDb(display_name: string, id?: number): Promise<boolean> {
	const db = getDb();
	let query = 'SELECT EXISTS(SELECT 1 FROM users WHERE display_name = ?';
	const params: (string | number)[] = [display_name];
	if (id !== undefined) {
		query += ' AND id != ?';
		params.push(id);
	}
	query += ') AS "exists"';
	const row = await db.get<{ exists: number }>(query, params);
	return row?.exists === 1;
}
// app/services/users/db/init.sql
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT UNIQUE NOT NULL,
    email TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    display_name TEXT UNIQUE NOT NULL,
    avatar_url TEXT,
    wins INTEGER DEFAULT 0,
    losses INTEGER DEFAULT 0,
    status TEXT NOT NULL DEFAULT 'offline',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS friendships (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user1_id INTEGER NOT NULL,
    user2_id INTEGER NOT NULL,
    initiator_id INTEGER NOT NULL,
    status TEXT NOT NULL DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY(user1_id) REFERENCES users(id),
    FOREIGN KEY(user2_id) REFERENCES users(id),
    FOREIGN KEY(initiator_id) REFERENCES users(id),
    CONSTRAINT user_order CHECK (user1_id < user2_id),
    CONSTRAINT unique_pair UNIQUE (user1_id, user2_id)
);

INSERT OR IGNORE INTO users (username, email, password_hash, display_name, avatar_url)
VALUES
	('Serge', 'serge@student.42.fr', '$2b$10$3Gy9uzvm61CTJ0kuPN3FYu1vJrmylnrmKNmkdoHNTF2owheMzkucu', 'Serge P', 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSq2Q26rH3nI4ossmbYm8jpCyYwuytbyk6iYXJ4_C4tO8FFgv4Wk488h9CB24G5jB46Qjk&usqp=CAU'),
	('Xavier', 'xavier@student.42.fr', '$2b$10$3Gy9uzvm61CTJ0kuPN3FYu1vJrmylnrmKNmkdoHNTF2owheMzkucu', 'Xavier N', 'https://www.lemediaplus.com/wp-content/uploads/2023/02/Xavier-niel-fortune.png'),
	('Donkey_Kong', 'donkeyKong@nitendo.com', '$2b$10$3Gy9uzvm61CTJ0kuPN3FYu1vJrmylnrmKNmkdoHNTF2owheMzkucu', 'Donkey Kong', 'https://m1.quebecormedia.com/emp/emp/dk1b93f6bb-34a1-498c-8234-fb9c7c6f794a_ORIGINAL.jpg?impolicy=crop-resize&x=0&y=0&w=1200&h=675&width=925'),
	('jane_doe', 'jane@example.com', '$2b$10$3Gy9uzvm61CTJ0kuPN3FYu1vJrmylnrmKNmkdoHNTF2owheMzkucu', 'Jane Doe', 'https://ui-avatars.com/api/?name=Jane+Doe&background=random&color=fff&size=128'),
	('alice_smith', 'alice@example.com', '$2b$10$3Gy9uzvm61CTJ0kuPN3FYu1vJrmylnrmKNmkdoHNTF2owheMzkucu', 'Alice Smith', 'https://gravatar.com/avatar/3bd177d6fdf72eecc626c6cc19dfbdc6?s=400&d=identicon&r=g'),
	('Alexis B', 'alexb@example.com', '$2b$10$3Gy9uzvm61CTJ0kuPN3FYu1vJrmylnrmKNmkdoHNTF2owheMzkucu', 'Alexis le Brun', 'https://media.ouest-france.fr/v1/pictures/MjAyMzA5NjIyNGQ3MmNlNzkyNTdjYzgwY2IyNDllOWQ2MmQzYzM?width=1260&height=708&focuspoint=50%2C36&cropresize=1&client_id=bpeditorial&sign=06fccb8b939b1ef4f9042a38edab621665dc6428590f6fa79a643ed33535af5f');



INSERT OR IGNORE INTO friendships (user1_id, user2_id, initiator_id, status)
VALUES
    (1, 5, 1, 'accepted'),-- Serge et alice sont amis (Serge a initi√©)
    (1, 4, 4, 'accepted'),-- Serge et jane sont amis (jane a initi√©)
    (1, 3, 3, 'pending'),-- Donkey_kong a envoy√© une demande d'ami √† Serge (en attente)
    (1, 2, 2, 'pending'),-- Xavier a envoy√© une demande d'ami √† Serge (en attente)
    (2, 5, 5, 'blocked');-- Alice a bloqu√© Xavier
// app/services/users/server.ts
import Fastify, { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { validatorCompiler, serializerCompiler, ZodTypeProvider } from 'fastify-type-provider-zod';
import { config } from './shared/env.js';
import { initializeDb } from './utils/dbConfig.js';
import { setupPlugins } from './shared/auth-plugin/tokens.js';
import { setupErrorHandler } from './utils/appError.js';
import friendRoutes from './routes/friends.js';
import userRoutes from './routes/users.js';
import authRoutes from './routes/auth.js';


// const fastify: FastifyInstance = Fastify({ logger: { level: config.LOG_LEVEL } });
const fastify: FastifyInstance = Fastify({ logger: { level: config.LOG_LEVEL } }).withTypeProvider<ZodTypeProvider>();

fastify.setValidatorCompiler(validatorCompiler);
fastify.setSerializerCompiler(serializerCompiler);

function setupHooks(): void {
	fastify.addHook('onRequest', async (req: FastifyRequest, reply: FastifyReply) => {
		if (fastify.log.level === 'trace') {
			req.log.trace({ path: req.raw.url, cookies: req.cookies, headers: req.headers }, '[Logging Hook]');
		} else {
			req.log.debug({ path: req.raw.url, method: req.method }, '[Request Received]');
		}
	});
	fastify.log.info('Logging onRequest hook registered');
}

function setupRoutes(): void {
	fastify.get('/api/users/csrf-token', async (request: FastifyRequest, reply: FastifyReply) => {
		const token: string = await reply.generateCsrf();
		request.log.debug(`[CSRF Endpoint] Token CSRF fourni au client: ${token}`);
		return { csrfToken: token };
	});
	fastify.log.info('CSRF token endpoint /api/users/csrf-token registered');

	fastify.register(userRoutes);
	fastify.register(authRoutes);
	fastify.register(friendRoutes);
	fastify.log.info('Routes registered');
}

async function buildApp(): Promise<FastifyInstance> {
	try {
		await initializeDb();
		fastify.log.info('Database initialized');
		await setupPlugins(fastify);
		setupErrorHandler(fastify);
		setupHooks();
		setupRoutes();
		return fastify;
	} catch (err: any) {
		fastify.log.error({ err: err.message, stack: err.stack }, 'Error initializing app');
		process.exit(1);
	}
}

async function start() {
	let app: FastifyInstance | undefined;
	try {
		app = await buildApp();
		await app.listen({ port: config.API_USER_PORT, host: '0.0.0.0' });
		const address = app.server.address();
		const port = typeof address === 'string' ? address : (address?.port);
		app.log.info(`Server listening on ${port || 'unknown port'}`);
	} catch (err: any) {
		const logger = app?.log || console;
		logger.error({ err: err.message, stack: err.stack }, 'Failed to start server:');
		process.exit(1);
	}
}

start();
// app/services/users/handlers/friendsHandlers.ts
import { FastifyRequest, FastifyReply } from 'fastify';
import * as friendService from '../services/friendService.js';
import { ERROR_MESSAGES, AppError } from '../utils/appError.js';
import { JWTPayload } from '../shared/schemas/usersSchemas.js';

// Types pour les requ√™tes avec params
interface FriendshipIdRequest extends FastifyRequest<{ Params: { friendshipId: string } }> {
	user: JWTPayload;
}
interface BlockUserRequest extends FastifyRequest<{ Params: { userIdToBlock: string } }> {
	user: JWTPayload;
}
interface UnblockUserRequest extends FastifyRequest<{ Params: { userIdToUnblock: string } }> {
	user: JWTPayload;
}

export async function sendFriendRequestHandler(req: FastifyRequest, reply: FastifyReply) {
	const requesterId = (req.user as JWTPayload).id;
	const { friendId } = req.body as { friendId: number };

	req.log.info({ requesterId, friendId }, 'Attempting to send friend request');
	const newFriendship = await friendService.sendFriendRequest(requesterId, friendId);
	return reply.code(201).send({
		message: 'Friend request sent successfully.',
		friendship: newFriendship
	});
}

export async function getReceivedRequestsHandler(req: FastifyRequest, reply: FastifyReply) {
	const userId = (req.user as JWTPayload).id;
	req.log.info({ userId }, 'Fetching received friend requests');
	const requests = await friendService.getReceivedFriendRequests(userId);
	return reply.send(requests);
}

export async function getSentRequestsHandler(req: FastifyRequest, reply: FastifyReply) {
	const userId = (req.user as JWTPayload).id;
	req.log.info({ userId }, 'Fetching sent friend requests');
	const requests = await friendService.getSentFriendRequests(userId);
	return reply.send(requests);
}

export async function acceptFriendRequestHandler(req: FastifyRequest, reply: FastifyReply) {
	const currentUserId = (req.user as JWTPayload).id;
	const friendshipId = parseInt((req.params as any).friendshipId, 10);

	req.log.info({ currentUserId, friendshipId }, 'Attempting to accept friend request');
	const result = await friendService.acceptFriendRequest(friendshipId, currentUserId);
	return reply.send(result);
}

export async function declineFriendRequestHandler(req: FastifyRequest, reply: FastifyReply) {
	const currentUserId = (req.user as JWTPayload).id;
	const friendshipId = parseInt((req.params as any).friendshipId, 10);

	if (isNaN(friendshipId)) {
		throw new AppError(ERROR_MESSAGES.INVALID_FRIENDSHIP_ID, 400);
	}

	req.log.info({ currentUserId, friendshipId }, 'Attempting to decline friend request');
	const result = await friendService.declineOrCancelFriendRequest(friendshipId, currentUserId);
	return reply.send(result);
}

export async function cancelFriendRequestHandler(req: FastifyRequest, reply: FastifyReply) {
	const currentUserId = (req.user as JWTPayload).id;
	const friendshipId = parseInt((req.params as any).friendshipId, 10);

	if (isNaN(friendshipId)) {
		throw new AppError(ERROR_MESSAGES.INVALID_FRIENDSHIP_ID, 400);
	}

	req.log.info({ currentUserId, friendshipId }, 'Attempting to cancel friend request');
	const result = await friendService.declineOrCancelFriendRequest(friendshipId, currentUserId);
	return reply.send(result);
}

export async function getMyFriendsHandler(req: FastifyRequest, reply: FastifyReply) {
	const userId = (req.user as JWTPayload).id;
	req.log.info({ userId }, 'Fetching user friends list');
	const friends = await friendService.getFriends(userId);
	return reply.send(friends);
}

export async function removeFriendshipHandler( req: FastifyRequest, reply: FastifyReply ) {
	const currentUserId = (req.user as JWTPayload).id;
	const friendshipId = parseInt((req.params as any).friendshipId, 10);

	if (isNaN(friendshipId)) {
		return reply.code(400).send({ error: "Invalid friendship ID." });
	}
	req.log.info({ currentUserId, friendshipId }, 'Attempting to remove friendship');
	const result = await friendService.removeFriendship(friendshipId, currentUserId);
	return reply.send(result);
}

export async function blockUserHandler(req: BlockUserRequest, reply: FastifyReply) {
	const blockerId = req.user.id;
	const userIdToBlock = parseInt(req.params.userIdToBlock, 10);

	if (isNaN(userIdToBlock)) {
		throw new AppError('Invalid user ID to block.', 400);
	}
	req.log.info({ blockerId, userIdToBlock }, 'Attempting to block user');
	const result = await friendService.blockUser(blockerId, userIdToBlock);
	return reply.send(result);
}

export async function unblockUserHandler(req: UnblockUserRequest, reply: FastifyReply) {
	const unblockerId = req.user.id;
	const userIdToUnblock = parseInt(req.params.userIdToUnblock, 10);

	if (isNaN(userIdToUnblock)) {
		throw new AppError('Invalid user ID to unblock.', 400);
	}
	req.log.info({ unblockerId, userIdToUnblock }, 'Attempting to unblock user');
	const result = await friendService.unblockUser(unblockerId, userIdToUnblock);
	return reply.send(result);
}

export async function getAllFriendshipsHandler(req: FastifyRequest, reply: FastifyReply) {
	req.log.info('Admin fetching all friendships');
	const friendships = await friendService.getAllFriendships();
	return reply.send(friendships);
}
// app/services/users/handlers/userHandlers.ts
// G√®re les requ√™tes Fastify (req, reply)
import { FastifyRequest, FastifyReply } from 'fastify';
import * as userService from '../services/userService.js';
import { UserIdParams, UpdateUserPayload, JWTPayload } from '../shared/schemas/usersSchemas.js';

type AuthenticatedRequest = FastifyRequest & { user: JWTPayload };

export async function getUsersHandler(req: FastifyRequest, reply: FastifyReply) {
	const users = await userService.getAllUsers();
	return reply.code(200).send(users);
}

export async function getUserMeHandler(req: AuthenticatedRequest, reply: FastifyReply) {
	const user = await userService.getUserById(req.user.id);
	return reply.code(200).send(user);
}

export async function updateUserMeHandler(req: AuthenticatedRequest, reply: FastifyReply) {
	const userId = req.user.id;
	const updates = req.body as UpdateUserPayload;

	req.log.info({ userId, updates }, 'Attempting to update user profile');
	const updatedUser = await userService.updateUserProfile(userId, updates);

	return reply.code(200).send({
		message: 'User updated successfully',
		user: updatedUser
	});
}

export async function getUserInfoHandler(req: AuthenticatedRequest, reply: FastifyReply) {
	const userId = parseInt((req.params as UserIdParams).userId, 10);

	if (isNaN(userId)) {
		return reply.code(400).send({ error: 'Invalid user ID.' });
	}

	const user = await userService.getUserById(userId);
	if (!user) {
		return reply.code(404).send({ error: 'User not found.' });
	}

	return reply.code(200).send(user);
}
// app/services/users/handlers/authHandlers.ts
import { FastifyRequest, FastifyReply } from 'fastify';
import { createUserAccount, loginUser, updateUserStatus } from '../services/userService.js';
import { jwtToken, cookieOptions, csrfCookieName, csrfOptions } from '../shared/auth-plugin/tokens.js';
import { ERROR_MESSAGES } from '../utils/appError.js';
import { JWTPayload, RegisterRequestBody, LoginRequestBody, UserOnlineStatus } from '../shared/schemas/usersSchemas.js';

export async function registerHandler(req: FastifyRequest<{ Body: RegisterRequestBody }>, reply: FastifyReply) {
	await createUserAccount(req.body);

	return reply.code(201).send({
		message: 'Registration successful. Please log in.'
	});
}

export async function loginHandler(req: FastifyRequest<{ Body: LoginRequestBody }>, reply: FastifyReply) {
	const user = await loginUser(req.body);
	const tokenPayload: JWTPayload = { id: user.id, username: user.username };
	const token = reply.server.jwt.sign(tokenPayload);
	const decodedToken = reply.server.jwt.decode(token) as { exp: number };
	await updateUserStatus(user.id, UserOnlineStatus.ONLINE);

	reply.setCookie(jwtToken, token, {
		...cookieOptions,
		expires: new Date(decodedToken.exp * 1000),
	});

	return reply.send({
		message: 'Login accepted',
		user,
	});
}

export async function logoutHandler(req: FastifyRequest, reply: FastifyReply) {
	const id = (req.user as JWTPayload).id;
	await updateUserStatus(id, UserOnlineStatus.OFFLINE);
	reply.clearCookie(jwtToken, cookieOptions);
	reply.clearCookie(csrfCookieName, csrfOptions);
	return reply.send({ message: 'Logout successful' });
}

export async function refreshTokenHandler(req: FastifyRequest, reply: FastifyReply) {
	const refreshToken = (req.cookies as any).refreshToken;
	if (!refreshToken) {
		return reply.code(401).send({ error: ERROR_MESSAGES.REFRESH_TOKEN_MISSING });
	}

	try {
		const decoded = reply.server.jwt.verify(refreshToken, { ignoreExpiration: false }) as JWTPayload & { exp: number };
		const newToken = reply.server.jwt.sign({ id: decoded.id, username: decoded.username });
		reply.setCookie(jwtToken, newToken, {
			...cookieOptions,
			expires: new Date(decoded.exp * 1000),
		});
		return reply.send({ message: 'Token refreshed successfully' });
	} catch (err) {
		return reply.code(401).send({ error: ERROR_MESSAGES.INVALID_REFRESH_TOKEN });
	}
}
// app/services/users/.dockerignore
# Node modules (can be installed with npm install)
node_modules/
# ignore git history
.git
# ignore cache directory
.DS_Store// app/services/users/package.json
{
  "name": "users",
  "version": "1.0.0",
  "main": "dist/server.js",
  "type": "module",
  "description": "Fastify app with SQLite",
  "scripts": {
    "clean": "rm -rf dist",
    "build": "npm run clean && tsc",
    "start": "node dist/server.js",
    "dev": "npm run build && concurrently \"tsc -w\" \"nodemon dist/server.js\" | pino-pretty",
    "start:dev": "node --inspect dist/server.js"
},
  "dependencies": {
    "@fastify/static": "^6.0.1",
    "@fastify/jwt": "^9.1.0",
    "@fastify/cookie": "^11.0.2",
    "@fastify/csrf-protection": "^7.1.0",
    "fastify": "^5.3.2",
    "concurrently": "^9.1.2",
    "dotenv": "^16.5.0",
    "bcrypt": "^5.1.1",
    "sqlite3": "^5.1.7",
    "sqlite": "^5.1.1",
    "fastify-type-provider-zod": "^4.0.2",
	"zod": "^3.24.4"
  },
  "devDependencies": {
    "typescript": "^5.3.3",
    "@types/node": "^22.15.18",
    "@types/bcrypt": "^5.0.2",
    "@types/sqlite3": "^5.1.0",
	"pino": "^9.6.0",
	"pino-pretty": "^13.0.0",
    "nodemon": "^3.1.10",
    "dotenv-cli": "^8.0.0"
  }
}
// app/services/users/routes/users.ts
import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import {
	getUsersHandler,
	getUserMeHandler,
	getUserInfoHandler,
	updateUserMeHandler,
} from '../handlers/userHandlers.js';
import { config } from '../shared/env.js';
import { UpdateUserRouteSchema, GetUserByIdRouteSchema, GetUsersListRouteSchema, GetMeRouteSchema } from '../shared/schemas/usersSchemas.js';


export default async function userRoutes(fastify: FastifyInstance, options: FastifyPluginOptions) {
	fastify.get(
		config.URL_ALL_USERS,
		{
			onRequest: [fastify.authenticate],
			schema: GetUsersListRouteSchema
		},
		getUsersHandler
	);

	fastify.get(
		config.URL_USER_ME,
		{
			onRequest: [fastify.authenticate],
			schema: GetMeRouteSchema
		},
		getUserMeHandler
	);

	fastify.get(
		config.URL_USER,
		{
			onRequest: [fastify.authenticate],
			schema: GetUserByIdRouteSchema
		},
		getUserInfoHandler
	);

	fastify.patch(
		config.URL_USER_ME,
		{
			onRequest: [fastify.authenticate, fastify.csrfProtection],
			schema: UpdateUserRouteSchema
		},
		updateUserMeHandler
	);
}
// app/services/users/routes/auth.ts
import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { config } from '../shared/env.js'
import { loginHandler, logoutHandler, registerHandler } from '../handlers/authHandlers.js';
import { RegisterRouteSchema, LoginRouteSchema, LogoutRouteSchema } from '../shared/schemas/usersSchemas.js';

export default async function authRoute(fastify: FastifyInstance, options: FastifyPluginOptions) {
	fastify.post(
		config.URL_LOGIN,
		{ schema: LoginRouteSchema },
		loginHandler
	);
	fastify.post(
		config.URL_REGISTER,
		{ schema: RegisterRouteSchema },
		registerHandler
	);
	fastify.post(
		config.URL_LOGOUT,
		{
			schema: LogoutRouteSchema,
			onRequest: [fastify.authenticate, fastify.csrfProtection],
		},
		logoutHandler
	);
}
// app/services/users/routes/friends.ts
import { FastifyInstance, FastifyPluginOptions } from 'fastify';
import { SendFriendRequestRouteSchema, FriendshipActionRouteSchema, GetFriendsListRouteSchema, GetPendingRequestsRouteSchema } from "../shared/schemas/friendsSchemas.js";
import { config } from "../shared/env.js";
import {
	acceptFriendRequestHandler,
	declineFriendRequestHandler,
	getReceivedRequestsHandler,
	getSentRequestsHandler,
	sendFriendRequestHandler,
	cancelFriendRequestHandler,
	getMyFriendsHandler,
	removeFriendshipHandler,
} from "../handlers/friendsHandlers.js";

export default async function friendRoutes(fastify: FastifyInstance, options: FastifyPluginOptions) {
	fastify.post(
		config.URL_FRIEND_REQUEST,
		{
			onRequest: [fastify.authenticate, fastify.csrfProtection],
			schema: SendFriendRequestRouteSchema
		},
		sendFriendRequestHandler
	);
	fastify.get(
		config.URL_FRIEND_RECEIVED,
		{
			onRequest: [fastify.authenticate],
			schema: GetPendingRequestsRouteSchema
		},
		getReceivedRequestsHandler
	);
	fastify.get(
		config.URL_FRIEND_SENT,
		{
			onRequest: [fastify.authenticate],
			schema: GetPendingRequestsRouteSchema
		},
		getSentRequestsHandler
	);
	fastify.post(
		config.URL_FRIEND_ACCEPT,
		{
			onRequest: [fastify.authenticate, fastify.csrfProtection],
			schema: FriendshipActionRouteSchema
		},
		acceptFriendRequestHandler
	);
	fastify.post(
		config.URL_FRIEND_DECLINE,
		{
			onRequest: [fastify.authenticate, fastify.csrfProtection],
			schema: FriendshipActionRouteSchema
		},
		declineFriendRequestHandler
	);
	fastify.post(
		config.URL_FRIEND_CANCEL,
		{
			onRequest: [fastify.authenticate, fastify.csrfProtection],
			schema: FriendshipActionRouteSchema
		},
		cancelFriendRequestHandler
	);
	fastify.get(
		config.URL_FRIEND_LIST,
		{
			onRequest: [fastify.authenticate],
			schema: GetFriendsListRouteSchema
		},
		getMyFriendsHandler
	);
	fastify.post(
		config.URL_FRIEND_REMOVE,
		{
			onRequest: [fastify.authenticate, fastify.csrfProtection],
			schema: FriendshipActionRouteSchema
		},
		removeFriendshipHandler
	);
};
// app/services/users/tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "rootDir": "./", // Tous les fichiers .ts sont √† la racine ou dans des sous-dossiers
    "outDir": "./dist", // O√π les fichiers .js compil√©s iront
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true, // Impose la casse correcte des noms de fichiers
    "strict": true,
    "skipLibCheck": true, // Acc√©l√®re la compilation en ne v√©rifiant pas les .d.ts des libs
    "resolveJsonModule": true, // Permet d'importer des fichiers .json
    "sourceMap": true, // G√©n√®re les sourcemaps pour le d√©bogage
    "allowJs": true,
  },
  "include": ["**/*.ts", "../../frontend/conf/utils/config.ts"],
  "exclude": [
    "node_modules",
    "dist"
  ]
}
